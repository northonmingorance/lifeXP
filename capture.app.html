<body data-app-id="capture">

    <template id="capture-icon-template">
        <div class="icon-image">ðŸ“¹</div>
        <div class="icon-label">Capture</div>
    </template>

    <template id="capture-window-template">
        <div class="xp-window" id="captureWindow" style="display:none;">
            <div class="title-bar">
                <span class="title-bar-text">Capture</span>
                <div class="title-bar-controls">
                    <button data-app-action="minimize" title="Minimize">0</button>
                    <button data-app-action="maximize" title="Maximize">1</button>
                    <button data-app-action="close" title="Close">r</button>
                </div>
            </div>
            <div class="xp-menu-bar" id="captureMenuBar" style="background-color: #ECE9D8; border-bottom: 1px solid #000; display: flex; padding: 1px 2px; height: 21px; flex-shrink: 0; user-select: none; position: relative; z-index: 50;">
                <div class="xp-menu-item" id="captureVideoMenu" style="padding: 2px 7px; cursor: default; position: relative; font-size: 11px; line-height: 16px;">
                    <span>Video</span>
                    <div class="xp-dropdown-menu" id="captureVideoDropdown" style="display: none; position: absolute; top: 100%; left: 0; background-color: #ECE9D8; border: 1px solid #7F7F7F; box-shadow: 1px 1px 2px rgba(0,0,0,0.1), -1px -1px 2px rgba(0,0,0,0.1); min-width: 160px; z-index: 150; padding: 2px;">
                        <div class="xp-dropdown-item" id="captureVideoDeviceItem" style="padding: 4px 12px; cursor: default; display: flex; justify-content: space-between; align-items: center; position: relative; font-size: 11px; white-space: nowrap; color: #000000;">
                            Device <span class="xp-submenu-arrow" style="font-size: 10px; position: absolute; right: 5px; top: 50%; transform: translateY(-50%); color: #333;">â–º</span>
                            <div class="xp-submenu" id="captureVideoDeviceList" style="display: none; position: absolute; left: calc(100% - 4px); top: -3px; background-color: #ECE9D8; border: 1px solid #7F7F7F; box-shadow: 1px 1px 2px rgba(0,0,0,0.1), -1px -1px 2px rgba(0,0,0,0.1); min-width: 180px; max-width: 250px; z-index: 151; padding: 2px; color: #000000;"></div>
                        </div>
                        <div class="xp-dropdown-item" id="captureVideoResolutionItem" style="padding: 4px 12px; cursor: default; display: flex; justify-content: space-between; align-items: center; position: relative; font-size: 11px; white-space: nowrap; color: #000000;">
                            Resolution <span class="xp-submenu-arrow" style="font-size: 10px; position: absolute; right: 5px; top: 50%; transform: translateY(-50%); color: #333;">â–º</span>
                            <div class="xp-submenu" id="captureVideoResolutionList" style="display: none; position: absolute; left: calc(100% - 4px); top: -3px; background-color: #ECE9D8; border: 1px solid #7F7F7F; box-shadow: 1px 1px 2px rgba(0,0,0,0.1), -1px -1px 2px rgba(0,0,0,0.1); min-width: 180px; max-width: 250px; z-index: 151; padding: 2px; color: #000000;"></div>
                        </div>
                    </div>
                </div>
                <div class="xp-menu-item" id="captureAudioMenu" style="padding: 2px 7px; cursor: default; position: relative; font-size: 11px; line-height: 16px;">
                    <span>Audio</span>
                    <div class="xp-dropdown-menu" id="captureAudioDropdown" style="display: none; position: absolute; top: 100%; left: 0; background-color: #ECE9D8; border: 1px solid #7F7F7F; box-shadow: 1px 1px 2px rgba(0,0,0,0.1), -1px -1px 2px rgba(0,0,0,0.1); min-width: 160px; z-index: 150; padding: 2px;">
                        <div class="xp-dropdown-item" id="captureAudioDeviceItem" style="padding: 4px 12px; cursor: default; display: flex; justify-content: space-between; align-items: center; position: relative; font-size: 11px; white-space: nowrap; color: #000000;">
                            Device <span class="xp-submenu-arrow" style="font-size: 10px; position: absolute; right: 5px; top: 50%; transform: translateY(-50%); color: #333;">â–º</span>
                            <div class="xp-submenu" id="captureAudioDeviceList" style="display: none; position: absolute; left: calc(100% - 4px); top: -3px; background-color: #ECE9D8; border: 1px solid #7F7F7F; box-shadow: 1px 1px 2px rgba(0,0,0,0.1), -1px -1px 2px rgba(0,0,0,0.1); min-width: 180px; max-width: 250px; z-index: 151; padding: 2px; color: #000000;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="window-body" id="captureWindowBody" style="padding:0; display:flex; background-color:#000; justify-content:center; align-items:center; position:relative;">
                <video id="captureVideoElement" autoplay playsinline style="width:100%; height:100%; transform:scaleX(-1); object-fit:contain;"></video>
                <button id="captureActionBtn" class="xp-button" style="position:absolute; bottom:20px; left:50%; transform:translateX(-50%); z-index:10; padding:8px 15px; font-size:14px;">Take Photo</button>
                <button id="captureToggleModeBtn" class="xp-button" style="position:absolute; bottom:20px; right:20px; z-index:10; padding:4px 15px; font-size:18px; min-width:auto;">ðŸ“¹</button>
            </div>
            <div class="resize-handle"></div>
        </div>
    </template>

    <script type="application/json" id="capture-config">
    {
        "minWidth": 320,
        "minHeight": 280,
        "defaultWidth": 400,
        "defaultHeight": 350,
        "defaultOffsetX": 270,
        "defaultOffsetY": 270
    }
    </script>

    <script id="capture-script">
    const appWindow = this.appWindow;
    const appData = this.appData; // Managed by OS
    const os = this.os;

    const COMMON_RESOLUTIONS = [
        { label: "Default", width: null, height: null }, // Added Default
        { label: "320x240 (QVGA)", width: 320, height: 240 },
        { label: "640x480 (VGA)", width: 640, height: 480 },
        { label: "800x600 (SVGA)", width: 800, height: 600 },
        { label: "1280x720 (HD)", width: 1280, height: 720 },
        { label: "1920x1080 (FHD)", width: 1920, height: 1080 }
    ];
    let currentStream = null;
    let mediaRecorder = null;
    let recordedChunks = [];
    let resolutionChangeDelayTimer = null;
    let isResolutionChangeDelayed = false;


    const DOM = {
        videoElement: appWindow.querySelector('#captureVideoElement'),
        actionBtn: appWindow.querySelector('#captureActionBtn'),
        toggleModeBtn: appWindow.querySelector('#captureToggleModeBtn'),
        menuBar: appWindow.querySelector('#captureMenuBar'),
        videoMenu: appWindow.querySelector('#captureVideoMenu'),
        videoDropdown: appWindow.querySelector('#captureVideoDropdown'),
        videoDeviceItem: appWindow.querySelector('#captureVideoDeviceItem'),
        videoDeviceList: appWindow.querySelector('#captureVideoDeviceList'),
        videoResolutionItem: appWindow.querySelector('#captureVideoResolutionItem'),
        videoResolutionList: appWindow.querySelector('#captureVideoResolutionList'),
        audioMenu: appWindow.querySelector('#captureAudioMenu'),
        audioDropdown: appWindow.querySelector('#captureAudioDropdown'),
        audioDeviceItem: appWindow.querySelector('#captureAudioDeviceItem'),
        audioDeviceList: appWindow.querySelector('#captureAudioDeviceList'),
        windowBody: appWindow.querySelector('#captureWindowBody')
    };
    
    function initializeDefaultAppData() {
        if (appData.mode === undefined) appData.mode = 'photo'; // 'photo' or 'video'
        if (appData.isRecording === undefined) appData.isRecording = false;
        if (appData.selectedVideoDevice === undefined) appData.selectedVideoDevice = null;
        if (appData.selectedAudioDevice === undefined) appData.selectedAudioDevice = null;
        if (appData.selectedResolution === undefined) appData.selectedResolution = null; // Store as {width, height} or null for default
    }
    initializeDefaultAppData();

    async function startCapture(videoDeviceId = appData.selectedVideoDevice, audioDeviceId = appData.selectedAudioDevice, resolution = appData.selectedResolution) {
        await stopCapture(); // Ensure previous stream is stopped
        DOM.windowBody.innerHTML = ''; // Clear previous error messages
        DOM.windowBody.appendChild(DOM.videoElement);
        DOM.windowBody.appendChild(DOM.actionBtn);
        DOM.windowBody.appendChild(DOM.toggleModeBtn);

        const constraints = { video: {}, audio: {} };
        if (videoDeviceId) constraints.video.deviceId = { exact: videoDeviceId }; else constraints.video = true;
        if (audioDeviceId) constraints.audio.deviceId = { exact: audioDeviceId }; else constraints.audio = true;
        
        if (resolution && resolution.width && resolution.height) {
            constraints.video.width = { exact: resolution.width };
            constraints.video.height = { exact: resolution.height };
        }

        try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                 DOM.windowBody.innerHTML = '<p style="color:white; padding:10px; text-align:center;">Webcam/mic access not supported.</p>'; return;
            }
            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            DOM.videoElement.srcObject = currentStream;
            DOM.videoElement.muted = true; // Important for preventing feedback loop if mic is on
            
            // Update selected devices if they were auto-selected by browser
            const videoTracks = currentStream.getVideoTracks();
            if (videoTracks.length > 0 && !videoDeviceId) appData.selectedVideoDevice = videoTracks[0].getSettings().deviceId;
            const audioTracks = currentStream.getAudioTracks();
            if (audioTracks.length > 0 && !audioDeviceId) appData.selectedAudioDevice = audioTracks[0].getSettings().deviceId;

            os.saveAppData();
            updateMenuSelections();

        } catch (err) {
            let msg = `Error: ${err.name}. ${err.message}. Try other settings.`;
            if (err.name === "OverconstrainedError") msg = `Selected resolution likely not supported. Try default. Error: ${err.message}`;
            DOM.windowBody.innerHTML = `<p style="color:white; padding:10px; text-align:center;">${msg}</p>`;
            currentStream = null;
        }
        updateUI();
    }

    async function stopCapture() {
        if (appData.isRecording) await stopRecording();
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
            currentStream = null;
            DOM.videoElement.srcObject = null;
        }
    }

    function takePhoto() {
        if (!currentStream) return;
        const canvas = document.createElement('canvas');
        canvas.width = DOM.videoElement.videoWidth;
        canvas.height = DOM.videoElement.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(DOM.videoElement, 0, 0, canvas.width, canvas.height);
        const dataURL = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL; link.download = `capture-${Date.now()}.png`;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    }
    function toggleMode() {
        if (appData.isRecording) return;
        appData.mode = (appData.mode === 'photo') ? 'video' : 'photo';
        updateUI(); os.saveAppData();
    }
    function handleAction() {
        if (!currentStream && appData.mode === 'photo') { startCapture(); return; } // Try to start if no stream
        if (!currentStream && appData.mode === 'video' && !appData.isRecording) { startCapture().then(() => { if(currentStream) startRecording()}); return; }


        if (appData.mode === 'photo') takePhoto();
        else {
            if (appData.isRecording) stopRecording();
            else startRecording();
        }
    }
    function startRecording() {
        if (!currentStream || !currentStream.active || currentStream.getAudioTracks().length === 0) {
             alert("Audio track missing or stream inactive. Cannot record. Ensure microphone is permitted and selected.");
             startCapture(appData.selectedVideoDevice, appData.selectedAudioDevice, appData.selectedResolution); // Try to re-init with audio
             return;
        }
        recordedChunks = [];
        const options = { mimeType: 'video/webm; codecs=vp9,opus' };
        try {
            mediaRecorder = new MediaRecorder(currentStream, options);
        } catch (e1) {
            try { options.mimeType = 'video/webm; codecs=vp8,opus'; mediaRecorder = new MediaRecorder(currentStream, options); }
            catch (e2) { try {options.mimeType = 'video/webm'; mediaRecorder = new MediaRecorder(currentStream, options); }
                         catch (e3) { alert("Recording not supported by browser."); return; }
            }
        }
        mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = `recording-${Date.now()}.webm`;
            document.body.appendChild(a); a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a);
            recordedChunks = [];
        };
        mediaRecorder.start();
        appData.isRecording = true; updateUI(); os.saveAppData();
    }
    async function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();
        appData.isRecording = false; updateUI(); os.saveAppData();
    }
    function updateUI() {
        DOM.actionBtn.disabled = !currentStream && !appData.isRecording;
        DOM.toggleModeBtn.disabled = appData.isRecording;
        if (appData.mode === 'photo') {
            DOM.actionBtn.textContent = 'Take Photo'; DOM.actionBtn.classList.remove('recording'); // Style with .recording
            DOM.toggleModeBtn.textContent = 'ðŸ“¹'; DOM.toggleModeBtn.title = "Switch to Video";
        } else {
            DOM.toggleModeBtn.textContent = 'ðŸ“·'; DOM.toggleModeBtn.title = "Switch to Photo";
            if (appData.isRecording) {
                DOM.actionBtn.textContent = 'Stop Recording'; DOM.actionBtn.classList.add('recording');
            } else {
                DOM.actionBtn.textContent = 'Start Recording'; DOM.actionBtn.classList.remove('recording');
            }
        }
         if (!currentStream && !appData.isRecording) DOM.actionBtn.textContent = (appData.mode === 'photo') ? 'Take Photo' : 'Start Recording';
    }

    function setupMenus() {
        const menus = [
            { menuEl: DOM.videoMenu, dropdownEl: DOM.videoDropdown, subItems: [
                { itemEl: DOM.videoDeviceItem, listEl: DOM.videoDeviceList, populateFn: populateVideoDevices },
                { itemEl: DOM.videoResolutionItem, listEl: DOM.videoResolutionList, populateFn: populateResolutions }
            ]},
            { menuEl: DOM.audioMenu, dropdownEl: DOM.audioDropdown, subItems: [
                { itemEl: DOM.audioDeviceItem, listEl: DOM.audioDeviceList, populateFn: populateAudioDevices }
            ]}
        ];
        menus.forEach(menu => {
            menu.menuEl.addEventListener('click', (e) => {
                e.stopPropagation();
                const isActive = menu.menuEl.classList.toggle('active'); // Style with .active
                menu.dropdownEl.style.display = isActive ? 'block' : 'none';
                menus.filter(m => m !== menu).forEach(other => { // Close other main menus
                    other.menuEl.classList.remove('active'); other.dropdownEl.style.display = 'none';
                    closeAllSubMenus(other.dropdownEl);
                });
                if (isActive) menu.subItems.forEach(si => si.populateFn()); else closeAllSubMenus(menu.dropdownEl);
            });
            menu.subItems.forEach(sub => {
                sub.itemEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isActive = sub.itemEl.classList.toggle('submenu-active'); // Style with .submenu-active
                    sub.listEl.style.display = isActive ? 'block' : 'none';
                    menu.subItems.filter(s => s !== sub).forEach(otherSub => { // Close other submenus in same dropdown
                        otherSub.itemEl.classList.remove('submenu-active'); otherSub.listEl.style.display = 'none';
                    });
                });
            });
        });
        appWindow.addEventListener('click', () => menus.forEach(m => { // Close all on window click
            m.menuEl.classList.remove('active'); m.dropdownEl.style.display = 'none'; closeAllSubMenus(m.dropdownEl);
        }));
    }
    function closeAllSubMenus(dropdownEl) {
        if (!dropdownEl) return;
        dropdownEl.querySelectorAll('.xp-dropdown-item').forEach(i => i.classList.remove('submenu-active'));
        dropdownEl.querySelectorAll('.xp-submenu').forEach(s => s.style.display = 'none');
    }
    async function populateDevices(listEl, kind, selectedDevice, onSelect) {
        listEl.innerHTML = '';
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const filtered = devices.filter(d => d.kind === kind && d.deviceId !== 'default'); // Exclude 'default'
            if (filtered.length === 0) { listEl.innerHTML = `<div class="xp-submenu-item" style="padding:4px 12px;">No devices</div>`; return; }
            filtered.forEach(d => {
                const item = document.createElement('div');
                item.className = 'xp-submenu-item'; item.style.padding = "4px 12px";
                item.textContent = d.label || `${kind.replace('input','')} ${listEl.children.length + 1}`;
                item.dataset.deviceId = d.deviceId;
                if (d.deviceId === selectedDevice) item.classList.add('selected'); // Style with .selected
                item.addEventListener('click', async () => {
                    if (selectedDevice !== d.deviceId) await onSelect(d.deviceId);
                    closeAllSubMenus(listEl.closest('.xp-dropdown-menu'));
                    listEl.closest('.xp-dropdown-menu').style.display = 'none';
                    listEl.closest('.xp-dropdown-menu').parentElement.classList.remove('active');
                });
                listEl.appendChild(item);
            });
        } catch (err) { listEl.innerHTML = `<div class="xp-submenu-item" style="padding:4px 12px;">Error listing</div>`; }
    }
    function populateVideoDevices() { populateDevices(DOM.videoDeviceList, 'videoinput', appData.selectedVideoDevice, async (id) => { appData.selectedVideoDevice = id; await startCapture(); }); }
    function populateAudioDevices() { populateDevices(DOM.audioDeviceList, 'audioinput', appData.selectedAudioDevice, async (id) => { appData.selectedAudioDevice = id; await startCapture(); }); }
    
    function updateResolutionMenuState(disabled) {
        isResolutionChangeDelayed = disabled;
        DOM.videoResolutionList.querySelectorAll('.xp-submenu-item').forEach(item => {
            item.classList.toggle('disabled-resolution', disabled); // Style with .disabled-resolution
            item.style.pointerEvents = disabled ? 'none' : 'auto';
        });
    }

    function populateResolutions() {
        DOM.videoResolutionList.innerHTML = '';
        COMMON_RESOLUTIONS.forEach(res => {
            const item = document.createElement('div');
            item.className = 'xp-submenu-item'; item.style.padding = "4px 12px";
            item.textContent = res.label;
            if (isResolutionChangeDelayed && res.label !== "Default") { // Disable non-default during delay
                item.classList.add('disabled-resolution'); item.style.pointerEvents = 'none';
            }
            if (appData.selectedResolution && res.width === appData.selectedResolution.width && res.height === appData.selectedResolution.height) item.classList.add('selected');
            else if (!appData.selectedResolution && res.label === "Default") item.classList.add('selected');
            
            item.addEventListener('click', async () => {
                if (isResolutionChangeDelayed && res.label !== "Default") return;
                const newRes = (res.width && res.height) ? { width: res.width, height: res.height } : null;
                if (JSON.stringify(appData.selectedResolution) !== JSON.stringify(newRes)) {
                    appData.selectedResolution = newRes;
                    await startCapture();
                }
                closeAllSubMenus(DOM.videoResolutionList.closest('.xp-dropdown-menu'));
                DOM.videoResolutionList.closest('.xp-dropdown-menu').style.display = 'none';
                DOM.videoResolutionList.closest('.xp-dropdown-menu').parentElement.classList.remove('active');
            });
            DOM.videoResolutionList.appendChild(item);
        });
    }
    function updateMenuSelections() {
        [DOM.videoDeviceList, DOM.audioDeviceList].forEach(listEl => {
            if (!listEl) return;
            const selectedId = listEl === DOM.videoDeviceList ? appData.selectedVideoDevice : appData.selectedAudioDevice;
            Array.from(listEl.children).forEach(item => item.classList.toggle('selected', item.dataset.deviceId === selectedId));
        });
        if (DOM.videoResolutionList) {
            Array.from(DOM.videoResolutionList.children).forEach((item, i) => {
                const resOpt = COMMON_RESOLUTIONS[i];
                const isSelected = (appData.selectedResolution && resOpt.width === appData.selectedResolution.width && resOpt.height === appData.selectedResolution.height) || (!appData.selectedResolution && resOpt.label === "Default");
                item.classList.toggle('selected', isSelected);
            });
        }
    }
    
    this.onOpen = async (win) => {
        setupMenus();
        await startCapture();
        updateUI();
        updateMenuSelections();

        if (sessionStorage.getItem('captureFirstOpenDelay') === null) {
            sessionStorage.setItem('captureFirstOpenDelay', 'done');
            updateResolutionMenuState(true); 
            resolutionChangeDelayTimer = setTimeout(() => {
                updateResolutionMenuState(false);
                resolutionChangeDelayTimer = null;
            }, 15000); // 15 second delay
        } else {
            updateResolutionMenuState(false);
        }
    };
    this.onClose = async (win) => { 
        await stopCapture();
        if (resolutionChangeDelayTimer) clearTimeout(resolutionChangeDelayTimer);
    };
    this.onMinimize = async (win) => { await stopCapture(); };
    this.onRestore = async (win) => { await startCapture(); updateUI(); updateMenuSelections();};

    DOM.actionBtn.addEventListener('click', handleAction);
    DOM.toggleModeBtn.addEventListener('click', toggleMode);
    
    // Initial setup if window is already visible (e.g. on page load with saved state)
    if (appWindow.style.display !== 'none' && !appWindow.classList.contains('minimized')) {
        this.onOpen(appWindow);
    }

    </script>
</body>
