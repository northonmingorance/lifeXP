<template id="captureIconTemplate">
    <div id="captureIcon" class="desktop-icon" data-window-id="captureWindow" style="left: 10px; top: 510px;">
        <div class="icon-image">ðŸ“¹</div>
        <div class="icon-label">Capture</div>
    </div>
</template>

<template id="captureWindowTemplate">
    <div class="xp-window" id="captureWindow" style="display: none;">
        <div class="title-bar" id="captureWindowTitleBar">
            <span class="title-bar-text">Capture</span>
            <div class="title-bar-controls">
                <button id="captureMinimizeBtn" title="Minimize">0</button>
                <button id="captureMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="captureCloseBtn">r</button>
            </div>
        </div>
        <div class="xp-menu-bar" id="captureMenuBar">
            <div class="xp-menu-item" id="videoMenu" tabindex="0">
                <span>Video</span>
                <div class="xp-dropdown-menu" id="videoDropdown">
                    <div class="xp-dropdown-item" id="videoDeviceItem" tabindex="0">
                        Device
                        <span class="xp-submenu-arrow">â–º</span>
                        <div class="xp-submenu" id="videoDeviceList">
                            </div>
                    </div>
                    <div class="xp-dropdown-item" id="videoResolutionItem" tabindex="0">
                        Resolution
                        <span class="xp-submenu-arrow">â–º</span>
                        <div class="xp-submenu" id="videoResolutionList">
                            </div>
                    </div>
                </div>
            </div>
            <div class="xp-menu-item" id="audioMenu" tabindex="0">
                <span>Audio</span>
                <div class="xp-dropdown-menu" id="audioDropdown">
                    <div class="xp-dropdown-item" id="audioDeviceItem" tabindex="0">
                        Device
                        <span class="xp-submenu-arrow">â–º</span>
                        <div class="xp-submenu" id="audioDeviceList">
                            </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="window-body" id="captureWindowBody">
            </div>
        <div class="resize-handle" id="captureResizeHandle"></div>
    </div>
</template>

<template id="captureBodyContentTemplate">
    <video id="captureVideo" autoplay playsinline></video>
    <button id="captureActionBtn" class="xp-button">Take Photo</button>
    <button id="captureToggleModeBtn" class="xp-button">ðŸ“¹</button>
</template>

<style>
    /* Capture App Specific Styles */
    #captureWindow .window-body {
        padding: 0;
        display: flex; /* Use flex to center video and position buttons */
        background-color: #000000; /* Black background for video area */
        justify-content: center;
        align-items: center;
        position: relative; /* For absolute positioning of buttons */
        overflow: hidden; /* Ensure video doesn't overflow */
    }
    #captureVideo {
        width: 100%;
        height: 100%;
        object-fit: contain; /* Or 'cover', depending on desired behavior */
         transform: scaleX(-1); /* Mirror image for webcam feel */
        -webkit-transform: scaleX(-1);
    }
    #captureActionBtn {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10; /* Above video */
        padding: 8px 15px;
        font-size: 14px;
    }
    #captureActionBtn.recording { /* Style for when recording */
        background-color: #FF6347; /* Tomato red */
        border-color: #CD5C5C;
        color: white;
    }
    #captureActionBtn.recording:hover {
        background-color: #E55337;
        border-color: #B24331;
    }
    #captureToggleModeBtn {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 10;
        padding: 4px 10px; /* Slightly smaller padding */
        font-size: 18px; /* Emoji size */
        min-width: auto; /* Allow button to be smaller */
    }
    /* Menu styles are inherited from OS, but ensure submenus position correctly if needed */
    #captureMenuBar .xp-dropdown-menu,
    #captureMenuBar .xp-submenu {
        background-color: #ECE9D8; /* Ensure consistent background */
        border: 1px solid #7F7F7F;
        color: #000;
    }
    #captureMenuBar .xp-dropdown-item:hover,
    #captureMenuBar .xp-submenu-item:hover:not(.disabled-resolution) {
        background-color: #316AC5;
        color: white;
    }
     #captureMenuBar .xp-submenu-item.selected::before {
        color: #000; /* Default color for selected mark */
    }
    #captureMenuBar .xp-submenu-item.selected:hover:not(.disabled-resolution)::before {
        color: white; /* Change with hover if item is not disabled */
    }
</style>

<script>
(function() {
    const APP_ID = 'captureWindow';
    const MIN_WIDTH = 320;
    const MIN_HEIGHT = 280; // Increased slightly for menu bar
    const DEFAULT_WIDTH = 400;
    const DEFAULT_HEIGHT = 350;

    const COMMON_RESOLUTIONS = [ // Specific to Capture app
        { label: "Default", width: null, height: null }, // Option to use browser default
        { label: "320x240 (QVGA)", width: 320, height: 240 },
        { label: "640x480 (VGA)", width: 640, height: 480 },
        { label: "800x600 (SVGA)", width: 800, height: 600 },
        { label: "1280x720 (HD)", width: 1280, height: 720 },
        { label: "1920x1080 (FHD)", width: 1920, height: 1080 }
    ];

    let captureDOM = {};
    let mediaRecorder = null;
    let recordedChunks = [];
    let isResolutionDelayActive = false; // For initial resolution selection delay
    let captureResolutionTimerId = null;

    const getById = window.getById;

    function populateCaptureDOM() {
        captureDOM = {
            captureWindow: getById('captureWindow'),
            captureMenuBar: getById('captureMenuBar'),
            videoMenu: getById('videoMenu'),
            videoDropdown: getById('videoDropdown'),
            videoDeviceItem: getById('videoDeviceItem'),
            videoDeviceList: getById('videoDeviceList'),
            videoResolutionItem: getById('videoResolutionItem'),
            videoResolutionList: getById('videoResolutionList'),
            audioMenu: getById('audioMenu'),
            audioDropdown: getById('audioDropdown'),
            audioDeviceItem: getById('audioDeviceItem'),
            audioDeviceList: getById('audioDeviceList'),
            captureWindowBody: getById('captureWindowBody'),
            captureVideo: getById('captureVideo'), // Will be populated after body content injection
            captureActionBtn: getById('captureActionBtn'), // Same here
            captureToggleModeBtn: getById('captureToggleModeBtn'), // Same here
        };
    }

    function getCaptureData() {
        if (!window.appData.capture) {
            window.appData.capture = {
                stream: null,
                captureMode: 'photo', // 'photo' or 'video'
                isRecording: false,
                selectedVideoDevice: null,
                selectedAudioDevice: null,
                selectedResolution: null, // Store as {label, width, height} or null for default
            };
        }
        return window.appData.capture;
    }

    function initCaptureApp() {
        const capData = getCaptureData();
        populateCaptureDOM();

        addCaptureEventListeners();
        setupCaptureMenus(); // Setup menu interactions
        updateCaptureAppUI(); // Initial UI state

        const appWindow = getById(APP_ID);
        if (appWindow) {
            appWindow.addEventListener('appresize', handleCaptureWindowResize);
            appWindow.addEventListener('appopen', (event) => {
                if (event.detail && event.detail.windowId === APP_ID) {
                    if (!capData.stream) { // If stream isn't active, try to start it
                        startCaptureApp(capData.selectedVideoDevice, capData.selectedAudioDevice, capData.selectedResolution);
                    }
                    updateSelectedInMenu(); // Refresh menu selections
                }
            });
            appWindow.addEventListener('appminimize', () => {
                if (capData.isRecording) stopVideoRecording(); // Stop recording on minimize
                stopCaptureApp(); // Stop stream on minimize
            });
            // OS drag start/resize start events are listened to by menus themselves to close
        }
    }
    
    function handleCaptureWindowResize() {
        // Video element uses object-fit: contain, so it resizes naturally within its container.
        // No specific JS needed here for resizing the video element itself.
    }

    function addCaptureEventListeners() {
        captureDOM.captureActionBtn.addEventListener('click', handleMainCaptureAction);
        captureDOM.captureToggleModeBtn.addEventListener('click', toggleCaptureMode);

        // Menu item event listeners are set up in setupCaptureMenus
        
        const appWindow = getById(APP_ID);
        if (appWindow) {
            const closeButton = appWindow.querySelector('#captureCloseBtn');
            if (closeButton) closeButton.addEventListener('click', () => {
                const capData = getCaptureData();
                if (capData.isRecording) stopVideoRecording();
                stopCaptureApp();
                let state = window.appData.windowStates[APP_ID];
                if (state) state.hiddenByUser = true;
                window.saveWindowState(APP_ID);
                appWindow.style.display = 'none';
                closeAllCaptureMenus();
                if (captureResolutionTimerId) clearTimeout(captureResolutionTimerId);
            });
            const minimizeButton = appWindow.querySelector('#captureMinimizeBtn');
            if(minimizeButton) minimizeButton.addEventListener('click', () => window.minimizeWindow(APP_ID));

            const maximizeButton = appWindow.querySelector('#captureMaximizeBtn');
            if(maximizeButton) maximizeButton.addEventListener('click', () => window.maximizeWindow(APP_ID));
        }
    }

    async function startCaptureApp(videoDeviceId = null, audioDeviceId = null, resolution = null) {
        const capData = getCaptureData();
        if (capData.stream && captureDOM.captureVideo.srcObject === capData.stream) {
             // Stream already running with the same object, maybe just update UI
            updateCaptureAppUI();
            return;
        }
        await stopCaptureApp(); // Ensure any existing stream is stopped first

        // Ensure video element is present (it's in a template)
        if (!getById('captureVideo')) { // Check if it was removed
            const bodyContentTemplate = document.getElementById('captureBodyContentTemplate');
            if (captureDOM.captureWindowBody && bodyContentTemplate) {
                 captureDOM.captureWindowBody.innerHTML = ''; // Clear first
                 captureDOM.captureWindowBody.appendChild(bodyContentTemplate.content.cloneNode(true));
                 // Re-populate DOM elements for video and buttons
                 captureDOM.captureVideo = getById('captureVideo');
                 captureDOM.captureActionBtn = getById('captureActionBtn');
                 captureDOM.captureToggleModeBtn = getById('captureToggleModeBtn');
                 // Re-add listeners if they were on the old elements
                 if(captureDOM.captureActionBtn) captureDOM.captureActionBtn.addEventListener('click', handleMainCaptureAction);
                 if(captureDOM.captureToggleModeBtn) captureDOM.captureToggleModeBtn.addEventListener('click', toggleCaptureMode);
            } else {
                console.error("Capture body or template missing for video injection.");
                return;
            }
        }


        const finalVideoDeviceId = videoDeviceId || capData.selectedVideoDevice;
        const finalAudioDeviceId = audioDeviceId || capData.selectedAudioDevice;
        const finalResolution = resolution || capData.selectedResolution;

        let videoConstraints = {};
        if (finalVideoDeviceId) videoConstraints.deviceId = { exact: finalVideoDeviceId };
        if (finalResolution && finalResolution.width && finalResolution.height) {
            videoConstraints.width = { exact: finalResolution.width };
            videoConstraints.height = { exact: finalResolution.height };
        }
        if (Object.keys(videoConstraints).length === 0) videoConstraints = true; // Default to any video

        let audioConstraints = {};
        if (finalAudioDeviceId) audioConstraints.deviceId = { exact: finalAudioDeviceId };
        if (Object.keys(audioConstraints).length === 0) audioConstraints = true; // Default to any audio

        try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                captureDOM.captureWindowBody.innerHTML = '<p style="color:white; padding:10px; text-align:center;">Webcam/mic access not supported.</p>';
                updateCaptureAppUI(); return;
            }
            const stream = await navigator.mediaDevices.getUserMedia({ video: videoConstraints, audio: audioConstraints });
            
            capData.stream = stream;
            captureDOM.captureVideo.srcObject = stream;
            captureDOM.captureVideo.muted = true; // Mute playback to avoid echo
            await captureDOM.captureVideo.play();

            // Update selected devices if defaults were chosen by browser
            const videoTracks = stream.getVideoTracks();
            if (videoTracks.length > 0 && !videoDeviceId) {
                capData.selectedVideoDevice = videoTracks[0].getSettings().deviceId || videoTracks[0].id;
            }
            const audioTracks = stream.getAudioTracks();
            if (audioTracks.length > 0 && !audioDeviceId) {
                capData.selectedAudioDevice = audioTracks[0].getSettings().deviceId || audioTracks[0].id;
            }
            
            // Handle initial resolution delay
            if (sessionStorage.getItem(`captureFirstOpen_${APP_ID}`) === null) {
                sessionStorage.setItem(`captureFirstOpen_${APP_ID}`, 'true');
                isResolutionDelayActive = true;
                updateResolutionItemsState(true);
                if (captureResolutionTimerId) clearTimeout(captureResolutionTimerId);
                captureResolutionTimerId = setTimeout(() => {
                    isResolutionDelayActive = false;
                    updateResolutionItemsState(false);
                    captureResolutionTimerId = null;
                }, 20000); // 20 seconds delay
            } else {
                isResolutionDelayActive = false;
                updateResolutionItemsState(false);
            }

        } catch (err) {
            let message = `Error: ${err.name} - ${err.message}. Try other device/resolution.`;
            if (err.name === "OverconstrainedError" && finalResolution) {
                message = `Resolution ${finalResolution.label || (finalResolution.width + 'x' + finalResolution.height)} not supported. Try default.`;
                capData.selectedResolution = null; // Reset to default on overconstrained
            }
            captureDOM.captureWindowBody.innerHTML = `<p style="color:white; padding:10px; text-align:center;">${message}</p>`;
            capData.stream = null;
        }
        updateCaptureAppUI();
        updateSelectedInMenu();
        window.saveData();
    }

    async function stopCaptureApp() {
        const capData = getCaptureData();
        if (capData.isRecording) await stopVideoRecording();
        
        if (capData.stream) {
            capData.stream.getTracks().forEach(track => track.stop());
            capData.stream = null;
        }
        if (captureDOM.captureVideo) captureDOM.captureVideo.srcObject = null;
        updateCaptureAppUI();
    }

    function takeAndDownloadPhoto() {
        const capData = getCaptureData();
        if (!capData.stream || !captureDOM.captureVideo.srcObject) return;
        const video = captureDOM.captureVideo;
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const context = canvas.getContext('2d');
        if (video.style.transform === 'scaleX(-1)') { // If mirrored, flip canvas draw
            context.translate(canvas.width, 0);
            context.scale(-1, 1);
        }
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        const dataURL = canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = `photo-${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function toggleCaptureMode() {
        const capData = getCaptureData();
        if (capData.isRecording) return; // Don't switch mode while recording
        capData.captureMode = (capData.captureMode === 'photo') ? 'video' : 'photo';
        updateCaptureAppUI();
        window.saveData();
    }

    function handleMainCaptureAction() {
        const capData = getCaptureData();
        if (!capData.stream) {
            startCaptureApp(capData.selectedVideoDevice, capData.selectedAudioDevice, capData.selectedResolution);
            return; // Let it start, then user can click again
        }
        if (capData.captureMode === 'photo') {
            takeAndDownloadPhoto();
        } else {
            if (capData.isRecording) stopVideoRecording();
            else startVideoRecording();
        }
    }

    function startVideoRecording() {
        const capData = getCaptureData();
        if (!capData.stream) return;
        if (!capData.stream.getAudioTracks().length > 0) {
             alert("No audio track available. Please select an audio device in the menu. Recording video without audio.");
             // Allow recording without audio, or prompt to select one
        }
        recordedChunks = [];
        const mimeTypes = ['video/webm;codecs=vp9,opus', 'video/webm;codecs=vp8,opus', 'video/webm;codecs=h264,opus', 'video/mp4', 'video/webm'];
        let supportedMimeType = mimeTypes.find(type => MediaRecorder.isTypeSupported(type)) || "";
        
        try {
            mediaRecorder = new MediaRecorder(capData.stream, { mimeType: supportedMimeType });
        } catch (e) {
            console.error("Failed to create MediaRecorder:", e.message, "Supported:", MediaRecorder.isTypeSupported('video/webm'));
            alert("Video recording setup failed. Your browser might not support the required codecs.");
            return;
        }
        mediaRecorder.ondataavailable = (event) => { if (event.data.size > 0) recordedChunks.push(event.data); };
        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none'; a.href = url;
            const extension = (mediaRecorder.mimeType || 'video/webm').split('/')[1].split(';')[0];
            a.download = `recording-${new Date().toISOString().replace(/[:.]/g, '-')}.${extension}`;
            document.body.appendChild(a); a.click(); window.URL.revokeObjectURL(url); document.body.removeChild(a);
            recordedChunks = [];
        };
        mediaRecorder.start();
        capData.isRecording = true;
        updateCaptureAppUI();
    }
    async function stopVideoRecording() {
        const capData = getCaptureData();
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
            mediaRecorder.stop(); // This will trigger onstop
        }
        capData.isRecording = false;
        updateCaptureAppUI();
    }
    
    function updateCaptureAppUI() {
        const capData = getCaptureData();
        if (!captureDOM.captureActionBtn || !captureDOM.captureToggleModeBtn) return;

        const streamActive = !!capData.stream;
        captureDOM.captureActionBtn.disabled = !streamActive;
        captureDOM.captureToggleModeBtn.disabled = capData.isRecording;

        if (capData.captureMode === 'photo') {
            captureDOM.captureActionBtn.textContent = 'Take Photo';
            captureDOM.captureActionBtn.classList.remove('recording');
            captureDOM.captureToggleModeBtn.textContent = 'ðŸ“¹'; 
            captureDOM.captureToggleModeBtn.title = "Switch to Video Mode";
        } else { 
            captureDOM.captureToggleModeBtn.textContent = 'ï¿½'; 
            captureDOM.captureToggleModeBtn.title = "Switch to Photo Mode";
            if (capData.isRecording) {
                captureDOM.captureActionBtn.textContent = 'Stop Recording';
                captureDOM.captureActionBtn.classList.add('recording');
            } else {
                captureDOM.captureActionBtn.textContent = 'Start Recording';
                captureDOM.captureActionBtn.classList.remove('recording');
            }
        }
         if (!streamActive) { // If stream died or couldn't start
            captureDOM.captureActionBtn.textContent = (capData.captureMode === 'photo') ? 'Take Photo' : 'Start Recording';
            captureDOM.captureActionBtn.classList.remove('recording'); 
         }
    }

    function setupCaptureMenus() {
        const handleMenuClick = (menuElement, dropdownElement, populateFn1, populateFn2) => {
            menuElement.addEventListener('click', (e) => {
                e.stopPropagation();
                const parentWindow = menuElement.closest('.xp-window');
                if (parentWindow && (parentWindow.classList.contains('disable-selection') || parentWindow.querySelector('.title-bar').style.cursor === 'grabbing')) {
                    return; // Don't open menu during window drag/resize
                }

                const isActive = menuElement.classList.toggle('active');
                dropdownElement.style.display = isActive ? 'block' : 'none';
                
                // Close other main menus
                [captureDOM.videoMenu, captureDOM.audioMenu].forEach(otherMenu => {
                    if (otherMenu && otherMenu !== menuElement) {
                        otherMenu.classList.remove('active');
                        const otherDropdown = otherMenu.querySelector('.xp-dropdown-menu');
                        if (otherDropdown) {
                            otherDropdown.style.display = 'none';
                            closeAllSubMenus(otherDropdown);
                        }
                    }
                });

                if (isActive) {
                    if (populateFn1) populateFn1();
                    if (populateFn2) populateFn2(); // For video menu that populates devices and resolutions
                    updateSelectedInMenu();
                } else {
                    closeAllSubMenus(dropdownElement);
                }
            });
        };

        const handleSubMenuItemClick = (parentItem, subMenu) => {
            parentItem.addEventListener('click', (e) => {
                e.stopPropagation();
                const isActive = parentItem.classList.toggle('submenu-active');
                subMenu.style.display = isActive ? 'block' : 'none';
                // Close other submenus in the same dropdown
                const allSubItems = parentItem.closest('.xp-dropdown-menu').querySelectorAll('.xp-dropdown-item');
                allSubItems.forEach(item => {
                    if (item !== parentItem && item.classList.contains('submenu-active')) {
                        item.classList.remove('submenu-active');
                        const otherSubMenu = item.querySelector('.xp-submenu');
                        if (otherSubMenu) otherSubMenu.style.display = 'none';
                    }
                });
            });
        };

        handleMenuClick(captureDOM.videoMenu, captureDOM.videoDropdown, populateVideoDevices, populateResolutions);
        handleSubMenuItemClick(captureDOM.videoDeviceItem, captureDOM.videoDeviceList);
        handleSubMenuItemClick(captureDOM.videoResolutionItem, captureDOM.videoResolutionList);
        
        handleMenuClick(captureDOM.audioMenu, captureDOM.audioDropdown, populateAudioDevices);
        handleSubMenuItemClick(captureDOM.audioDeviceItem, captureDOM.audioDeviceList);

        // Close menus if clicked outside
        document.addEventListener('click', (e) => {
            if (!captureDOM.captureMenuBar.contains(e.target)) {
                closeAllCaptureMenus();
            }
        });
        // Also close on window drag/resize start (event dispatched by OS)
        const appWindow = getById(APP_ID);
        if(appWindow){
            appWindow.addEventListener('osdragstart', closeAllCaptureMenus);
            appWindow.addEventListener('osresizestart', closeAllCaptureMenus);
        }
    }

    function closeAllCaptureMenus() {
        [captureDOM.videoMenu, captureDOM.audioMenu].forEach(menu => {
            if (menu) menu.classList.remove('active');
        });
        [captureDOM.videoDropdown, captureDOM.audioDropdown].forEach(dropdown => {
            if (dropdown) {
                dropdown.style.display = 'none';
                closeAllSubMenus(dropdown);
            }
        });
    }
    function closeAllSubMenus(dropdownElement) {
        if (!dropdownElement) return;
        dropdownElement.querySelectorAll('.xp-dropdown-item.submenu-active').forEach(item => item.classList.remove('submenu-active'));
        dropdownElement.querySelectorAll('.xp-submenu').forEach(submenu => submenu.style.display = 'none');
    }

    async function populateVideoDevices() {
        if (!captureDOM.videoDeviceList) return;
        captureDOM.videoDeviceList.innerHTML = ''; 
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(device => device.kind === 'videoinput');
            if (videoDevices.length === 0) {
                captureDOM.videoDeviceList.innerHTML = '<div class="xp-submenu-item">No video devices</div>'; return;
            }
            videoDevices.forEach(device => {
                const item = document.createElement('div');
                item.classList.add('xp-submenu-item');
                item.textContent = device.label || `Camera ${captureDOM.videoDeviceList.children.length + 1}`;
                item.dataset.deviceId = device.deviceId;
                item.addEventListener('click', async () => {
                    const capData = getCaptureData();
                    if (capData.selectedVideoDevice !== device.deviceId) {
                        capData.selectedVideoDevice = device.deviceId;
                        await startCaptureApp(capData.selectedVideoDevice, capData.selectedAudioDevice, capData.selectedResolution);
                    }
                    closeAllCaptureMenus();
                });
                captureDOM.videoDeviceList.appendChild(item);
            });
        } catch (err) {
            captureDOM.videoDeviceList.innerHTML = '<div class="xp-submenu-item">Error listing devices</div>';
        }
        updateSelectedInMenu(); 
    }
    async function populateAudioDevices() {
        if (!captureDOM.audioDeviceList) return;
        captureDOM.audioDeviceList.innerHTML = '';
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioDevices = devices.filter(device => device.kind === 'audioinput' && device.deviceId !== 'default');
            if (audioDevices.length === 0) {
                captureDOM.audioDeviceList.innerHTML = '<div class="xp-submenu-item">No audio devices</div>'; return;
            }
            audioDevices.forEach(device => {
                const item = document.createElement('div');
                item.classList.add('xp-submenu-item');
                item.textContent = device.label || `Microphone ${captureDOM.audioDeviceList.children.length + 1}`;
                item.dataset.deviceId = device.deviceId;
                item.addEventListener('click', async () => {
                    const capData = getCaptureData();
                     if (capData.selectedAudioDevice !== device.deviceId) {
                        capData.selectedAudioDevice = device.deviceId;
                        await startCaptureApp(capData.selectedVideoDevice, capData.selectedAudioDevice, capData.selectedResolution);
                     }
                    closeAllCaptureMenus();
                });
                captureDOM.audioDeviceList.appendChild(item);
            });
        } catch (err) {
             captureDOM.audioDeviceList.innerHTML = '<div class="xp-submenu-item">Error listing devices</div>';
        }
        updateSelectedInMenu();
    }
    function updateResolutionItemsState(disabled) {
        if (!captureDOM.videoResolutionList) return;
        captureDOM.videoResolutionList.querySelectorAll('.xp-submenu-item').forEach(item => {
            if (disabled) {
                item.classList.add('disabled-resolution');
                item.style.pointerEvents = 'none'; 
            } else {
                item.classList.remove('disabled-resolution');
                item.style.pointerEvents = 'auto'; 
            }
        });
    }
    function populateResolutions() {
        if (!captureDOM.videoResolutionList) return;
        captureDOM.videoResolutionList.innerHTML = '';
        COMMON_RESOLUTIONS.forEach(res => {
            const item = document.createElement('div');
            item.classList.add('xp-submenu-item');
            item.textContent = res.label;
            item.addEventListener('click', async () => {
                if (isResolutionDelayActive) return;
                const capData = getCaptureData();
                const newRes = (res.width && res.height) ? { width: res.width, height: res.height, label: res.label } : null;
                if (JSON.stringify(capData.selectedResolution) !== JSON.stringify(newRes)) {
                    capData.selectedResolution = newRes;
                    await startCaptureApp(capData.selectedVideoDevice, capData.selectedAudioDevice, capData.selectedResolution);
                }
                closeAllCaptureMenus();
            });
            captureDOM.videoResolutionList.appendChild(item);
        });
        updateResolutionItemsState(isResolutionDelayActive);
        updateSelectedInMenu();
    }
    function updateSelectedInMenu() {
        const capData = getCaptureData();
        const updateList = (listElement, selectedValue) => {
            if (listElement) {
                Array.from(listElement.children).forEach(item => {
                    item.classList.remove('selected');
                    if (item.dataset.deviceId && item.dataset.deviceId === selectedValue) {
                        item.classList.add('selected');
                    }
                });
            }
        };
        updateList(captureDOM.videoDeviceList, capData.selectedVideoDevice);
        updateList(captureDOM.audioDeviceList, capData.selectedAudioDevice);

        if (captureDOM.videoResolutionList) {
            Array.from(captureDOM.videoResolutionList.children).forEach(item => {
                item.classList.remove('selected');
                const resOpt = COMMON_RESOLUTIONS.find(r => r.label === item.textContent);
                if (resOpt) { 
                    if (capData.selectedResolution && capData.selectedResolution.width === resOpt.width && capData.selectedResolution.height === resOpt.height) {
                        item.classList.add('selected');
                    } else if (!capData.selectedResolution && resOpt.label === "Default") {
                        item.classList.add('selected'); // Select "Default" if no specific resolution is set
                    }
                }
            });
        }
    }

    function setupCaptureApp() {
        const windowBody = getById('captureWindowBody');
        const bodyContentTemplate = document.getElementById('captureBodyContentTemplate');

        if (windowBody && bodyContentTemplate) {
            windowBody.innerHTML = ''; // Clear placeholder
            windowBody.appendChild(bodyContentTemplate.content.cloneNode(true));
        } else {
            console.error("Capture App window body or content template not found.");
            return;
        }
        
        if (!window.appRegistry) window.appRegistry = {};
        window.appRegistry[APP_ID] = {
            minWidth: MIN_WIDTH,
            minHeight: MIN_HEIGHT,
            defaultWidth: DEFAULT_WIDTH,
            defaultHeight: DEFAULT_HEIGHT,
            appName: "Capture"
        };
        
        initCaptureApp();
    }

    window.setupCaptureApp = setupCaptureApp;

})();
</script>