<template id="pixelCraftIconTemplate">
    <div id="pixelIcon" class="desktop-icon" data-window-id="pixelWindow" style="left: 10px; top: 410px;">
        <div class="icon-image">üé®</div>
        <div class="icon-label">Pixel Craft</div>
    </div>
</template>

<template id="pixelCraftWindowTemplate">
    <div class="xp-window" id="pixelWindow" style="display: none;">
        <div class="title-bar" id="pixelWindowTitleBar">
            <span class="title-bar-text">Pixel Craft</span>
            <div class="title-bar-controls">
                <button id="pixelMinimizeBtn" title="Minimize">0</button>
                <button id="pixelMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="pixelCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="pixelWindowBody">
            </div>
        <div class="resize-handle" id="pixelResizeHandle"></div>
    </div>
</template>

<template id="pixelCraftBodyContentTemplate">
    <div class="pixel-craft-body-container">
        <div class="pixel-menu-bar" id="pixelMenuBar">
            <div class="pixel-menu-item" tabindex="0">
                File
                <div class="pixel-dropdown-content">
                    <div class="pixel-dropdown-item" id="pixelFileSave">Save</div>
                    <div class="pixel-dropdown-item" id="pixelFileClearCanvas">Clear canvas</div>
                    <div class="pixel-dropdown-item" id="pixelFileCanvasSize">Canvas size</div>
                </div>
            </div>
        </div>
        <div class="pixel-toolbar">
            <input type="number" class="pixel-size-input" id="pixelSizeInput" value="2" min="1" max="50" title="Pencil/Eraser Size">
            <button class="pixel-tool-button active" id="pixelPencilTool" title="Pencil">‚úèÔ∏è</button>
            <button class="pixel-tool-button" id="pixelEraserTool" title="Eraser">üßº</button>
            <button class="pixel-tool-button" id="pixelBucketTool" title="Paint Bucket">ü´ó</button>
            <input type="color" class="pixel-color-picker" id="pixelColorPicker" value="#000000" title="Color Picker">
        </div>
        <div class="pixel-canvas-container">
            <canvas id="pixelCanvas"></canvas>
        </div>
    </div>
</template>

<template id="pixelCraftModalsTemplate">
    <div id="pixelCanvasSizeModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Set Canvas Size</span>
                <span class="close-button" data-modal-id="pixelCanvasSizeModal">r</span>
            </div>
            <div class="modal-body">
                <label for="pixelNewCanvasWidth">New Width (px):</label>
                <input type="number" id="pixelNewCanvasWidth" min="10" max="2000" value="600">
                <label for="pixelNewCanvasHeight">New Height (px):</label>
                <input type="number" id="pixelNewCanvasHeight" min="10" max="2000" value="400">
                <p><small>Min: 10px, Max: 2000px per dimension.</small></p>
            </div>
            <div class="modal-footer">
                <button id="savePixelCanvasSizeBtn" class="xp-button">Save New Size</button>
                <button class="xp-button" data-modal-id="pixelCanvasSizeModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmPixelResizeModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Canvas Resize</span>
                <span class="close-button" data-modal-id="confirmPixelResizeModal">r</span>
            </div>
            <div class="modal-body">
                <p>Changing the canvas size will clear the current drawing. Are you sure you want to proceed?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmPixelResizeBtn" class="xp-button">Proceed & Clear</button>
                <button class="xp-button" data-modal-id="confirmPixelResizeModal">Cancel</button>
            </div>
        </div>
    </div>
</template>

<style>
    /* Pixel Craft Specific Styles */
    #pixelWindow .window-body {
        display: flex; /* To make body-container fill it */
        flex-direction: column;
        padding: 0;
        overflow: hidden; /* Prevent scrollbars on window body itself */
    }
    .pixel-craft-body-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        background-color: #ECE9D8; /* Standard XP background */
    }
    .pixel-menu-bar {
        background-color: #ECE9D8;
        padding: 2px 3px;
        border-bottom: 1px solid #ACA899;
        display: flex;
        flex-shrink: 0;
        user-select: none;
        color: #000000;
        height: 21px; /* Match OS menu bar height */
        box-sizing: border-box;
    }
    .pixel-menu-item {
        padding: 2px 7px; /* Match OS menu item padding */
        cursor: default;
        position: relative;
        color: inherit;
        font-size: 11px; /* Match OS font */
        line-height: 16px; /* Match OS line height */
    }
    .pixel-menu-item:hover {
        background-color: #005CFE; /* XP Blue */
        color: white;
    }
    .pixel-dropdown-content {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        background-color: #ECE9D8;
        border: 1px solid #7F7F7F; /* Darker border for dropdown */
        box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
        z-index: 100; /* Above toolbar */
        padding: 2px; /* XP style padding */
        color: #000000;
        min-width: 160px;
    }
    .pixel-dropdown-item {
        padding: 4px 12px; /* Standard dropdown item padding */
        cursor: default;
        white-space: nowrap;
        color: inherit;
        font-size: 11px;
    }
    .pixel-dropdown-item:hover:not(.disabled) {
        background-color: #005CFE;
        color: white;
    }
    .pixel-menu-item:focus-within .pixel-dropdown-content,
    .pixel-menu-item.open .pixel-dropdown-content {
        display: block;
    }
    .pixel-toolbar {
        display: flex;
        align-items: center;
        padding: 4px;
        border-bottom: 1px solid #000000; /* Stronger separator */
        background-color: #ECE9D8;
        flex-shrink: 0;
        gap: 5px;
    }
    .pixel-tool-button {
        font-family: "Tahoma", "Geneva", sans-serif; /* Ensure consistent font */
        font-size: 18px; /* Emoji size */
        border: 1px outset #7F7F7F;
        background-color: #ECE9D8;
        min-width: 28px; /* Slightly larger for touch */
        height: 28px;
        padding: 0;
        cursor: default;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 1px 1px 0px #FFF inset, -1px -1px 0px #808080 inset; /* XP Button style */
    }
    .pixel-tool-button.active {
        border-style: inset;
        background-color: #D4D0C8; /* Slightly darker when active */
        box-shadow: -1px -1px 0px #FFF inset, 1px 1px 0px #808080 inset;
    }
    .pixel-tool-button:active:not(.active) { /* For click feedback */
        border-style: inset;
        box-shadow: -1px -1px 0px #FFF inset, 1px 1px 0px #808080 inset;
    }
    .pixel-color-picker {
        width: 28px;
        height: 28px;
        border: 1px solid #7F7F7F;
        padding: 0; /* Remove browser default padding */
        background-color: #ECE9D8; /* Match toolbar */
        cursor: pointer;
        box-sizing: border-box; /* Include border in size */
    }
    .pixel-size-input {
        width: 30px; /* Narrower for just 2 digits */
        height: 24px; /* Match tool button height better */
        border: 1px inset #7F7F7F;
        padding: 2px 4px;
        font-family: "Tahoma", "Geneva", sans-serif;
        font-size: 12px;
        text-align: center;
        background-color: #FFFFFF;
        margin-right: 3px;
        box-sizing: border-box;
    }
    .pixel-size-input::-webkit-outer-spin-button,
    .pixel-size-input::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }
    .pixel-size-input[type=number] {
        -moz-appearance: textfield; /* Firefox */
    }
    .pixel-canvas-container {
        flex-grow: 1;
        background-color: #808080; /* Checkerboard or grey background for canvas area */
        padding: 10px; /* Spacing around the canvas */
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: auto; /* Allow scrolling if canvas is larger than container */
    }
    #pixelCanvas {
        background-color: white;
        border: 1px solid #000; /* Border around the actual canvas */
        cursor: default; /* Will be changed by tool selection */
        image-rendering: pixelated; /* Keep pixels sharp */
        image-rendering: -moz-crisp-edges;
        image-rendering: crisp-edges;
        /* max-width/max-height are handled by JS for responsive scaling */
        object-fit: contain; /* Should not be needed if JS handles dimensions */
    }
</style>

<script>
(function() {
    const APP_ID = 'pixelWindow';
    const MIN_WIDTH = 375;
    const MIN_HEIGHT = 300; // Menu + Toolbar + Min Canvas Area
    const DEFAULT_WIDTH = 650;
    const DEFAULT_HEIGHT = 500;

    let pixelCraftDOM = {};
    let pixelCtx = null;
    let pixelIsDrawing = false;
    let pixelLastX, pixelLastY;
    
    const getById = window.getById;

    function populatePixelCraftDOM() {
        pixelCraftDOM = {
            pixelWindow: getById('pixelWindow'),
            pixelWindowBody: getById('pixelWindowBody'),
            pixelMenuBar: getById('pixelMenuBar'),
            pixelFileSave: getById('pixelFileSave'),
            pixelFileClearCanvas: getById('pixelFileClearCanvas'),
            pixelFileCanvasSize: getById('pixelFileCanvasSize'),
            pixelPencilTool: getById('pixelPencilTool'),
            pixelEraserTool: getById('pixelEraserTool'),
            pixelBucketTool: getById('pixelBucketTool'),
            pixelColorPicker: getById('pixelColorPicker'),
            pixelSizeInput: getById('pixelSizeInput'),
            pixelCanvas: getById('pixelCanvas'),
            pixelCanvasContainer: getById('pixelCanvasContainer'),
            pixelCanvasSizeModal: getById('pixelCanvasSizeModal'),
            pixelNewCanvasWidthInput: getById('pixelNewCanvasWidth'),
            pixelNewCanvasHeightInput: getById('pixelNewCanvasHeight'),
            savePixelCanvasSizeBtn: getById('savePixelCanvasSizeBtn'),
            confirmPixelResizeModal: getById('confirmPixelResizeModal'),
            confirmPixelResizeBtn: getById('confirmPixelResizeBtn'),
        };
    }

    function getPixelCraftData() {
        if (!window.appData.pixelCraft) {
            window.appData.pixelCraft = {
                currentColor: '#000000',
                currentTool: 'pencil',
                pencilSize: 2,
                canvasWidth: 64, // Default canvas logical size
                canvasHeight: 64,
                // canvasContent: null, // Could store canvas dataURL for persistence
            };
        }
        return window.appData.pixelCraft;
    }

    function initPixelCraftApp() {
        const pcData = getPixelCraftData();
        populatePixelCraftDOM();

        pixelCtx = pixelCraftDOM.pixelCanvas.getContext('2d');
        pixelCraftDOM.pixelCanvas.width = pcData.canvasWidth;
        pixelCraftDOM.pixelCanvas.height = pcData.canvasHeight;
        
        // Set initial canvas background (important for eraser)
        pixelCtx.fillStyle = 'white';
        pixelCtx.fillRect(0, 0, pixelCraftDOM.pixelCanvas.width, pixelCraftDOM.pixelCanvas.height);

        pcData.pencilSize = parseInt(pcData.pencilSize) || 2;
        if (pcData.pencilSize < 1) pcData.pencilSize = 1;
        if (pcData.pencilSize > 50) pcData.pencilSize = 50;
        
        pixelCraftDOM.pixelColorPicker.value = pcData.currentColor;
        pixelCraftDOM.pixelSizeInput.value = pcData.pencilSize;

        addPixelCraftEventListeners();
        setPixelTool(pcData.currentTool); // Apply initial tool
        handlePixelWindowResize(); // Initial canvas scaling

        const appWindow = getById(APP_ID);
        if (appWindow) {
            appWindow.addEventListener('appresize', handlePixelWindowResize);
            appWindow.addEventListener('appopen', (event) => {
                if (event.detail && event.detail.windowId === APP_ID) {
                    handlePixelWindowResize(); // Ensure canvas scales correctly when window is shown
                }
            });
        }
    }

    function handlePixelWindowResize() {
        const windowEl = getById(APP_ID);
        if (!windowEl || windowEl.classList.contains('minimized') || windowEl.style.display === 'none') return;
        
        const pcData = getPixelCraftData();
        const container = pixelCraftDOM.pixelCanvasContainer;
        const canvas = pixelCraftDOM.pixelCanvas;
        
        const padding = 20; // Total padding within container (10px on each side)
        const menuBarHeight = pixelCraftDOM.pixelMenuBar.offsetHeight;
        const toolbarHeight = pixelCraftDOM.pixelWindow.querySelector('.pixel-toolbar').offsetHeight;
        
        // Calculate available space for the canvas container first
        const availableContainerHeight = pixelCraftDOM.pixelWindowBody.clientHeight - menuBarHeight - toolbarHeight;
        container.style.height = `${availableContainerHeight}px`; // Let container take up space

        // Then calculate space within the container for the canvas itself
        const availableWidthInContainer = container.clientWidth - padding;
        const availableHeightInContainer = container.clientHeight - padding;

        if (availableWidthInContainer <= 0 || availableHeightInContainer <= 0) return;

        const aspectRatio = pcData.canvasWidth / pcData.canvasHeight;
        
        let newCanvasDisplayWidth = availableWidthInContainer;
        let newCanvasDisplayHeight = newCanvasDisplayWidth / aspectRatio;

        if (newCanvasDisplayHeight > availableHeightInContainer) {
            newCanvasDisplayHeight = availableHeightInContainer;
            newCanvasDisplayWidth = newCanvasDisplayHeight * aspectRatio;
        }
        
        // Ensure minimum display size if needed, but mostly let it scale down
        canvas.style.width = Math.max(10, newCanvasDisplayWidth) + 'px';
        canvas.style.height = Math.max(10, newCanvasDisplayHeight) + 'px';
    }


    function addPixelCraftEventListeners() {
        pixelCraftDOM.pixelColorPicker.addEventListener('input', (e) => {
            getPixelCraftData().currentColor = e.target.value;
            window.saveData();
        });
        pixelCraftDOM.pixelSizeInput.addEventListener('input', (e) => {
            let newSize = parseInt(e.target.value);
            if (isNaN(newSize) || newSize < 1) newSize = 1;
            if (newSize > 50) newSize = 50;
            e.target.value = newSize; // Correct input if out of bounds
            getPixelCraftData().pencilSize = newSize;
            window.saveData();
        });
         pixelCraftDOM.pixelSizeInput.addEventListener('change', (e) => { // Ensure 'change' also updates
            let newSize = parseInt(e.target.value);
            if (isNaN(newSize) || newSize < 1) newSize = 1;
            if (newSize > 50) newSize = 50;
            e.target.value = newSize;
            getPixelCraftData().pencilSize = newSize;
            window.saveData();
        });

        pixelCraftDOM.pixelPencilTool.addEventListener('click', () => setPixelTool('pencil'));
        pixelCraftDOM.pixelEraserTool.addEventListener('click', () => setPixelTool('eraser'));
        pixelCraftDOM.pixelBucketTool.addEventListener('click', () => setPixelTool('bucket'));

        pixelCraftDOM.pixelCanvas.addEventListener('mousedown', startPixelDrawing);
        pixelCraftDOM.pixelCanvas.addEventListener('mouseup', stopPixelDrawing);
        pixelCraftDOM.pixelCanvas.addEventListener('mouseout', stopPixelDrawing); // Stop if mouse leaves canvas
        pixelCraftDOM.pixelCanvas.addEventListener('mousemove', pixelDraw);
        pixelCraftDOM.pixelCanvas.addEventListener('click', pixelBucketFill); // For bucket tool

        // Menu items
        let pixelActiveMenu = null;
        pixelCraftDOM.pixelMenuBar.querySelectorAll('.pixel-menu-bar > .pixel-menu-item').forEach(menuItem => {
            menuItem.addEventListener('click', (event) => {
                event.stopPropagation();
                if (pixelActiveMenu && pixelActiveMenu !== menuItem) {
                    pixelActiveMenu.classList.remove('open');
                }
                menuItem.classList.toggle('open');
                pixelActiveMenu = menuItem.classList.contains('open') ? menuItem : null;
            });
        });
        // Close pixel menu if clicked outside
        document.addEventListener('click', (event) => {
            if (pixelActiveMenu && !pixelCraftDOM.pixelMenuBar.contains(event.target)) {
                pixelActiveMenu.classList.remove('open');
                pixelActiveMenu = null;
            }
        });

        pixelCraftDOM.pixelFileSave.addEventListener('click', savePixelCanvas);
        pixelCraftDOM.pixelFileClearCanvas.addEventListener('click', clearPixelCanvas);
        pixelCraftDOM.pixelFileCanvasSize.addEventListener('click', openPixelCanvasSizeModal);
        
        // Modal buttons
        pixelCraftDOM.savePixelCanvasSizeBtn.addEventListener('click', handleSavePixelCanvasSize);
        pixelCraftDOM.confirmPixelResizeBtn.addEventListener('click', executePixelCanvasResize);

        const appWindow = getById(APP_ID);
        if (appWindow) {
            const closeButton = appWindow.querySelector('#pixelCloseBtn');
            if (closeButton) closeButton.addEventListener('click', () => {
                let state = window.appData.windowStates[APP_ID];
                if (state) state.hiddenByUser = true;
                window.saveWindowState(APP_ID);
                appWindow.style.display = 'none';
            });
            const minimizeButton = appWindow.querySelector('#pixelMinimizeBtn');
            if(minimizeButton) minimizeButton.addEventListener('click', () => window.minimizeWindow(APP_ID));

            const maximizeButton = appWindow.querySelector('#pixelMaximizeBtn');
            if(maximizeButton) maximizeButton.addEventListener('click', () => window.maximizeWindow(APP_ID));
        }
    }

    function setPixelTool(tool) {
        const pcData = getPixelCraftData();
        pcData.currentTool = tool;
        pixelCraftDOM.pixelPencilTool.classList.remove('active');
        pixelCraftDOM.pixelEraserTool.classList.remove('active');
        pixelCraftDOM.pixelBucketTool.classList.remove('active');

        if (tool === 'pencil') {
            pixelCraftDOM.pixelPencilTool.classList.add('active');
            pixelCraftDOM.pixelCanvas.style.cursor = 'crosshair';
        } else if (tool === 'eraser') {
            pixelCraftDOM.pixelEraserTool.classList.add('active');
            pixelCraftDOM.pixelCanvas.style.cursor = 'crosshair';
        } else if (tool === 'bucket') {
            pixelCraftDOM.pixelBucketTool.classList.add('active');
            pixelCraftDOM.pixelCanvas.style.cursor = 'copy'; // Or a bucket icon cursor if available
        }
        window.saveData();
    }

    function startPixelDrawing(e) {
        const pcData = getPixelCraftData();
        if (pcData.currentTool === 'bucket') return; // Bucket tool is click-only

        pixelIsDrawing = true;
        // Calculate mouse position relative to canvas logical pixels
        const rect = pixelCraftDOM.pixelCanvas.getBoundingClientRect();
        const scaleX = pixelCraftDOM.pixelCanvas.width / rect.width;
        const scaleY = pixelCraftDOM.pixelCanvas.height / rect.height;
        
        pixelLastX = (e.clientX - rect.left) * scaleX;
        pixelLastY = (e.clientY - rect.top) * scaleY;

        drawAtPoint(pixelLastX, pixelLastY); // Draw single point on mousedown
    }

    function stopPixelDrawing() {
        pixelIsDrawing = false;
        pixelLastX = undefined;
        pixelLastY = undefined;
    }

    function pixelDraw(e) {
        if (!pixelIsDrawing || getPixelCraftData().currentTool === 'bucket') return;

        const rect = pixelCraftDOM.pixelCanvas.getBoundingClientRect();
        const scaleX = pixelCraftDOM.pixelCanvas.width / rect.width;
        const scaleY = pixelCraftDOM.pixelCanvas.height / rect.height;

        const currentX = (e.clientX - rect.left) * scaleX;
        const currentY = (e.clientY - rect.top) * scaleY;

        drawLine(pixelLastX, pixelLastY, currentX, currentY);
        
        pixelLastX = currentX;
        pixelLastY = currentY;
    }

    function drawAtPoint(x, y) {
        const pcData = getPixelCraftData();
        const size = parseInt(pcData.pencilSize);
        const drawX = Math.floor(x); // Use floor for pixel grid alignment
        const drawY = Math.floor(y);

        if (pcData.currentTool === 'pencil') {
            pixelCtx.fillStyle = pcData.currentColor;
            pixelCtx.fillRect(drawX, drawY, 1, 1); // Draw single pixel for pencil
        } else if (pcData.currentTool === 'eraser') {
            pixelCtx.clearRect(drawX, drawY, 1, 1); // Clear single pixel for eraser
        }
    }
    
    // Bresenham's line algorithm for pixel-perfect lines
    function drawLine(x0, y0, x1, y1) {
        x0 = Math.floor(x0); y0 = Math.floor(y0);
        x1 = Math.floor(x1); y1 = Math.floor(y1);

        const dx = Math.abs(x1 - x0);
        const dy = -Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1;
        const sy = y0 < y1 ? 1 : -1;
        let err = dx + dy;

        while (true) {
            drawAtPoint(x0, y0); // Use the modified drawAtPoint
            if (x0 === x1 && y0 === y1) break;
            let e2 = 2 * err;
            if (e2 >= dy) {
                err += dy;
                x0 += sx;
            }
            if (e2 <= dx) {
                err += dx;
                y0 += sy;
            }
        }
    }


    function pixelBucketFill(e) {
        const pcData = getPixelCraftData();
        if (pcData.currentTool !== 'bucket') return;

        const rect = pixelCraftDOM.pixelCanvas.getBoundingClientRect();
        const scaleX = pixelCraftDOM.pixelCanvas.width / rect.width;
        const scaleY = pixelCraftDOM.pixelCanvas.height / rect.height;
        
        const startX = Math.floor((e.clientX - rect.left) * scaleX);
        const startY = Math.floor((e.clientY - rect.top) * scaleY);

        const canvasWidth = pixelCraftDOM.pixelCanvas.width;
        const canvasHeight = pixelCraftDOM.pixelCanvas.height;
        const imageData = pixelCtx.getImageData(0, 0, canvasWidth, canvasHeight);
        const data = imageData.data;

        const targetColor = getPixelColor(startX, startY, data, canvasWidth);
        const fillColorHex = pcData.currentColor;
        const rFill = parseInt(fillColorHex.slice(1, 3), 16);
        const gFill = parseInt(fillColorHex.slice(3, 5), 16);
        const bFill = parseInt(fillColorHex.slice(5, 7), 16);
        const fillColor = [rFill, gFill, bFill, 255];

        if (colorsMatch(targetColor, fillColor)) return; // Clicked on already filled area

        const stack = [[startX, startY]];
        
        while (stack.length > 0) {
            const [x, y] = stack.pop();
            if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) continue;

            const currentColor = getPixelColor(x, y, data, canvasWidth);
            if (colorsMatch(currentColor, targetColor)) {
                setPixelColor(x, y, fillColor, data, canvasWidth);
                stack.push([x + 1, y]);
                stack.push([x - 1, y]);
                stack.push([x, y + 1]);
                stack.push([x, y - 1]);
            }
        }
        pixelCtx.putImageData(imageData, 0, 0);
    }

    function getPixelColor(x, y, data, width) {
        const index = (y * width + x) * 4;
        return [data[index], data[index + 1], data[index + 2], data[index + 3]];
    }

    function setPixelColor(x, y, color, data, width) {
        const index = (y * width + x) * 4;
        data[index] = color[0];
        data[index + 1] = color[1];
        data[index + 2] = color[2];
        data[index + 3] = color[3];
    }

    function colorsMatch(c1, c2) {
        return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3];
    }

    function savePixelCanvas() {
        let filename = prompt("Filename for your masterpiece:", "pixel_art.png");
        if (filename) {
            if (!filename.toLowerCase().endsWith('.png')) filename += '.png';
            const dataURL = pixelCraftDOM.pixelCanvas.toDataURL('image/png');
            const downloadLink = document.createElement('a');
            downloadLink.href = dataURL;
            downloadLink.download = filename;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }
        const pixelFileMenu = pixelCraftDOM.pixelFileSave.closest('.pixel-menu-item');
        if(pixelFileMenu && pixelFileMenu.classList.contains('open')) {
            pixelFileMenu.classList.remove('open');
        }
    }

    function clearPixelCanvas() {
        if (pixelCtx && pixelCraftDOM.pixelCanvas) {
            pixelCtx.fillStyle = 'white'; // Or transparent: pixelCtx.clearRect(0, 0, ...);
            pixelCtx.fillRect(0, 0, pixelCraftDOM.pixelCanvas.width, pixelCraftDOM.pixelCanvas.height);
        }
        const pixelFileMenu = pixelCraftDOM.pixelFileClearCanvas.closest('.pixel-menu-item');
        if(pixelFileMenu && pixelFileMenu.classList.contains('open')) {
            pixelFileMenu.classList.remove('open');
        }
    }

    function openPixelCanvasSizeModal() {
        const pcData = getPixelCraftData();
        pixelCraftDOM.pixelNewCanvasWidthInput.value = pcData.canvasWidth;
        pixelCraftDOM.pixelNewCanvasHeightInput.value = pcData.canvasHeight;
        window.openModal('pixelCanvasSizeModal');
        const pixelFileMenu = pixelCraftDOM.pixelFileCanvasSize.closest('.pixel-menu-item');
         if(pixelFileMenu && pixelFileMenu.classList.contains('open')) {
            pixelFileMenu.classList.remove('open');
        }
    }

    function handleSavePixelCanvasSize() {
        const newWidth = parseInt(pixelCraftDOM.pixelNewCanvasWidthInput.value);
        const newHeight = parseInt(pixelCraftDOM.pixelNewCanvasHeightInput.value);
        if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 10 || newWidth > 2000 || newHeight < 10 || newHeight > 2000) {
            alert("Invalid canvas dimensions. Width and height must be between 10 and 2000 pixels.");
            return;
        }
        window.closeModal('pixelCanvasSizeModal');
        window.openModal('confirmPixelResizeModal');
    }

    function executePixelCanvasResize() {
        const pcData = getPixelCraftData();
        const newWidth = parseInt(pixelCraftDOM.pixelNewCanvasWidthInput.value);
        const newHeight = parseInt(pixelCraftDOM.pixelNewCanvasHeightInput.value);
        // Validation already done in handleSavePixelCanvasSize, but good to have a check
        if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 10 || newHeight < 10) {
             window.closeModal('confirmPixelResizeModal'); return;
        }

        window.closeModal('confirmPixelResizeModal');
        pcData.canvasWidth = newWidth;
        pcData.canvasHeight = newHeight;
        pixelCraftDOM.pixelCanvas.width = newWidth;
        pixelCraftDOM.pixelCanvas.height = newHeight;
        clearPixelCanvas(); // Clear with new dimensions
        handlePixelWindowResize(); // Adjust display scaling
        window.saveData();
    }


    function setupPixelCraftApp() {
        const windowBody = getById('pixelWindowBody');
        const bodyContentTemplate = document.getElementById('pixelCraftBodyContentTemplate');

        if (windowBody && bodyContentTemplate) {
            windowBody.innerHTML = '';
            windowBody.appendChild(bodyContentTemplate.content.cloneNode(true));
        } else {
            console.error("Pixel Craft window body or content template not found.");
            return;
        }
        
        if (!window.appRegistry) window.appRegistry = {};
        window.appRegistry[APP_ID] = {
            minWidth: MIN_WIDTH,
            minHeight: MIN_HEIGHT,
            defaultWidth: DEFAULT_WIDTH,
            defaultHeight: DEFAULT_HEIGHT,
            appName: "Pixel Craft"
        };
        
        initPixelCraftApp();
    }

    window.setupPixelCraftApp = setupPixelCraftApp;

})();
</script>
