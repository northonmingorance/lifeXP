<body data-app-id="pixelCraft">

    <template id="pixelCraft-icon-template">
        <div class="icon-image">üé®</div>
        <div class="icon-label">Pixel Craft</div>
    </template>

    <template id="pixelCraft-window-template">
        <div class="xp-window" id="pixelCraftWindow" style="display:none;">
            <div class="title-bar">
                <span class="title-bar-text">Pixel Craft</span>
                <div class="title-bar-controls">
                    <button data-app-action="minimize" title="Minimize">0</button>
                    <button data-app-action="maximize" title="Maximize">1</button>
                    <button data-app-action="close" title="Close">r</button>
                </div>
            </div>
            <div class="window-body" id="pixelCraftWindowBody" style="padding:0; display:flex; flex-direction:column; overflow:hidden;">
                <div id="pixelCraftMenuBar" style="background-color: #ECE9D8; padding: 2px 3px; border-bottom: 1px solid #ACA899; display: flex; flex-shrink: 0; user-select: none; color: #000000;">
                    <div class="pixel-menu-item" tabindex="0" style="padding: 3px 8px; cursor: default; position: relative; color: inherit;">
                        File
                        <div class="pixel-dropdown-content" style="display: none; position: absolute; top: 100%; left: 0; background-color: #ECE9D8; border: 1px solid #000; box-shadow: 1px 1px 3px rgba(0,0,0,0.2); z-index: 100; padding: 2px 0; color: #000000; min-width:120px;">
                            <div class="pixel-dropdown-item" id="pixelCraftFileSave" style="padding: 4px 12px; cursor: default; white-space: nowrap; color: inherit;">Save</div>
                            <div class="pixel-dropdown-item" id="pixelCraftFileClearCanvas" style="padding: 4px 12px; cursor: default; white-space: nowrap; color: inherit;">Clear canvas</div>
                            <div class="pixel-dropdown-item" id="pixelCraftFileCanvasSize" style="padding: 4px 12px; cursor: default; white-space: nowrap; color: inherit;">Canvas size</div>
                        </div>
                    </div>
                </div>
                <div style="display: flex; align-items: center; padding: 4px; border-bottom: 1px solid #000000; background-color: #ECE9D8; flex-shrink: 0; gap: 5px;">
                    <input type="number" class="pixel-size-input" id="pixelCraftSizeInput" value="2" min="1" max="50" title="Pencil/Eraser Size" style="width: 24px; height: 20px; border: 1px inset #7F7F7F; padding: 2px 4px; font-family: 'Tahoma', Geneva, sans-serif; font-size: 12px; text-align: center; background-color: #FFFFFF; margin-right: 3px; box-sizing: border-box;">
                    <button class="pixel-tool-button active" id="pixelCraftPencilTool" title="Pencil" style="font-family: 'Tahoma', Geneva, sans-serif; font-size: 18px; border: 1px outset #7F7F7F; background-color: #ECE9D8; min-width: 24px; height: 24px; padding: 0; cursor: default; display: flex; align-items: center; justify-content: center;">‚úèÔ∏è</button>
                    <button class="pixel-tool-button" id="pixelCraftEraserTool" title="Eraser" style="font-family: 'Tahoma', Geneva, sans-serif; font-size: 18px; border: 1px outset #7F7F7F; background-color: #ECE9D8; min-width: 24px; height: 24px; padding: 0; cursor: default; display: flex; align-items: center; justify-content: center;">üßº</button>
                    <button class="pixel-tool-button" id="pixelCraftBucketTool" title="Paint Bucket" style="font-family: 'Tahoma', Geneva, sans-serif; font-size: 18px; border: 1px outset #7F7F7F; background-color: #ECE9D8; min-width: 24px; height: 24px; padding: 0; cursor: default; display: flex; align-items: center; justify-content: center;">ü´ó</button>
                    <input type="color" id="pixelCraftColorPicker" value="#000000" title="Color Picker" style="width: 24px; height: 24px; border: 1px solid #7F7F7F; padding: 0; background-color: #ECE9D8; cursor: pointer;">
                </div>
                <div id="pixelCraftCanvasContainer" style="flex-grow: 1; background-color: #808080; padding: 5px; display: flex; justify-content: center; align-items: center; overflow: auto;">
                    <canvas id="pixelCraftCanvas" style="background-color: white; border: 1px solid #000; cursor: default; max-width: 100%; max-height: 100%; object-fit: contain;"></canvas>
                </div>
            </div>
            <div class="resize-handle"></div>
            <div id="pixelCraftCanvasSizeModal" class="modal"><div class="modal-content" style="max-width:400px"><div class="modal-title-bar"><span>Set Canvas Size</span><span class="close-button" data-modal-id="pixelCraftCanvasSizeModal">r</span></div><div class="modal-body"><label for="pixelCraftNewCanvasWidth">New Width (px):</label><input type="number" id="pixelCraftNewCanvasWidth" min="50" max="2000" value="600"><label for="pixelCraftNewCanvasHeight">New Height (px):</label><input type="number" id="pixelCraftNewCanvasHeight" min="50" max="2000" value="400"><p><small>Min: 50px, Max: 2000px.</small></p></div><div class="modal-footer"><button id="pixelCraftSaveCanvasSizeBtn" class="xp-button">Save</button><button class="xp-button" data-modal-id="pixelCraftCanvasSizeModal">Cancel</button></div></div></div>
            <div id="pixelCraftConfirmResizeModal" class="modal"><div class="modal-content" style="max-width:400px"><div class="modal-title-bar"><span>Confirm Canvas Resize</span><span class="close-button" data-modal-id="pixelCraftConfirmResizeModal">r</span></div><div class="modal-body"><p>Changing canvas size will clear the drawing. Proceed?</p></div><div class="modal-footer"><button id="pixelCraftConfirmResizeBtn" class="xp-button">Proceed</button><button class="xp-button" data-modal-id="pixelCraftConfirmResizeModal">Cancel</button></div></div></div>
        </div>
    </template>

    <script type="application/json" id="pixelCraft-config">
    {
        "minWidth": 375,
        "minHeight": 300,
        "defaultWidth": 650,
        "defaultHeight": 500,
        "defaultOffsetX": 220,
        "defaultOffsetY": 220
    }
    </script>

    <script id="pixelCraft-script">
    const appWindow = this.appWindow;
    const appData = this.appData;
    const os = this.os;

    const DOM = {
        menuBar: appWindow.querySelector('#pixelCraftMenuBar'),
        fileSave: appWindow.querySelector('#pixelCraftFileSave'),
        fileClearCanvas: appWindow.querySelector('#pixelCraftFileClearCanvas'),
        fileCanvasSize: appWindow.querySelector('#pixelCraftFileCanvasSize'),
        pencilTool: appWindow.querySelector('#pixelCraftPencilTool'),
        eraserTool: appWindow.querySelector('#pixelCraftEraserTool'),
        bucketTool: appWindow.querySelector('#pixelCraftBucketTool'),
        colorPicker: appWindow.querySelector('#pixelCraftColorPicker'),
        sizeInput: appWindow.querySelector('#pixelCraftSizeInput'),
        canvas: appWindow.querySelector('#pixelCraftCanvas'),
        canvasContainer: appWindow.querySelector('#pixelCraftCanvasContainer'),
        canvasSizeModal: appWindow.querySelector('#pixelCraftCanvasSizeModal'),
        newCanvasWidthInput: appWindow.querySelector('#pixelCraftNewCanvasWidth'),
        newCanvasHeightInput: appWindow.querySelector('#pixelCraftNewCanvasHeight'),
        saveCanvasSizeBtn: appWindow.querySelector('#pixelCraftSaveCanvasSizeBtn'),
        confirmResizeModal: appWindow.querySelector('#pixelCraftConfirmResizeModal'),
        confirmResizeBtn: appWindow.querySelector('#pixelCraftConfirmResizeBtn'),
    };

    let ctx = null;
    let isDrawing = false;
    let lastX, lastY;

    function initializeDefaultAppData() {
        if (appData.currentColor === undefined) appData.currentColor = '#000000';
        if (appData.currentTool === undefined) appData.currentTool = 'pencil';
        if (appData.pencilSize === undefined || isNaN(parseInt(appData.pencilSize))) appData.pencilSize = 2;
        else appData.pencilSize = Math.max(1, Math.min(50, parseInt(appData.pencilSize)));
        if (appData.canvasWidth === undefined) appData.canvasWidth = 600;
        if (appData.canvasHeight === undefined) appData.canvasHeight = 400;
        if (appData.canvasDataUrl === undefined) appData.canvasDataUrl = null;
    }
    initializeDefaultAppData();

    function initPixelApp() {
        ctx = DOM.canvas.getContext('2d');
        DOM.canvas.width = appData.canvasWidth;
        DOM.canvas.height = appData.canvasHeight;
        
        if (appData.canvasDataUrl) {
            const img = new Image();
            img.onload = () => { ctx.drawImage(img, 0, 0); };
            img.src = appData.canvasDataUrl;
        } else {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, DOM.canvas.width, DOM.canvas.height);
        }

        DOM.colorPicker.value = appData.currentColor;
        DOM.sizeInput.value = appData.pencilSize;

        DOM.colorPicker.addEventListener('input', (e) => { appData.currentColor = e.target.value; os.saveAppData(); });
        DOM.sizeInput.addEventListener('input', (e) => {
            let s = parseInt(e.target.value);
            s = isNaN(s) ? 1 : Math.max(1, Math.min(50,s));
            e.target.value = s; appData.pencilSize = s; os.saveAppData();
        });
        DOM.sizeInput.addEventListener('change', (e) => { // Ensure value sticks if user types and blurs
             let s = parseInt(e.target.value);
            s = isNaN(s) ? 1 : Math.max(1, Math.min(50,s));
            e.target.value = s; appData.pencilSize = s; os.saveAppData();
        });

        DOM.pencilTool.addEventListener('click', () => setTool('pencil'));
        DOM.eraserTool.addEventListener('click', () => setTool('eraser'));
        DOM.bucketTool.addEventListener('click', () => setTool('bucket'));

        DOM.canvas.addEventListener('mousedown', startDrawing);
        DOM.canvas.addEventListener('mouseup', stopDrawing);
        DOM.canvas.addEventListener('mouseout', stopDrawing);
        DOM.canvas.addEventListener('mousemove', draw);
        DOM.canvas.addEventListener('click', bucketFill);

        DOM.fileSave.addEventListener('click', saveCanvas);
        DOM.fileClearCanvas.addEventListener('click', clearCanvas);
        DOM.fileCanvasSize.addEventListener('click', openCanvasSizeModal);
        
        let activeMenu = null;
        DOM.menuBar.querySelectorAll('.pixel-menu-item').forEach(menuItem => {
            menuItem.addEventListener('click', (event) => {
                event.stopPropagation();
                const dropdown = menuItem.querySelector('.pixel-dropdown-content');
                if (activeMenu && activeMenu !== menuItem) activeMenu.querySelector('.pixel-dropdown-content').style.display = 'none';
                if (dropdown) {
                    const isOpen = dropdown.style.display === 'block';
                    dropdown.style.display = isOpen ? 'none' : 'block';
                    activeMenu = isOpen ? null : menuItem;
                }
            });
        });
        appWindow.addEventListener('click', (event) => { // Close menu on outside click
            if (activeMenu && !activeMenu.contains(event.target)) {
                activeMenu.querySelector('.pixel-dropdown-content').style.display = 'none';
                activeMenu = null;
            }
        });
        setTool(appData.currentTool);
        handleResize();
    }

    function setTool(tool) {
        appData.currentTool = tool;
        [DOM.pencilTool, DOM.eraserTool, DOM.bucketTool].forEach(btn => btn.classList.remove('active'));
        if (tool === 'pencil') { DOM.pencilTool.classList.add('active'); DOM.canvas.style.cursor = 'crosshair'; }
        else if (tool === 'eraser') { DOM.eraserTool.classList.add('active'); DOM.canvas.style.cursor = 'crosshair'; }
        else if (tool === 'bucket') { DOM.bucketTool.classList.add('active'); DOM.canvas.style.cursor = 'copy'; }
        os.saveAppData();
    }

    function handleResize() {
        if (appWindow.classList.contains('minimized') || appWindow.style.display === 'none') return;
        const container = DOM.canvasContainer;
        const canvasEl = DOM.canvas;
        const padding = 10;
        const menuBarHeight = DOM.menuBar.offsetHeight;
        const toolbarHeight = appWindow.querySelector('.pixel-toolbar') ? appWindow.querySelector('.pixel-toolbar').offsetHeight : 30; // Fallback
        const availableWidth = container.clientWidth - padding;
        const availableHeight = appWindow.querySelector('.window-body').clientHeight - menuBarHeight - toolbarHeight - padding - 5;

        if (availableWidth > 0 && availableHeight > 0) {
            const aspectRatio = appData.canvasWidth / appData.canvasHeight;
            let newCanvasWidth = availableWidth;
            let newCanvasHeight = newCanvasWidth / aspectRatio;
            if (newCanvasHeight > availableHeight) {
                newCanvasHeight = availableHeight;
                newCanvasWidth = newCanvasHeight * aspectRatio;
            }
            canvasEl.style.width = Math.max(50, newCanvasWidth) + 'px';
            canvasEl.style.height = Math.max(50, newCanvasHeight) + 'px';
        }
    }

    function startDrawing(e) {
        if (appData.currentTool === 'bucket' || e.button !== 0) return;
        isDrawing = true;
        const rect = DOM.canvas.getBoundingClientRect();
        const scaleX = DOM.canvas.width / rect.width;
        const scaleY = DOM.canvas.height / rect.height;
        lastX = (e.clientX - rect.left) * scaleX;
        lastY = (e.clientY - rect.top) * scaleY;
        drawPixel(lastX, lastY); // Draw single pixel on click
    }

    function stopDrawing() {
        if (isDrawing) {
            appData.canvasDataUrl = DOM.canvas.toDataURL();
            os.saveAppData();
        }
        isDrawing = false;
    }
    
    function drawPixel(x, y) { // Helper to draw a single "pixel" based on brush size
        const size = parseInt(appData.pencilSize);
        const drawX = Math.floor(x - size / 2);
        const drawY = Math.floor(y - size / 2);
        if (appData.currentTool === 'pencil') {
            ctx.fillStyle = appData.currentColor;
            ctx.globalCompositeOperation = 'source-over';
        } else if (appData.currentTool === 'eraser') {
            ctx.globalCompositeOperation = 'destination-out'; // Clears pixels
            ctx.fillStyle = 'rgba(0,0,0,1)'; // Needed for destination-out to work
        }
        ctx.fillRect(drawX, drawY, size, size);
    }

    function draw(e) {
        if (!isDrawing || appData.currentTool === 'bucket') return;
        const rect = DOM.canvas.getBoundingClientRect();
        const scaleX = DOM.canvas.width / rect.width;
        const scaleY = DOM.canvas.height / rect.height;
        const currentX = (e.clientX - rect.left) * scaleX;
        const currentY = (e.clientY - rect.top) * scaleY;

        // Bresenham's line algorithm or simple interpolation for smoother lines
        let x0 = Math.floor(lastX); let y0 = Math.floor(lastY);
        let x1 = Math.floor(currentX); let y1 = Math.floor(currentY);
        const dx = Math.abs(x1 - x0); const dy = -Math.abs(y1 - y0);
        let sx = x0 < x1 ? 1 : -1; let sy = y0 < y1 ? 1 : -1;
        let err = dx + dy; let e2;

        for (;;) {
            drawPixel(x0, y0);
            if (x0 === x1 && y0 === y1) break;
            e2 = 2 * err;
            if (e2 >= dy) { err += dy; x0 += sx; }
            if (e2 <= dx) { err += dx; y0 += sy; }
        }
        lastX = currentX; lastY = currentY;
    }

    function bucketFill(e) {
        if (appData.currentTool !== 'bucket' || e.button !== 0) return;
        ctx.globalCompositeOperation = 'source-over';
        const rect = DOM.canvas.getBoundingClientRect();
        const scaleX = DOM.canvas.width / rect.width;
        const scaleY = DOM.canvas.height / rect.height;
        const x = Math.floor((e.clientX - rect.left) * scaleX);
        const y = Math.floor((e.clientY - rect.top) * scaleY);
        
        const canvasWidth = DOM.canvas.width; const canvasHeight = DOM.canvas.height;
        const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
        const data = imageData.data;
        const startIdx = (y * canvasWidth + x) * 4;
        const targetColor = [data[startIdx], data[startIdx+1], data[startIdx+2], data[startIdx+3]];
        
        const fillColorHex = appData.currentColor;
        const rFill = parseInt(fillColorHex.slice(1,3),16); const gFill = parseInt(fillColorHex.slice(3,5),16); const bFill = parseInt(fillColorHex.slice(5,7),16);
        const fillColor = [rFill, gFill, bFill, 255];

        if (targetColor.every((val, i) => val === fillColor[i])) return; // Clicked on already filled area

        const stack = [[x,y]];
        while(stack.length) {
            const [cx, cy] = stack.pop();
            if (cx < 0 || cx >= canvasWidth || cy < 0 || cy >= canvasHeight) continue;
            const idx = (cy * canvasWidth + cx) * 4;
            if (data[idx] === targetColor[0] && data[idx+1] === targetColor[1] && data[idx+2] === targetColor[2] && data[idx+3] === targetColor[3]) {
                data[idx] = fillColor[0]; data[idx+1] = fillColor[1]; data[idx+2] = fillColor[2]; data[idx+3] = fillColor[3];
                stack.push([cx+1,cy]); stack.push([cx-1,cy]); stack.push([cx,cy+1]); stack.push([cx,cy-1]);
            }
        }
        ctx.putImageData(imageData,0,0);
        appData.canvasDataUrl = DOM.canvas.toDataURL();
        os.saveAppData();
    }

    function saveCanvas() {
        let filename = prompt("Filename:", "pixel_art.png");
        if (filename) {
            if (!filename.toLowerCase().endsWith('.png')) filename += '.png';
            const dataURL = DOM.canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL; link.download = filename;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        }
        closePixelMenus();
    }
    function clearCanvas() {
        if (ctx && DOM.canvas) {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, DOM.canvas.width, DOM.canvas.height);
            appData.canvasDataUrl = DOM.canvas.toDataURL(); // Save cleared state
            os.saveAppData();
        }
        closePixelMenus();
    }
    function openCanvasSizeModal() {
        DOM.newCanvasWidthInput.value = appData.canvasWidth;
        DOM.newCanvasHeightInput.value = appData.canvasHeight;
        os.openModal(DOM.canvasSizeModal);
        closePixelMenus();
    }
    DOM.saveCanvasSizeBtn.addEventListener('click', () => {
        const w = parseInt(DOM.newCanvasWidthInput.value); const h = parseInt(DOM.newCanvasHeightInput.value);
        if (isNaN(w) || isNaN(h) || w<50 || w>2000 || h<50 || h>2000) { alert("Invalid dimensions (50-2000px)."); return; }
        os.closeModal(DOM.canvasSizeModal);
        os.openModal(DOM.confirmResizeModal);
    });
    DOM.confirmResizeBtn.addEventListener('click', () => {
        const w = parseInt(DOM.newCanvasWidthInput.value); const h = parseInt(DOM.newCanvasHeightInput.value);
        os.closeModal(DOM.confirmResizeModal);
        appData.canvasWidth = w; appData.canvasHeight = h;
        DOM.canvas.width = w; DOM.canvas.height = h;
        clearCanvas(); // This also saves the cleared state
        handleResize();
        os.saveAppData();
    });
    
    function closePixelMenus() {
        DOM.menuBar.querySelectorAll('.pixel-menu-item').forEach(mi => {
            const dd = mi.querySelector('.pixel-dropdown-content');
            if (dd) dd.style.display = 'none';
        });
    }
    
    appWindow.querySelectorAll('.modal .close-button, .modal .xp-button[data-modal-id]').forEach(button => {
        button.addEventListener('click', (event) => {
            const modalId = event.target.dataset.modalId || event.target.closest('.modal').id;
            if (modalId) os.closeModal(appWindow.querySelector('#'+modalId));
        });
    });

    this.onOpen = (win) => { initPixelApp(); };
    this.onResize = handleResize;
    this.onClose = () => {
        if (ctx) { // Save canvas on close
            appData.canvasDataUrl = DOM.canvas.toDataURL();
            os.saveAppData();
        }
    };

    initPixelApp(); // Initial setup when script is first run for the window
    </script>
</body>
