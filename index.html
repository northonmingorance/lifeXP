<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life XP OS</title>
    <style>
        body {
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #3A6EA5;
            background-image: url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png');
            background-size: cover;
            background-position: 0% 0%;
            background-repeat: no-repeat;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        .xp-window {
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            min-height: 30px;
            display: flex;
            flex-direction: column;
            position: absolute;
            overflow: hidden;
        }
        .xp-window.disable-selection,
        .xp-window.disable-selection * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #000;
            cursor: grab;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
            user-select: none;
        }
        .title-bar:active {
            cursor: grabbing;
        }
        .title-bar-text {
            margin-left: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        .title-bar-controls button {
            background-color: #ECE9D8;
            border: 1px solid #000;
            width: 22px;
            height: 18px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-size: 12px;
            line-height: 16px;
            margin-left: 2px;
            box-shadow: 1px 1px 0px #FFF inset, -1px -1px 0px #808080 inset;
            padding: 0;
            text-align: center;
            cursor: default;
        }
        .title-bar-controls button:active:not(:disabled) {
            box-shadow: -1px -1px 0px #FFF inset, 1px 1px 0px #808080 inset;
        }
        .title-bar-controls button:disabled {
            color: #7F7F7F;
            cursor: default;
            opacity: 0.7;
        }
        .window-body {
            padding: 0;
            flex-grow: 1;
            overflow-y: auto;
            opacity: 1;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.2s ease-out;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Important for iframes/canvas to not overflow padding */
        }
        .xp-menu-bar {
            background-color: #ECE9D8;
            border-bottom: 1px solid #000;
            display: flex;
            padding: 1px 2px;
            height: 21px;
            flex-shrink: 0;
            user-select: none;
            position: relative;
            z-index: 50;
        }
        .xp-menu-item {
            padding: 2px 7px;
            cursor: default;
            position: relative;
            font-size: 11px;
            line-height: 16px;
        }
        .xp-menu-item:hover,
        .xp-menu-item.active {
            background-color: #316AC5;
            color: white;
        }
        .xp-dropdown-menu {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background-color: #ECE9D8;
            border: 1px solid #7F7F7F;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1), -1px -1px 2px rgba(0,0,0,0.1);
            min-width: 160px;
            z-index: 150;
            padding: 2px;
        }
        .xp-menu-item.active .xp-dropdown-menu {
            display: block;
        }
        .xp-dropdown-item {
            padding: 4px 12px 4px 12px;
            cursor: default;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            font-size: 11px;
            white-space: nowrap;
            color: #000000;
        }
        .xp-dropdown-item:hover,
        .xp-dropdown-item.submenu-active {
            background-color: #316AC5;
            color: white;
        }
        .xp-dropdown-item.submenu-active .xp-submenu-arrow{
            color: white;
        }
        .xp-submenu-arrow {
            font-size: 10px;
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            color: #333;
        }
         .xp-dropdown-item:hover .xp-submenu-arrow {
            color: white;
         }
        .xp-submenu {
            display: none;
            position: absolute;
            left: calc(100% - 4px);
            top: -3px;
            background-color: #ECE9D8;
            border: 1px solid #7F7F7F;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1), -1px -1px 2px rgba(0,0,0,0.1);
            min-width: 180px;
            max-width: 250px;
            z-index: 151;
            padding: 2px;
            color: #000000;
        }
        .xp-dropdown-item.submenu-active .xp-submenu {
            display: block;
        }
        .xp-submenu-item {
            padding: 4px 12px 4px 20px;
            cursor: default;
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            position: relative;
        }
        .xp-submenu-item:hover:not(.disabled-resolution) {
            background-color: #316AC5;
            color: white;
        }
        .xp-submenu-item.selected::before {
            content: "â€¢";
            position: absolute;
            left: 7px;
            font-size: 14px;
            line-height: 1;
            top: 50%;
            transform: translateY(-50%);
        }
         .xp-submenu-item.selected:hover:not(.disabled-resolution)::before {
            color: white;
         }
        .xp-submenu-item.disabled-resolution {
            color: #999 !important;
            cursor: not-allowed !important;
        }
        .xp-submenu-item.disabled-resolution:hover {
            background-color: #ECE9D8 !important;
            color: #999 !important;
        }
         .xp-submenu-item.disabled-resolution.selected::before {
            color: #999 !important;
         }
         .xp-submenu-item.disabled-resolution:hover.selected::before {
            color: #999 !important;
         }
        .xp-menu-item u, .xp-dropdown-item u {
            text-decoration: underline;
        }
        .xp-window.minimized .window-body,
        .xp-window.minimized .xp-menu-bar {
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            opacity: 0 !important;
            overflow: hidden !important;
            border-top: none !important;
        }
        .xp-window.minimized {
            min-height: 28px !important;
            height: 28px !important;
            overflow: hidden;
        }
        .xp-button {
            background-color: #ECE9D8;
            border: 1px outset #7F7F7F;
            padding: 5px 12px;
            min-width: 75px;
            text-align: center;
            cursor: pointer;
            margin: 2px;
        }
        .xp-button:active {
            border-style: inset;
        }
        .xp-button:hover {
            border-color: #005CFE;
        }
        .xp-button:disabled {
            color: #7F7F7F;
            border-color: #ACA899;
            cursor: default;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #ECE9D8;
            margin: auto;
            padding: 0;
            border: 1px solid #000;
            width: 80%;
            max-width: 500px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
            display: flex;
            flex-direction: column;
        }
        .modal-title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            border-bottom: 1px solid #000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .modal-title-bar .close-button {
            color: white;
            font-size: 16px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-weight: normal;
            background: #E04343;
            border: 1px outset white;
            width: 22px;
            height: 18px;
            text-align: center;
            line-height: 16px;
            padding: 0;
            cursor: pointer;
        }
        .modal-title-bar .close-button:hover,
        .modal-title-bar .close-button:focus {
            background: #FF6363;
            text-decoration: none;
        }
         .modal-title-bar .close-button:active {
            border-style: inset;
        }
        .modal-body {
            padding: 15px;
            overflow-y: auto;
            flex-grow: 1;
        }
        .modal-body p {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .modal-body label {
            display: block;
            margin-bottom: 5px;
            margin-top: 12px;
        }
        .modal-body input[type="text"],
        .modal-body input[type="number"],
        .modal-body textarea,
        .modal-body select {
            width: calc(100% - 12px);
            padding: 5px;
            margin-bottom: 10px;
            border: 1px solid #ACA899;
            box-sizing: border-box;
        }
        .modal-body input[type="file"] {
            margin-bottom: 5px;
        }
         .modal-body hr {
            border: 0;
            height: 1px;
            background: #ACA899;
            margin: 20px 0;
        }
        .modal-footer {
            padding: 10px 15px;
            text-align: right;
            background-color: #F0F0F0;
            border-top: 1px solid #ACA899;
            flex-shrink: 0;
        }
        @keyframes fadeIn {
            from {opacity: 0; transform: scale(0.9);}
            to {opacity: 1; transform: scale(1);}
        }
        .resize-handle {
            width: 12px;
            height: 12px;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            z-index: 10;
            box-sizing: border-box;
            opacity: 0.6;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center center;
        }
        .resize-handle:hover {
            opacity: 1;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
        }
        .xp-window.true-maximized .resize-handle {
            display: none;
        }
        .color-swatch-item {
            box-sizing: border-box;
            transition: transform 0.1s ease-out;
        }
        .color-swatch-item:hover {
            outline: 2px solid #005CFE;
            outline-offset: 1px;
            transform: scale(1.1);
        }
        .desktop-icon {
            position: absolute;
            width: 90px;
            height: 100px;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 1px black;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 10px;
            box-sizing: border-box;
            z-index: 5;
        }
        .desktop-icon:active {
            cursor: grabbing;
        }
        .desktop-icon .icon-image {
            font-size: 48px;
            line-height: 1;
            margin-bottom: 8px;
        }
        .desktop-icon .icon-label {
            font-size: 12px;
            font-weight: normal;
            word-wrap: break-word;
            max-width: 100%;
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-remote-config.js"></script>
</head>
<body>
    <div id="desktopIconsContainer"></div>
    <div id="windowsContainer"></div>

    <div id="changeBgImageModal" class="modal">
        <div class="modal-content" style="max-width: 550px;"> <div class="modal-title-bar">
                <span>Change Background</span>
                <span class="close-button" data-modal-id="changeBgImageModal">r</span>
            </div>
            <div class="modal-body">
                <p>Choose a background type for the application:</p>
                <div>
                    <label for="newBgImageInput">1. Upload image file:</label>
                    <input type="file" id="newBgImageInput" accept="image/*">
                     <p><small>Max 5MB recommended for file uploads due to browser storage limits.</small></p>
                    <button id="uploadBgImageBtn" class="xp-button" style="margin-top: 5px;">Upload File & Apply</button>
                </div>
                <hr>
                <div>
                    <label for="bgImageUrlInput">2. Enter image URL:</label>
                    <input type="text" id="bgImageUrlInput" placeholder="https://example.com/image.png">
                    <p><small>Using a URL is recommended for very large images from the web.</small></p>
                    <button id="applyBgImageUrlBtn" class="xp-button" style="margin-top: 5px;">Apply URL</button>
                </div>
                <hr>
                <div>
                    <label>3. Pick a solid color:</label>
                    <div id="bgColorSwatchesContainer" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; justify-content: center;">
                          </div>
                     <p style="margin-top: 8px;"><small>Click a color swatch to apply it immediately.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="xp-button" data-modal-id="changeBgImageModal">Cancel</button>
            </div>
        </div>
    </div>

<script>
    "use strict";
    window.YOUTUBE_API_KEY = ""; 
    window.GEMINI_API_KEY = "";  
    const STORAGE_KEY = 'lifeXpOS_v1.1.0'; 
    const ICON_GRID_SIZE = 25;
    const STANDARD_COLORS = [
        { name: 'Black', value: '#000000' }, { name: 'Silver', value: '#C0C0C0' },
        { name: 'Gray', value: '#808080' }, { name: 'White', value: '#FFFFFF' },
        { name: 'Maroon', value: '#800000' }, { name: 'Red', value: '#FF0000' },
        { name: 'Purple', value: '#800080' }, { name: 'Fuchsia', value: '#FF00FF' },
        { name: 'Green', value: '#008000' }, { name: 'Lime', value: '#00FF00' },
        { name: 'Olive', value: '#808000' }, { name: 'Yellow', value: '#FFFF00' },
        { name: 'Navy', value: '#000080' }, { name: 'Blue', value: '#0000FF' },
        { name: 'Teal', value: '#008080' }, { name: 'Aqua', value: '#00FFFF' },
        { name: 'Orange', value: '#FFA500' }, { name: 'Brown', value: '#A52A2A' },
        { name: 'Pink', value: '#FFC0CB' }, { name: 'Gold', value: '#FFD700' },
        { name: 'Dark Green', value: '#006400' }, { name: 'Light Blue', value: '#ADD8E6' },
        { name: 'Indigo', value: '#4B0082' }, { name: 'Violet', value: '#EE82EE' },
        { name: 'Coral', value: '#FF7F50' }, { name: 'Sky Blue', value: '#87CEEB' }
    ];
    const MODAL_IDS_OS = { 
        CHANGE_BG_IMAGE: 'changeBgImageModal'
    };
    const firebaseConfig = {
      apiKey: "AIzaSyCVWUnnXiOvKRqbvngafdZC7DedEY-7vpg",
      authDomain: "lifexpapp-f5578.firebaseapp.com",
      projectId: "lifexpapp-f5578",
      storageBucket: "lifexpapp-f5578.appspot.com",
      messagingSenderId: "194098013746",
      appId: "1:194098013746:web:720ba296ee9e40dee37e2b"
    };
    firebase.initializeApp(firebaseConfig);
    const remoteConfig = firebase.remoteConfig();
    remoteConfig.defaultConfig = {
      'youtube_api_key': '',
      'gemini_api_key': ''
    };
    remoteConfig.settings.minimumFetchIntervalMillis = 3600000;

    window.getById = (id) => document.getElementById(id); 

    const DOM = {
        desktopIconsContainer: getById('desktopIconsContainer'),
        windowsContainer: getById('windowsContainer'),
        changeBgImageModal: getById(MODAL_IDS_OS.CHANGE_BG_IMAGE),
        newBgImageInput: getById('newBgImageInput'),
        uploadBgImageBtn: getById('uploadBgImageBtn'),
        bgImageUrlInput: getById('bgImageUrlInput'),
        applyBgImageUrlBtn: getById('applyBgImageUrlBtn'),
        bgColorSwatchesContainer: getById('bgColorSwatchesContainer'),
        modalCloseButtons: null 
    };
    
    window.appData = { 
        windowStates: {},
        iconPositions: {},
        customBgImage: null,
        customBgColor: null,
    };
    window.appRegistry = {}; 

    let lastNormalStates = {};
    let highestZIndex = 10;
    let activeDragWindow = null;
    let activeResizeWindow = null;
    let dragOffsetX, dragOffsetY;
    let resizeInitialX, resizeInitialY, resizeInitialWidth, resizeInitialHeight;
    let activeDragIcon = null;
    let iconDragOffsetX, iconDragOffsetY;

    const APPS_TO_LOAD = [
        'xp-tracker.app.html',
        'jotter.app.html',
        'play-jockey.app.html',
        'gemini-chat.app.html',
        'pixel-craft.app.html',
        'capture.app.html'
    ];

    async function loadApp(appFilename) {
        try {
            const response = await fetch(appFilename);
            if (!response.ok) {
                console.error(`Failed to load app ${appFilename}: ${response.statusText}`);
                return;
            }
            const appHtmlContent = await response.text();
            const parser = new DOMParser();
            const appDoc = parser.parseFromString(appHtmlContent, 'text/html');

            appDoc.querySelectorAll('style').forEach(styleTag => {
                document.head.appendChild(styleTag.cloneNode(true));
            });

            const iconTemplate = appDoc.querySelector('template[id$="IconTemplate"]');
            if (iconTemplate) {
                const iconNode = iconTemplate.content.firstElementChild.cloneNode(true);
                DOM.desktopIconsContainer.appendChild(iconNode);
                initDesktopIconBehavior(iconNode); 
            }

            const windowTemplate = appDoc.querySelector('template[id$="WindowTemplate"]');
            let appWindowId = null;
            if (windowTemplate) {
                const windowNode = windowTemplate.content.firstElementChild.cloneNode(true);
                DOM.windowsContainer.appendChild(windowNode);
                appWindowId = windowNode.id;
            }
            
            appDoc.querySelectorAll('template[id$="ModalsTemplate"]').forEach(modalsTemplate => {
                 const modalsFragment = modalsTemplate.content.cloneNode(true);
                 document.body.appendChild(modalsFragment);
            });
            
            DOM.modalCloseButtons = document.querySelectorAll('.modal .close-button, .modal .xp-button[data-modal-id]');
            DOM.modalCloseButtons.forEach(button => {
                button.removeEventListener('click', handleModalCloseClick); 
                button.addEventListener('click', handleModalCloseClick);
            });

            const scriptTag = appDoc.querySelector('script');
            if (scriptTag) {
                const script = document.createElement('script');
                script.textContent = scriptTag.textContent;
                document.body.appendChild(script); 
            }
            
            if (appWindowId && window.appRegistry[appWindowId]) {
                initWindowInteractions(appWindowId);
                restoreWindowState(appWindowId); 
                updateMinMaxButtonStates(appWindowId);
            } else if (appWindowId && !window.appRegistry[appWindowId]) {
                // This case might happen if app script hasn't registered yet,
                // but restoreWindowState called from initDesktopIconBehavior should have created a basic state.
                // The app's own setup (called by its script) will later populate appRegistry.
                // We still want to ensure basic window interactions and state restoration are attempted.
                initWindowInteractions(appWindowId);
                restoreWindowState(appWindowId); 
                updateMinMaxButtonStates(appWindowId);
            }


        } catch (error) {
            console.error(`Error loading app ${appFilename}:`, error);
        }
    }
    
    function handleModalCloseClick(event) {
        const modalId = event.target.dataset.modalId || event.target.closest('.modal')?.id;
        if (modalId) closeModal(modalId);
    }

    async function loadAllApps() {
        for (const appFilename of APPS_TO_LOAD) {
            await loadApp(appFilename);
        }
    }

    function applyCurrentBackgroundStyle() {
        if (appData.customBgColor) {
            document.body.style.backgroundImage = 'none';
            document.body.style.backgroundColor = appData.customBgColor;
        } else if (appData.customBgImage) {
            document.body.style.backgroundColor = '';
            document.body.style.backgroundImage = `url('${appData.customBgImage}')`;
        } else {
            document.body.style.backgroundColor = '#3A6EA5';
            document.body.style.backgroundImage = "url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png')";
        }
    }

    async function initOS() {
        loadData(); 
        applyCurrentBackgroundStyle();
        populateColorSwatches();
        
        await loadAllApps(); 

        addEventListenersOS();
        
        let maxLoadedWindowZ = highestZIndex; 
        Object.values(appData.windowStates).forEach(state => {
            if (state && state.zIndex) {
                maxLoadedWindowZ = Math.max(maxLoadedWindowZ, parseInt(state.zIndex));
            }
        });
        highestZIndex = maxLoadedWindowZ; 
    }

    function initDesktopIconBehavior(iconElement) { 
        const iconId = iconElement.id;
        const windowId = iconElement.dataset.windowId; 

        if (appData.iconPositions && appData.iconPositions[iconId]) {
            iconElement.style.left = appData.iconPositions[iconId].x + 'px';
            iconElement.style.top = appData.iconPositions[iconId].y + 'px';
        } else {
            const defaultX = parseInt(iconElement.style.left || "0");
            const defaultY = parseInt(iconElement.style.top || "0");
            const { x: finalX, y: finalY } = findNonCollidingPosition(iconElement, defaultX, defaultY);
            iconElement.style.left = finalX + 'px';
            iconElement.style.top = finalY + 'px';
            if (!appData.iconPositions) appData.iconPositions = {};
            appData.iconPositions[iconId] = { x: finalX, y: finalY };
        }
        iconElement.addEventListener('mousedown', handleIconMouseDown);
        iconElement.addEventListener('dblclick', handleIconDoubleClick);

        if (windowId) { // Ensure windowId is valid
            // Preemptively ensure a basic window state exists.
            // This will use generic defaults if appRegistry isn't populated yet for this windowId.
            if (!window.appData.windowStates[windowId]) {
                // console.log(`initDesktopIconBehavior: Preemptively calling restoreWindowState for ${windowId}`);
                restoreWindowState(windowId);
            }
        }
    }

    function handleIconMouseDown(e) {
        if (e.button !== 0 || activeDragWindow || activeResizeWindow) return;
        activeDragIcon = e.currentTarget;
        const windowId = activeDragIcon.dataset.windowId;
        const windowEl = getById(windowId);
        if(windowEl && windowEl.style.display !== 'none' && !windowEl.classList.contains('minimized')) {
             bringToFront(windowEl);
        }
        iconDragOffsetX = e.clientX - activeDragIcon.offsetLeft;
        iconDragOffsetY = e.clientY - activeDragIcon.offsetTop;
        activeDragIcon.style.cursor = 'grabbing';
        activeDragIcon.style.zIndex = (highestZIndex + 1).toString(); 
        document.addEventListener('mousemove', handleIconMouseMove);
        document.addEventListener('mouseup', handleIconMouseUp);
        e.preventDefault();
    }

    function handleIconMouseMove(e) {
        if (!activeDragIcon) return;
        let newX = e.clientX - iconDragOffsetX;
        let newY = e.clientY - iconDragOffsetY;
        const bodyRect = document.body.getBoundingClientRect();
        const iconWidth = activeDragIcon.offsetWidth || 90;
        const iconHeight = activeDragIcon.offsetHeight || 100;
        newX = Math.max(0, Math.min(newX, bodyRect.width - iconWidth));
        newY = Math.max(0, Math.min(newY, bodyRect.height - iconHeight));
        activeDragIcon.style.left = newX + 'px';
        activeDragIcon.style.top = newY + 'px';
    }

    function findNonCollidingPosition(draggedIcon, initialX, initialY) {
        let currentX = initialX;
        let currentY = initialY;
        let attempt = 0;
        const maxAttempts = 100;
        const iconWidth = draggedIcon.offsetWidth || 90;
        const iconHeight = draggedIcon.offsetHeight || 100;

        const checkCollisionAt = (x, y, currentDraggedIcon) => {
            const iconsToCompare = Array.from(DOM.desktopIconsContainer.querySelectorAll('.desktop-icon')).filter(
                icon => icon && icon !== currentDraggedIcon && icon.style.left && icon.style.top
            );
            for (const otherIcon of iconsToCompare) {
                const otherLeft = parseInt(otherIcon.style.left, 10);
                const otherTop = parseInt(otherIcon.style.top, 10);
                const otherWidth = otherIcon.offsetWidth || 90;
                const otherHeight = otherIcon.offsetHeight || 100;
                if (x < otherLeft + otherWidth &&
                    x + iconWidth > otherLeft &&
                    y < otherTop + otherHeight &&
                    y + iconHeight > otherTop) {
                    return true;
                }
            }
            return false;
        };

        let snappedX = Math.round(initialX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        let snappedY = Math.round(initialY / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        snappedX = Math.max(0, Math.min(snappedX, document.body.clientWidth - iconWidth));
        snappedY = Math.max(0, Math.min(snappedY, document.body.clientHeight - iconHeight));

        if (!checkCollisionAt(snappedX, snappedY, draggedIcon)) {
            return { x: snappedX, y: snappedY };
        }

        let layer = 1;
        while (attempt < maxAttempts) {
            const positionsToTry = [];
            for (let i = -layer; i <= layer; i++) {
                positionsToTry.push({ x: snappedX + i * ICON_GRID_SIZE, y: snappedY - layer * ICON_GRID_SIZE });
                if (layer !== 0) positionsToTry.push({ x: snappedX + i * ICON_GRID_SIZE, y: snappedY + layer * ICON_GRID_SIZE });
            }
            for (let i = -layer + 1; i < layer; i++) {
                positionsToTry.push({ x: snappedX - layer * ICON_GRID_SIZE, y: snappedY + i * ICON_GRID_SIZE });
                if (layer !== 0) positionsToTry.push({ x: snappedX + layer * ICON_GRID_SIZE, y: snappedY + i * ICON_GRID_SIZE });
            }

            for (const pos of positionsToTry) {
                attempt++;
                if (attempt >= maxAttempts) break;
                let testX = pos.x;
                let testY = pos.y;
                testX = Math.max(0, Math.min(testX, document.body.clientWidth - iconWidth));
                testY = Math.max(0, Math.min(testY, document.body.clientHeight - iconHeight));
                testX = Math.round(testX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
                testY = Math.round(testY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

                if (!checkCollisionAt(testX, testY, draggedIcon)) {
                    return { x: testX, y: testY };
                }
            }
            if (attempt >= maxAttempts) break;
            layer++;
            if (layer * ICON_GRID_SIZE > Math.max(document.body.clientWidth, document.body.clientHeight) && attempt > 20) {
                 break;
            }
        }
        return { x: snappedX, y: snappedY };
    }

    function handleIconMouseUp() {
        if (!activeDragIcon) return;
        activeDragIcon.style.zIndex = '5'; 
        let finalX = activeDragIcon.offsetLeft;
        let finalY = activeDragIcon.offsetTop;

        let snappedX = Math.round(finalX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        let snappedY = Math.round(finalY / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        const iconWidth = activeDragIcon.offsetWidth || 90;
        const iconHeight = activeDragIcon.offsetHeight || 100;
        snappedX = Math.max(0, Math.min(snappedX, document.body.clientWidth - iconWidth));
        snappedY = Math.max(0, Math.min(snappedY, document.body.clientHeight - iconHeight));
        snappedX = Math.round(snappedX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        snappedY = Math.round(snappedY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

        const { x: finalSnappedX, y: finalSnappedY } = findNonCollidingPosition(activeDragIcon, snappedX, snappedY);

        activeDragIcon.style.left = finalSnappedX + 'px';
        activeDragIcon.style.top = finalSnappedY + 'px';

        const iconId = activeDragIcon.id;
        if (!appData.iconPositions) appData.iconPositions = {};
        appData.iconPositions[iconId] = { x: finalSnappedX, y: finalSnappedY };
        saveData();

        activeDragIcon.style.cursor = 'grab';
        activeDragIcon = null;
        document.removeEventListener('mousemove', handleIconMouseMove);
        document.removeEventListener('mouseup', handleIconMouseUp);
    }

    function handleIconDoubleClick(e) {
        const iconElement = e.currentTarget;
        const windowId = iconElement.dataset.windowId;
        const windowElement = getById(windowId);
        if (!windowElement) {
            console.error(`Window element ${windowId} not found on double click.`);
            return;
        }

        let state = window.appData.windowStates[windowId];
        if (!state) { 
            // This warning is expected if the state wasn't loaded or previously created.
            // The restoreWindowState below should handle creating it.
            console.warn(`No state for window ${windowId} on double click. Attempting to restore.`);
            restoreWindowState(windowId); 
            state = window.appData.windowStates[windowId]; 
            if(!state) { 
                // If it's still not there, then restoreWindowState has a fundamental issue or windowId is bad.
                console.error(`Still no state for window ${windowId} after attempt to restore. Check appRegistry and restoreWindowState logic.`);
                return;
            }
        }

        if (state.hiddenByUser || windowElement.style.display === 'none') {
            state.hiddenByUser = false;
            state.minimized = false; 
            windowElement.style.display = 'flex';
            windowElement.classList.remove('minimized');
            // Call restoreWindowState again to ensure dimensions/positions are correctly applied based on the now-existing state
            restoreWindowState(windowId); 
            const appOpenEvent = new CustomEvent('appopen', { detail: { windowId: windowId, fromHidden: true } });
            windowElement.dispatchEvent(appOpenEvent);

        } else if (state.minimized || windowElement.classList.contains('minimized')) {
            maximizeWindow(windowId); 
        }
        bringToFront(windowElement);
        saveWindowState(windowId); 
    }

    function populateColorSwatches() {
        STANDARD_COLORS.forEach(color => {
            const swatch = document.createElement('div');
            swatch.style.width = '30px';
            swatch.style.height = '30px';
            swatch.style.backgroundColor = color.value;
            swatch.style.border = '1px solid #7F7F7F';
            swatch.style.cursor = 'pointer';
            swatch.title = color.name;
            swatch.dataset.colorValue = color.value;
            swatch.classList.add('color-swatch-item');
            DOM.bgColorSwatchesContainer.appendChild(swatch);
        });
    }

    window.bringToFront = function(windowElement) { 
        if (!windowElement) return;
        highestZIndex++;
        windowElement.style.zIndex = highestZIndex;
        const windowId = windowElement.id;
        if (!appData.windowStates[windowId]) appData.windowStates[windowId] = {};
        appData.windowStates[windowId].zIndex = highestZIndex;
    }

    window.initWindowInteractions = function(windowId) { 
        const windowElement = getById(windowId);
        if (!windowElement) return;
        const titleBarElement = windowElement.querySelector('.title-bar');
        const resizeHandleElement = windowElement.querySelector('.resize-handle');

        if (!titleBarElement) return;

        windowElement.addEventListener('mousedown', (e) => {
             if (e.target.closest('.desktop-icon') || e.target.closest('.context-modal') || e.target.closest('.xp-menu-bar')) return;
            if (e.target === windowElement ||
                (titleBarElement.contains(e.target) && !e.target.closest('button')) ||
                (windowElement.querySelector('.window-body')?.contains(e.target) && !e.target.closest('button, input, select, textarea, .resize-handle, iframe, canvas'))) { 
                 bringToFront(windowElement);
            }
        }, true);

        titleBarElement.addEventListener('mousedown', (e) => {
            if (e.target.closest('button') || windowElement.classList.contains('true-maximized') || activeDragIcon) return;
            activeDragWindow = windowElement;
            dragOffsetX = e.clientX - activeDragWindow.offsetLeft;
            dragOffsetY = e.clientY - activeDragWindow.offsetTop;
            activeDragWindow.classList.add('disable-selection');
            const iframe = activeDragWindow.querySelector('iframe');
            if (iframe) iframe.style.pointerEvents = 'none';
            const canvasEl = activeDragWindow.querySelector('canvas'); 
            if (canvasEl) canvasEl.style.pointerEvents = 'none';

            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDragOrResize);
            bringToFront(windowElement);
            
            const closeAppMenusEvent = new CustomEvent('osdragstart', { detail: { windowId: windowId }});
            windowElement.dispatchEvent(closeAppMenusEvent);
        });

        if (resizeHandleElement) {
            resizeHandleElement.addEventListener('mousedown', (e) => {
                if (windowElement.classList.contains('true-maximized') || activeDragIcon) return;
                activeResizeWindow = windowElement;
                activeResizeWindow.classList.add('disable-selection');
                resizeInitialX = e.clientX;
                resizeInitialY = e.clientY;
                resizeInitialWidth = activeResizeWindow.offsetWidth;
                resizeInitialHeight = activeResizeWindow.offsetHeight;
                const iframe = activeResizeWindow.querySelector('iframe');
                if (iframe) iframe.style.pointerEvents = 'none';
                const canvasEl = activeResizeWindow.querySelector('canvas');
                if (canvasEl) canvasEl.style.pointerEvents = 'none';

                document.addEventListener('mousemove', doResize);
                document.addEventListener('mouseup', stopDragOrResize);
                bringToFront(windowElement);

                const closeAppMenusEvent = new CustomEvent('osresizestart', { detail: { windowId: windowId }});
                windowElement.dispatchEvent(closeAppMenusEvent);
            });
        }
    }

    function doDrag(e) {
        if (!activeDragWindow) return;
        let newLeft = e.clientX - dragOffsetX;
        let newTop = e.clientY - dragOffsetY;
        const windowWidth = activeDragWindow.offsetWidth;
        const windowHeight = activeDragWindow.offsetHeight;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        newLeft = Math.max(0, newLeft);
        newTop = Math.max(0, newTop);
        newLeft = Math.min(newLeft, viewportWidth - windowWidth);
        newTop = Math.min(newTop, viewportHeight - windowHeight);

        activeDragWindow.style.left = newLeft + 'px';
        activeDragWindow.style.top = newTop + 'px';
        if (appData.windowStates[activeDragWindow.id]) {
            appData.windowStates[activeDragWindow.id].userManuallySet = true;
        }
    }

    function doResize(e) {
        if (!activeResizeWindow) return;
        const windowId = activeResizeWindow.id;
        const minDim = getMinWindowDimensions(windowId);

        let newWidth = resizeInitialWidth + (e.clientX - resizeInitialX);
        let newHeight = resizeInitialHeight + (e.clientY - resizeInitialY);

        activeResizeWindow.style.width = Math.max(minDim.width, newWidth) + 'px';
        activeResizeWindow.style.height = Math.max(minDim.height, newHeight) + 'px';

        if (appData.windowStates[windowId]) {
            appData.windowStates[windowId].userManuallySet = true;
        }
        
        const appResizeEvent = new CustomEvent('appresize', { detail: { windowId: windowId }});
        activeResizeWindow.dispatchEvent(appResizeEvent);
    }
    
    window.getMinWindowDimensions = function(windowId) { 
        if (window.appRegistry && window.appRegistry[windowId]) {
            return {
                width: window.appRegistry[windowId].minWidth || 200,
                height: window.appRegistry[windowId].minHeight || 150
            };
        }
        return { width: 200, height: 150 }; 
    }

    function stopDragOrResize() {
        let windowToSaveState = null;
        let operatedWindow = null;

        if (activeDragWindow) {
            activeDragWindow.classList.remove('disable-selection');
            const iframe = activeDragWindow.querySelector('iframe');
            if (iframe) iframe.style.pointerEvents = 'auto';
            const canvasEl = activeDragWindow.querySelector('canvas');
            if (canvasEl) canvasEl.style.pointerEvents = 'auto';
            windowToSaveState = activeDragWindow.id;
            operatedWindow = activeDragWindow;
            activeDragWindow = null;
        }
        if (activeResizeWindow) {
            activeResizeWindow.classList.remove('disable-selection');
            const iframe = activeResizeWindow.querySelector('iframe');
            if (iframe) iframe.style.pointerEvents = 'auto';
            const canvasEl = activeResizeWindow.querySelector('canvas');
            if (canvasEl) canvasEl.style.pointerEvents = 'auto';
            windowToSaveState = activeResizeWindow.id;
            operatedWindow = activeResizeWindow;
            activeResizeWindow = null;
        }

        if (windowToSaveState) {
            saveWindowState(windowToSaveState);
        }
        document.removeEventListener('mousemove', doDrag);
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', stopDragOrResize);
    }

    window.setWindowDefaults = function(windowId, isBrowserResize = false) { 
        const appWindow = getById(windowId);
        if (!appWindow || appWindow.classList.contains('minimized')) return;

        if (appWindow.classList.contains('true-maximized') && !isBrowserResize) {
            appWindow.style.width = '100vw';
            appWindow.style.height = '100vh';
            appWindow.style.top = '0px';
            appWindow.style.left = '0px';
            return;
        }

        let state = appData.windowStates[windowId]; // Use 'let' as it might be reassigned
        if (!state) {
            restoreWindowState(windowId); 
            state = appData.windowStates[windowId]; // Re-fetch after potential creation
            if (!state) return; // If still no state, exit
        }

        const hasValidSavedSize = state.width && state.width > 0 && state.height && state.height > 0;
        const hasValidSavedPosition = state.x != null && state.y != null;

        const minDim = getMinWindowDimensions(windowId);
        let defaultWidth = (window.appRegistry[windowId]?.defaultWidth) || minDim.width * 1.5;
        let defaultHeight = (window.appRegistry[windowId]?.defaultHeight) || minDim.height * 1.5;
        defaultWidth = Math.max(minDim.width, defaultWidth);
        defaultHeight = Math.max(minDim.height, defaultHeight);

        let defaultOffsetX = (Object.keys(appData.windowStates).length % 5) * 30 + 50;
        let defaultOffsetY = (Object.keys(appData.windowStates).length % 5) * 30 + 50;

        if (isBrowserResize || !state.userManuallySet || !hasValidSavedSize || !hasValidSavedPosition) {
            let newWidth = state.userManuallySet && hasValidSavedSize ? state.width : defaultWidth;
            let newHeight = state.userManuallySet && hasValidSavedSize ? state.height : defaultHeight;
            let newLeft = state.userManuallySet && hasValidSavedPosition ? state.x : defaultOffsetX;
            let newTop = state.userManuallySet && hasValidSavedPosition ? state.y : defaultOffsetY;

            if (newLeft + newWidth > window.innerWidth) newLeft = Math.max(10, window.innerWidth - newWidth - 10);
            if (newTop + newHeight > window.innerHeight) newTop = Math.max(10, window.innerHeight - newHeight - 10);
            if (newWidth > window.innerWidth - 20) newWidth = Math.max(minDim.width, window.innerWidth - 20);
            if (newHeight > window.innerHeight - 20) newHeight = Math.max(minDim.height, window.innerHeight - 20);
            newLeft = Math.max(10, newLeft); 
            newTop = Math.max(10, newTop);   

            appWindow.style.width = newWidth + 'px';
            appWindow.style.height = newHeight + 'px';
            appWindow.style.left = newLeft + 'px';
            appWindow.style.top = newTop + 'px';

            state.width = newWidth;
            state.height = newHeight;
            state.x = newLeft;
            state.y = newTop;
            if (!isBrowserResize) { 
                state.userManuallySet = false;
            }
        }
        const appResizeEvent = new CustomEvent('appresize', { detail: { windowId: windowId }});
        appWindow.dispatchEvent(appResizeEvent);
    }

    function addEventListenersOS() { 
        document.body.addEventListener('contextmenu', function(event) {
            if (event.target === document.body || event.target === DOM.desktopIconsContainer) {
                event.preventDefault();
                DOM.newBgImageInput.value = null;
                DOM.bgImageUrlInput.value = '';
                openModal(MODAL_IDS_OS.CHANGE_BG_IMAGE);
            }
        });

        DOM.uploadBgImageBtn.addEventListener('click', function() {
            const file = DOM.newBgImageInput.files[0];
            if (file) {
                if (file.size > 5 * 1024 * 1024) { 
                    alert("Image file is large (over 5MB). This might exceed browser storage limits when saved. Try a smaller file or use the URL option for large images.");
                }
                const reader = new FileReader();
                reader.onloadend = function() {
                    document.body.style.backgroundColor = '';
                    document.body.style.backgroundImage = `url('${reader.result}')`;
                    appData.customBgImage = reader.result;
                    appData.customBgColor = null;
                    saveData();
                    closeModal(MODAL_IDS_OS.CHANGE_BG_IMAGE);
                }
                reader.onerror = function() {
                    alert("Error reading image file.");
                }
                reader.readAsDataURL(file);
            } else {
                alert("Please select an image file first.");
            }
        });

        DOM.applyBgImageUrlBtn.addEventListener('click', function() {
            const imageUrl = DOM.bgImageUrlInput.value.trim();
            if (imageUrl) {
                try {
                    new URL(imageUrl); 
                    document.body.style.backgroundColor = '';
                    document.body.style.backgroundImage = `url('${imageUrl}')`;
                    appData.customBgImage = imageUrl;
                    appData.customBgColor = null;
                    saveData();
                    closeModal(MODAL_IDS_OS.CHANGE_BG_IMAGE);
                } catch (e) {
                    alert("Invalid image URL provided. Please enter a complete and valid URL (e.g., https://example.com/image.png).");
                }
            } else {
                alert("Please enter an image URL.");
            }
        });

        DOM.bgColorSwatchesContainer.addEventListener('click', function(event) {
            if (event.target.classList.contains('color-swatch-item')) {
                const selectedColor = event.target.dataset.colorValue;
                if (selectedColor) {
                    document.body.style.backgroundImage = 'none';
                    document.body.style.backgroundColor = selectedColor;
                    appData.customBgColor = selectedColor;
                    appData.customBgImage = null;
                    saveData();
                    closeModal(MODAL_IDS_OS.CHANGE_BG_IMAGE);
                }
            }
        });
        
        DOM.modalCloseButtons = document.querySelectorAll('.modal .close-button, .modal .xp-button[data-modal-id]');
        DOM.modalCloseButtons.forEach(button => {
             button.addEventListener('click', handleModalCloseClick);
        });

        window.addEventListener('resize', () => {
            Object.keys(appData.windowStates).forEach(windowId => {
                 const windowEl = getById(windowId);
                 if (windowEl && windowEl.style.display !== 'none') { 
                    setWindowDefaults(windowId, true);
                 }
            });
            saveData();
        });

        document.addEventListener('click', (e) => {
            // Generic click outside to close OS-level menus if any are added later
        });
    }

    window.minimizeWindow = function(windowId) { 
        const appWindow = getById(windowId);
        if (!appWindow || appWindow.classList.contains('minimized')) return;
        const state = appData.windowStates[windowId];
        if (!state) return;

        state.minimized = true;
        if (appWindow.classList.contains('true-maximized')) {
            state.wasMaximizedBeforeMinimize = true;
            if (lastNormalStates[windowId]) {
                state.width = parseInt(lastNormalStates[windowId].width);
                state.height = parseInt(lastNormalStates[windowId].height);
                state.x = parseInt(lastNormalStates[windowId].left);
                state.y = parseInt(lastNormalStates[windowId].top);
            }
        } else {
            state.wasMaximizedBeforeMinimize = false;
            state.width = appWindow.offsetWidth;
            state.height = appWindow.offsetHeight;
            state.x = appWindow.offsetLeft;
            state.y = appWindow.offsetTop;
        }
        appWindow.classList.remove('true-maximized');
        appWindow.classList.add('minimized');
        
        const appMinimizeEvent = new CustomEvent('appminimize', { detail: { windowId: windowId }});
        appWindow.dispatchEvent(appMinimizeEvent);

        updateMinMaxButtonStates(windowId);
        saveWindowState(windowId);
    }

    window.maximizeWindow = function(windowId) { 
        const appWindow = getById(windowId);
        if (!appWindow) return;
        let state = appData.windowStates[windowId];
        if (!state) { 
            restoreWindowState(windowId);
            state = appData.windowStates[windowId];
            if (!state) return;
        }

        const isMinimized = appWindow.classList.contains('minimized');
        let currentLastNormal = lastNormalStates[windowId] || {};
        const minDim = getMinWindowDimensions(windowId);

        if (isMinimized) {
            appWindow.classList.remove('minimized');
            state.minimized = false;
            const wasMaximized = state.wasMaximizedBeforeMinimize;
            delete state.wasMaximizedBeforeMinimize;

            if (wasMaximized) {
                appWindow.style.width = '100vw';
                appWindow.style.height = '100vh';
                appWindow.style.top = '0px';
                appWindow.style.left = '0px';
                appWindow.classList.add('true-maximized');
                state.maximized = true;
            } else {
                appWindow.style.width = Math.max(minDim.width, state.width || parseInt(currentLastNormal.width) || minDim.width * 1.5) + 'px';
                appWindow.style.height = Math.max(minDim.height, state.height || parseInt(currentLastNormal.height) || minDim.height * 1.5) + 'px';
                appWindow.style.left = (state.x != null ? state.x : (parseInt(currentLastNormal.left) || 50)) + 'px';
                appWindow.style.top = (state.y != null ? state.y : (parseInt(currentLastNormal.top) || 50)) + 'px';
                state.maximized = false;
            }
             const appRestoreEvent = new CustomEvent('apprestore', { detail: { windowId: windowId, fromMinimized: true } });
             appWindow.dispatchEvent(appRestoreEvent);

        } else if (appWindow.classList.contains('true-maximized')) { 
            if (currentLastNormal.width && currentLastNormal.height) {
                appWindow.style.width = currentLastNormal.width;
                appWindow.style.height = currentLastNormal.height;
                appWindow.style.top = currentLastNormal.top;
                appWindow.style.left = currentLastNormal.left;
                state.width = parseInt(currentLastNormal.width);
                state.height = parseInt(currentLastNormal.height);
                state.x = parseInt(currentLastNormal.left);
                state.y = parseInt(currentLastNormal.top);
            } else {
                const defaultWidth = Math.max(minDim.width, state.width || minDim.width * 1.5);
                const defaultHeight = Math.max(minDim.height, state.height || minDim.height * 1.5);
                appWindow.style.width = defaultWidth + 'px';
                appWindow.style.height = defaultHeight + 'px';
                appWindow.style.left = (state.x != null ? state.x : 50) + 'px';
                appWindow.style.top = (state.y != null ? state.y : 50) + 'px';
                state.width = defaultWidth; state.height = defaultHeight;
                state.x = (state.x != null ? state.x : 50); state.y = (state.y != null ? state.y : 50);
            }
            appWindow.classList.remove('true-maximized');
            state.maximized = false;
            state.userManuallySet = true;
        } else { 
            lastNormalStates[windowId] = {
                width: appWindow.style.width || (appWindow.offsetWidth + 'px'),
                height: appWindow.style.height || (appWindow.offsetHeight + 'px'),
                top: appWindow.style.top || (appWindow.offsetTop + 'px'),
                left: appWindow.style.left || (appWindow.offsetLeft + 'px')
            };
            appWindow.style.width = '100vw';
            appWindow.style.height = '100vh';
            appWindow.style.top = '0px';
            appWindow.style.left = '0px';
            appWindow.classList.add('true-maximized');
            state.maximized = true;
            state.userManuallySet = false; 
        }
        updateMinMaxButtonStates(windowId);
        saveWindowState(windowId);
        
        const appResizeEvent = new CustomEvent('appresize', { detail: { windowId: windowId }});
        appWindow.dispatchEvent(appResizeEvent);
    }

    window.updateMinMaxButtonStates = function(windowId) { 
        const win = getById(windowId);
        if (!win) return;
        const minimizeBtn = win.querySelector('.title-bar-controls button[title="Minimize"]');
        const maximizeBtn = win.querySelector('.title-bar-controls button[title*="Maximize"], .title-bar-controls button[title*="Restore"]'); 
        
        if (!minimizeBtn || !maximizeBtn) return;

        const isMinimized = win.classList.contains('minimized');
        const isTrueMaximized = win.classList.contains('true-maximized');

        minimizeBtn.disabled = isMinimized;
        maximizeBtn.disabled = false; 

        if (isMinimized) {
            maximizeBtn.innerHTML = '1'; 
            maximizeBtn.title = "Restore";
        } else if (isTrueMaximized) {
            maximizeBtn.innerHTML = '2'; 
            maximizeBtn.title = "Restore Down";
        } else {
            maximizeBtn.innerHTML = '1'; 
            maximizeBtn.title = "Maximize";
        }
    }

    window.saveWindowState = function(windowId) { 
        const win = getById(windowId);
        if (!win) return;
        let state = appData.windowStates[windowId];
        if (!state) {
            appData.windowStates[windowId] = {}; 
            state = appData.windowStates[windowId];
        }
        state.hiddenByUser = (win.style.display === 'none'); 
        state.minimized = win.classList.contains('minimized');
        state.maximized = win.classList.contains('true-maximized');
        state.zIndex = parseInt(win.style.zIndex) || highestZIndex;

        if (!state.minimized && !state.maximized) {
            state.x = win.offsetLeft;
            state.y = win.offsetTop;
            state.width = win.offsetWidth;
            state.height = win.offsetHeight;
        }
        saveData();
    }

    window.restoreWindowState = function(windowId) {
        const win = getById(windowId);
        // if (!win) return; // Allow state creation even if window element isn't there yet

        // Ensure appData.windowStates itself is an object
        if (typeof window.appData.windowStates !== 'object' || window.appData.windowStates === null) {
            window.appData.windowStates = {};
        }
        let existingState = window.appData.windowStates[windowId];

        let minDimWidth = 200; let minDimHeight = 150;
        if (window.appRegistry && window.appRegistry[windowId]) {
            minDimWidth = window.appRegistry[windowId].minWidth || minDimWidth;
            minDimHeight = window.appRegistry[windowId].minHeight || minDimHeight;
        }
        
        const defaultAppWidth = (window.appRegistry[windowId]?.defaultWidth) || minDimWidth * 1.5;
        const defaultAppHeight = (window.appRegistry[windowId]?.defaultHeight) || minDimHeight * 1.5;
        // More robust default positioning: try to avoid overlap if possible, or cascade
        const numWindows = Object.keys(window.appData.windowStates).length;
        const defaultX = (numWindows % 10) * 30 + 50; // Cascade offset
        const defaultY = (numWindows % 10) * 30 + 50;

        const defaultStateTemplate = {
            x: defaultX, y: defaultY, 
            width: defaultAppWidth, height: defaultAppHeight,
            maximized: false, minimized: false, 
            zIndex: highestZIndex + 1, 
            userManuallySet: false,
            hiddenByUser: true // Default to hidden, app opening will make it visible
        };

        if (!existingState) {
            window.appData.windowStates[windowId] = { ...defaultStateTemplate };
        } else {
            // Merge existing state with defaults to ensure all properties are present
            window.appData.windowStates[windowId] = {
                ...defaultStateTemplate, // Base defaults
                ...existingState,        // Loaded/current state overrides defaults
                // Ensure specific properties from loaded state are correctly typed or fall back
                zIndex: parseInt(existingState.zIndex) || defaultStateTemplate.zIndex,
                hiddenByUser: typeof existingState.hiddenByUser === 'boolean' ? existingState.hiddenByUser : defaultStateTemplate.hiddenByUser,
                minimized: typeof existingState.minimized === 'boolean' ? existingState.minimized : defaultStateTemplate.minimized,
                maximized: typeof existingState.maximized === 'boolean' ? existingState.maximized : defaultStateTemplate.maximized,
                userManuallySet: typeof existingState.userManuallySet === 'boolean' ? existingState.userManuallySet : defaultStateTemplate.userManuallySet,
                width: existingState.width > 0 ? existingState.width : defaultStateTemplate.width,
                height: existingState.height > 0 ? existingState.height : defaultStateTemplate.height,
                x: existingState.x != null ? existingState.x : defaultStateTemplate.x,
                y: existingState.y != null ? existingState.y : defaultStateTemplate.y,
            };
        }
        
        const finalState = window.appData.windowStates[windowId]; // This is now guaranteed to be a complete object.

        if (win) { // Apply to DOM element if it exists
            if (finalState.hiddenByUser) {
                 win.style.display = 'none';
            } else {
                win.style.display = 'flex';
            }

            let loadedZ = parseInt(finalState.zIndex);
            if (isNaN(loadedZ) || loadedZ <= 5) loadedZ = highestZIndex + 1; 
            win.style.zIndex = loadedZ;
            highestZIndex = Math.max(highestZIndex, loadedZ);

            if (finalState.minimized) {
                win.classList.add('minimized');
                win.classList.remove('true-maximized');
            } else if (finalState.maximized) {
                win.classList.add('true-maximized');
                win.classList.remove('minimized');
                win.style.width = '100vw';
                win.style.height = '100vh';
                win.style.top = '0px';
                win.style.left = '0px';
                if (!lastNormalStates[windowId] || !lastNormalStates[windowId].width) {
                     lastNormalStates[windowId] = {
                        width: (finalState.width && finalState.width !== window.innerWidth ? finalState.width : defaultAppWidth) + 'px',
                        height: (finalState.height && finalState.height !== window.innerHeight ? finalState.height : defaultAppHeight) + 'px',
                        top: (finalState.y != null ? finalState.y : defaultY) + 'px',
                        left: (finalState.x != null ? finalState.x : defaultX) + 'px'
                    };
                }
            } else { 
                win.classList.remove('minimized');
                win.classList.remove('true-maximized');
                win.style.left = finalState.x + 'px';
                win.style.top = finalState.y + 'px';
                win.style.width = Math.max(minDimWidth, finalState.width) + 'px';
                win.style.height = Math.max(minDimHeight, finalState.height) + 'px';
            }
            updateMinMaxButtonStates(windowId); 
            
            if (!finalState.hiddenByUser) { 
                const appResizeEvent = new CustomEvent('appresize', { detail: { windowId: windowId }});
                win.dispatchEvent(appResizeEvent);
            }
        }
    };

    window.saveData = function() { 
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(appData));
        } catch (error) {
            if (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                alert("Could not save data: Storage limit exceeded. This might be due to a very large background image from file upload. Try a smaller file or use the URL option for large images.");
            }
        }
    }

    function loadData() { 
        const storedData = localStorage.getItem(STORAGE_KEY);
        const defaultOSData = { 
            windowStates: {},
            iconPositions: {},
            customBgImage: null,
            customBgColor: null,
        };

        window.appData = { 
            ...defaultOSData,
            ...(window.appData || {}) 
        };

        if (storedData) {
            try {
                const parsedStoredData = JSON.parse(storedData);
                window.appData.windowStates = { ...defaultOSData.windowStates, ...(parsedStoredData.windowStates || {}) };
                window.appData.iconPositions = { ...defaultOSData.iconPositions, ...(parsedStoredData.iconPositions || {}) };
                window.appData.customBgImage = parsedStoredData.customBgImage || defaultOSData.customBgImage;
                window.appData.customBgColor = parsedStoredData.customBgColor || defaultOSData.customBgColor;
                
                for (const key in parsedStoredData) {
                    if (parsedStoredData.hasOwnProperty(key) && !(key in defaultOSData)) {
                        if (window.appData[key] && typeof window.appData[key] === 'object' && typeof parsedStoredData[key] === 'object' && !Array.isArray(window.appData[key]) && !Array.isArray(parsedStoredData[key])) {
                           window.appData[key] = { ...window.appData[key], ...parsedStoredData[key] }; 
                        } else {
                            window.appData[key] = parsedStoredData[key]; 
                        }
                    }
                }
            } catch (error) {
                console.error("Error parsing stored OS data. Reverting OS parts to defaults.", error);
                window.appData.windowStates = { ...defaultOSData.windowStates };
                window.appData.iconPositions = { ...defaultOSData.iconPositions };
                window.appData.customBgImage = defaultOSData.customBgImage;
                window.appData.customBgColor = defaultOSData.customBgColor;
            }
        } 
    }
    
    window.openModal = function(modalId) { 
        const modal = getById(modalId);
        if (modal) modal.style.display = 'flex';
    }

    window.closeModal = function(modalId) { 
        const modal = getById(modalId);
         if (modal) modal.style.display = 'none';
    }

    async function fetchFirebaseConfigAndInitOS() {
        try {
            await remoteConfig.fetchAndActivate();
            window.YOUTUBE_API_KEY = remoteConfig.getString('youtube_api_key');
            window.GEMINI_API_KEY = remoteConfig.getString('gemini_api_key');
        } catch (err) {
            // Keep default empty keys
        } finally {
            initOS();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetchFirebaseConfigAndInitOS();
    });
</script>
</body>
</html>