<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life XP</title>
    <style>
        body {
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #3A6EA5;
            background-image: url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png');
            background-size: cover;
            background-position: 0% 0%;
            background-repeat: no-repeat;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden; 
        }

        .xp-window {
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            min-height: 30px;
            display: flex;
            flex-direction: column;
            position: absolute;
            overflow: hidden;
        }

        .xp-window.disable-selection,
        .xp-window.disable-selection * {
            user-select: none;
            -webkit-user-select: none; 
            -moz-user-select: none;    
            -ms-user-select: none;     
        }

        .title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #000;
            cursor: grab;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
            user-select: none;
        }
        .title-bar:active {
            cursor: grabbing;
        }

        .title-bar-text {
            margin-left: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .title-bar-controls button {
            background-color: #ECE9D8;
            border: 1px solid #000;
            width: 22px;
            height: 18px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-size: 12px;
            line-height: 16px;
            margin-left: 2px;
            box-shadow: 1px 1px 0px #FFF inset, -1px -1px 0px #808080 inset;
            padding: 0;
            text-align: center;
            cursor: default;
        }
        .title-bar-controls button:active:not(:disabled) {
            box-shadow: -1px -1px 0px #FFF inset, 1px 1px 0px #808080 inset;
        }
        .title-bar-controls button:disabled {
            color: #7F7F7F;
            cursor: default;
            opacity: 0.7;
        }

        .window-body {
            padding: 15px; 
            flex-grow: 1;
            overflow-y: auto;
            opacity: 1;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.2s ease-out;
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden; 
        }
        
        #xpMainWindow .window-body {
             padding: 15px;
             overflow-y: auto;
        }
        
        #playJockeyWindow .window-body {
            padding: 0; 
            display: flex; 
        }


        .xp-window.minimized .window-body {
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            opacity: 0 !important;
            overflow: hidden !important;
            border-top: none !important;
        }
        .xp-window.minimized {
            min-height: 28px !important; 
            height: 28px !important;
            overflow: hidden;
        }

        .controls-bar {
            display: flex;
            margin-bottom: 15px;
            padding: 8px;
            border: 1px solid #ACA899;
            background-color: #F0F0F0;
        }

        .controls-bar.layout-single-row {
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
        }
        .controls-bar.layout-single-row > div {
             margin: 2px 5px;
             flex-shrink: 0;
        }

        .controls-bar.layout-multi-row {
            flex-direction: column;
            align-items: stretch;
        }
        .controls-bar.layout-multi-row > div {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            padding: 5px 0;
        }
        .controls-bar.layout-multi-row > div:last-child {
            margin-bottom: 0;
        }
        .controls-bar.layout-multi-row .controls-group {
             text-align: center;
        }

        .xp-button {
            background-color: #ECE9D8;
            border: 1px outset #7F7F7F;
            padding: 5px 12px;
            min-width: 75px;
            text-align: center;
            cursor: pointer;
            margin: 2px;
        }
        .xp-button:active {
            border-style: inset;
        }
        .xp-button:hover {
            border-color: #005CFE;
        }
        .xp-button-small { 
            padding: 2px 5px;
            font-size: 10px;
            min-width: auto;
            margin: 0 2px;
        }


        .week-navigation {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .week-navigation button {
            margin: 0 3px;
        }

        .controls-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0 10px;
            text-align: center;
        }
        #currentWeekDisplay {
            font-weight: bold;
        }
        #weekCountDisplay {
            font-size: 0.9em;
            color: #333;
        }

        .global-actions {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            table-layout: fixed;
        }

        th, td {
            border: 1px solid #ACA899;
            padding: 8px;
            text-align: left;
            vertical-align: top;
            word-wrap: break-word;
        }

        th {
            background-color: #D4D0C8;
            text-align: center;
        }

        td.area-name-cell {
            font-weight: bold;
            width: 180px;
        }
        .area-stats {
            font-size: 0.9em;
            margin-top: 5px;
            color: #333;
        }
        .area-stats span { display: flex; }
        .xp-bar-container {
            width: 100%;
            height: 12px;
            background-color: #BDBDBD;
            border: 1px solid #7F7F7F;
            margin-top: 3px;
            position: relative;
            border-radius: 2px;
            overflow: hidden;
        }
        .xp-bar {
            height: 100%;
            background-color: #008000;
            transition: width 0.3s ease;
            border-radius: 1px;
        }
        .xp-bar-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            line-height: 12px;
            color: white;
            text-shadow: 1px 1px 0px black;
            font-weight: bold;
            z-index: 1;
        }

        .achievement-item {
            background-color: #FFF;
            border: 1px solid #DDD;
            padding: 4px;
            margin-bottom: 4px;
            font-size: 0.9em;
            border-radius: 3px;
            word-wrap: break-word;
            box-sizing: border-box;
            position: relative; 
            padding-bottom: 22px; 
        }
        .achievement-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin-top: 0px;
            border-radius: 2px;
        }
        .achievement-item-actions {
            position: absolute;
            bottom: 3px;
            right: 3px;
            display: flex;
            gap: 3px;
        }
        .achievement-add-btn-cell { 
            display: block;
            width: 99.5%;
            box-sizing: border-box;
            margin-top: 5px;
        }


        .modal {
            display: none;
            position: fixed;
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #ECE9D8;
            margin: auto;
            padding: 0;
            border: 1px solid #000;
            width: 80%;
            max-width: 500px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
            display: flex;
            flex-direction: column;
        }

        .modal-title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            border-bottom: 1px solid #000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .modal-title-bar .close-button {
            color: white;
            font-size: 16px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-weight: normal;
            background: #E04343;
            border: 1px outset white;
            width: 22px;
            height: 18px;
            text-align: center;
            line-height: 16px;
            padding: 0;
            cursor: pointer;
        }
        .modal-title-bar .close-button:hover,
        .modal-title-bar .close-button:focus {
            background: #FF6363;
            text-decoration: none;
        }
         .modal-title-bar .close-button:active {
            border-style: inset;
        }
        .modal-body {
            padding: 15px;
            overflow-y: auto;
            flex-grow: 1;
        }
        .modal-body p {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .modal-body label {
            display: block;
            margin-bottom: 5px;
            margin-top: 12px; 
        }
        .modal-body input[type="text"],
        .modal-body input[type="number"],
        .modal-body textarea,
        .modal-body select {
            width: calc(100% - 12px);
            padding: 5px;
            margin-bottom: 10px;
            border: 1px solid #ACA899;
            box-sizing: border-box;
        }
        .modal-body input[type="file"] {
            margin-bottom: 5px;
        }
         .modal-body hr {
            border: 0;
            height: 1px;
            background: #ACA899;
            margin: 20px 0;
        }
        .modal-footer {
            padding: 10px 15px;
            text-align: right;
            background-color: #F0F0F0;
            border-top: 1px solid #ACA899;
            flex-shrink: 0;
        }

        @keyframes fadeIn {
            from {opacity: 0; transform: scale(0.9);}
            to {opacity: 1; transform: scale(1);}
        }

        .quest-item {
            padding: 8px;
            border: 1px solid #ACA899;
            margin-bottom: 8px;
            background-color: #FFF;
            border-radius: 3px;
            position: relative;
        }
        .quest-item label {
            margin-left: 8px;
        }
        .quest-item.completed {
            background-color: #DFF0D8;
            text-decoration: line-through;
            color: #508a50;
        }
        .quest-item.completed .quest-title {
             color: #006400;
        }
        .quest-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #0039A9;
        }
        .quest-details {
            font-size: 0.95em;
            margin-bottom: 3px;
        }
        .quest-progress {
            font-size: 0.85em;
            color: #555;
            margin-top: 3px;
            margin-bottom: 25px;
        }
        .quest-actions {
            position: absolute;
            bottom: 5px;
            right: 5px;
        }


        .area-name-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .delete-area-btn {
            padding: 1px 6px;
            min-width: auto;
            font-size: 10px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-weight: bold;
            margin-left: 10px;
            background-color: #E04343;
            color: white;
            border: 1px outset white;
            line-height: 1.2;
            cursor: pointer;
        }
        .delete-area-btn:hover {
            background-color: #FF6363;
        }
        .delete-area-btn:active {
            border-style: inset;
        }

        .resize-handle {
            width: 12px;
            height: 12px;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            z-index: 10; 
            box-sizing: border-box;
            opacity: 0.6;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center center;
        }

        .resize-handle:hover {
            opacity: 1;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
        }

        .xp-window.true-maximized .resize-handle {
            display: none;
        }

        .color-swatch-item {
            box-sizing: border-box;
            transition: transform 0.1s ease-out;
        }
        .color-swatch-item:hover {
            outline: 2px solid #005CFE;
            outline-offset: 1px;
            transform: scale(1.1);
        }

        .desktop-icon {
            position: absolute;
            width: 90px; 
            height: 100px; 
            text-align: center;
            color: white;
            text-shadow: 1px 1px 1px black;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; 
            padding-top: 10px; 
            box-sizing: border-box;
            z-index: 5; 
        }
        .desktop-icon:active {
            cursor: grabbing;
        }
        .desktop-icon .icon-image {
            font-size: 48px; 
            line-height: 1;
            margin-bottom: 8px; 
        }
        .desktop-icon .icon-label {
            font-size: 12px; 
            font-weight: normal; 
            word-wrap: break-word; 
            max-width: 100%;
        }

        /* PlayJockey Specific Styles */
        .playjockey-body-container {
            display: flex;
            flex-direction: column;
            width: 100%; 
            height: 100%; 
            background-color: #D4D0C8; 
            padding: 5px;
            box-sizing: border-box;
        }

        .playjockey-input-bar {
            display: flex;
            margin-bottom: 5px;
            padding: 5px;
            background-color: #C0C0C0; 
            border: 1px outset #FFFFFF;
            border-right-color: #808080;
            border-bottom-color: #808080;
            flex-shrink: 0; 
        }

        #playJockeyLinkInput {
            flex-grow: 1;
            margin-right: 5px;
            border: 1px inset #7F7F7F;
            padding: 4px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #FFFFFF;
        }

        #playJockeyAddBtn { 
            min-width: 60px;
            padding: 3px 8px;
            font-size: 11px;
        }

        .playjockey-player-area {
            flex-grow: 1;
            margin-bottom: 5px; 
            border: 2px inset #808080;
            background-color: black; 
            min-height: 150px; 
            overflow: hidden; 
        }

        #playJockeyPlayer { 
            width: 100%;
            height: 100%;
        }

        .playjockey-controls-bar {
            display: flex;
            justify-content: center; 
            padding: 0px 0px 5px 0px;   
            flex-shrink: 0;
            gap: 5px; 
        }
        #playJockeyRandomBtn,
        #playJockeyAutoPlayBtn,
        #playJockeyRepeatBtn {
            min-width: 90px; 
            padding: 3px 8px;
            font-size: 11px;
        }
        #playJockeyRandomBtn.random-on, 
        #playJockeyAutoPlayBtn.autoplay-on,
        #playJockeyRepeatBtn.repeat-on { 
            border-style: inset; 
            font-weight: bold; 
        }
        

        .playjockey-playlist-area {
            height: 120px; 
            overflow-y: auto;
            border: 1px inset #7F7F7F;
            background-color: #FFFFFF;
            padding: 3px;
            flex-shrink: 0; 
        }

        .playjockey-playlist-item {
            padding: 4px 6px;
            cursor: grab; 
            border-bottom: 1px solid #ECE9D8;
            font-size: 10px;
            color: #000080; 
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            user-select: none; 
        }
        .playjockey-playlist-item:hover {
            background-color: #000080; 
            color: white;
        }
        .playjockey-playlist-item.playing {
            background-color: #005CFE; 
            color: white;
            font-weight: bold;
        }
        .playjockey-playlist-item:last-child {
            border-bottom: none;
        }
        
        .playjockey-playlist-item.dragging {
            opacity: 0.5;
            background-color: #AED6F1; 
        }
        .playjockey-playlist-item.drag-over-target-before {
            border-top: 2px dashed #005CFE;
        }
        .playjockey-playlist-item.drag-over-target-after {
            border-bottom: 2px dashed #005CFE;
        }


        .context-modal {
            display: none;
            position: fixed;
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            z-index: 2000; 
            padding: 3px 0;
            min-width: 120px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
        }
        .context-modal-item {
            padding: 5px 12px;
            cursor: default;
            color: black;
        }
        .context-modal-item:hover {
            background-color: #005CFE;
            color: white;
        }

    </style>
</head>
<body>

    <div class="desktop-icon" id="textEditorIcon" data-window-id="textEditorWindow">
        <div class="icon-image">📄</div>
        <div class="icon-label">Jotter</div>
    </div>
    <div class="desktop-icon" id="trackerIcon" data-window-id="xpMainWindow">
        <div class="icon-image">📅</div>
        <div class="icon-label">Habit Tracker</div>
    </div>
    <div class="desktop-icon" id="playJockeyIcon" data-window-id="playJockeyWindow">
        <div class="icon-image">▶️</div>
        <div class="icon-label">PlayJockey</div>
    </div>

    <div class="xp-window" id="xpMainWindow">
        <div class="title-bar" id="xpMainWindowTitleBar">
            <span class="title-bar-text">Habit Tracker</span>
            <div class="title-bar-controls">
                <button id="xpMainWindowMinimizeBtn" title="Minimize">0</button>
                <button id="xpMainWindowMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="xpMainWindowCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body">
            <div class="controls-bar" id="controlsBar">
                <div class="week-navigation">
                    <button id="prevWeekBtn" class="xp-button">< Prev Week</button>
                    <button id="thisWeekBtn" class="xp-button">This Week</button>
                    <button id="nextWeekBtn" class="xp-button">Next Week ></button>
                </div>
                <div class="controls-group">
                    <span id="currentWeekDisplay">Week X</span>
                    <span id="weekCountDisplay">Year Week: XX</span>
                </div>
                <div class="global-actions">
                    <button id="toggleViewBtn" class="xp-button">Day View</button>
                    <button id="showQuestsBtn" class="xp-button">Weekly Quests</button>
                    <button id="addAreaBtn" class="xp-button">New Area</button>
                </div>
            </div>
            <table id="gridTable">
                <thead>
                    <tr id="weekdayHeaders">
                        <th>Area</th>
                    </tr>
                </thead>
                <tbody id="gridBody">
                </tbody>
            </table>
        </div>
        <div class="resize-handle" id="xpMainWindowResizeHandle"></div>
    </div>

    <div class="xp-window" id="textEditorWindow">
        <div class="title-bar" id="textEditorWindowTitleBar">
            <span class="title-bar-text">Jotter</span>
            <div class="title-bar-controls">
                <button id="textEditorMinimizeBtn" title="Minimize">0</button>
                <button id="textEditorMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="textEditorCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="textEditorWindowBody">
            <iframe id="textEditorFrame" style="width: 100%; height: 100%; border: none;"></iframe>
        </div>
        <div class="resize-handle" id="textEditorResizeHandle"></div>
    </div>

    <div class="xp-window" id="playJockeyWindow">
        <div class="title-bar" id="playJockeyTitleBar">
            <span class="title-bar-text">PlayJockey</span>
            <div class="title-bar-controls">
                <button id="playJockeyMinimizeBtn" title="Minimize">0</button>
                <button id="playJockeyMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="playJockeyCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="playJockeyWindowBody">
            <div class="playjockey-body-container">
                <div class="playjockey-input-bar">
                    <input type="text" id="playJockeyLinkInput" placeholder="Paste YouTube Link Here">
                    <button id="playJockeyAddBtn" class="xp-button">Add</button>
                </div>
                <div class="playjockey-player-area">
                    <div id="playJockeyPlayer"></div> 
                </div>
                <div class="playjockey-controls-bar">
                    <button id="playJockeyRandomBtn" class="xp-button">Random: Off</button>
                    <button id="playJockeyAutoPlayBtn" class="xp-button">Auto Play: On</button> 
                    <button id="playJockeyRepeatBtn" class="xp-button">Repeat: Off</button>
                </div>
                <div class="playjockey-playlist-area" id="playJockeyPlaylist">
                </div>
            </div>
        </div>
        <div class="resize-handle" id="playJockeyResizeHandle"></div>
    </div>

    <div id="newAreaModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span id="newAreaModalTitle">Create New Area</span>
                <span class="close-button" data-modal-id="newAreaModal">r</span>
            </div>
            <div class="modal-body">
                <label for="newAreaName">Area Name:</label>
                <input type="text" id="newAreaName" placeholder="e.g., Fitness, Learning, Work">
            </div>
            <div class="modal-footer">
                <button id="saveNewAreaBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="newAreaModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="addEditAchievementModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span id="addEditAchievementModalTitle">Add Achievement</span>
                <span class="close-button" data-modal-id="addEditAchievementModal">r</span>
            </div>
            <div class="modal-body">
                <input type="hidden" id="achievementAreaName">
                <input type="hidden" id="achievementDayIndex">
                <input type="hidden" id="editingAchievementKey">
                <input type="hidden" id="editingAchievementId">
                <label>Type:</label>
                <input type="radio" name="achievementType" value="text" id="typeText" checked> Text
                <input type="radio" name="achievementType" value="image" id="typeImage"> Image
                <br><br>
                <div id="textInputDiv">
                    <label for="achievementText">Description:</label>
                    <textarea id="achievementText" rows="3"></textarea>
                </div>
                <div id="imageInputDiv" style="display:none;">
                    <label for="achievementImage">Upload Image:</label>
                    <input type="file" id="achievementImage" accept="image/*">
                    <p><small>Current image will be kept if no new image is selected during edit.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveAchievementBtn" class="xp-button">Save Achievement</button>
                <button class="xp-button" data-modal-id="addEditAchievementModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="questsModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Weekly Quests</span>
                <span class="close-button" data-modal-id="questsModal">r</span>
            </div>
            <div class="modal-body" id="questsList">
                </div>
            <div class="modal-footer">
                <button id="addQuestBtn" class="xp-button">Create New Quest</button>
                <button class="xp-button" data-modal-id="questsModal">Close</button>
            </div>
        </div>
    </div>
    <div id="confirmRemoveAreaModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Deletion</span>
                <span class="close-button" data-modal-id="confirmRemoveAreaModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemoveAreaMessage">Are you sure?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmRemoveBtn" class="xp-button">Confirm</button>
                <button class="xp-button" data-modal-id="confirmRemoveAreaModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmDeleteAchievementModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Achievement Deletion</span>
                <span class="close-button" data-modal-id="confirmDeleteAchievementModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this achievement? This will deduct its XP.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmDeleteAchievementBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmDeleteAchievementModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="createQuestModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Create New Quest</span>
                <span class="close-button" data-modal-id="createQuestModal">r</span>
            </div>
            <div class="modal-body">
                <label for="newQuestAreaName">Area:</label>
                <select id="newQuestAreaName"></select>
                <label for="newQuestDescription">Description:</label>
                <textarea id="newQuestDescription" rows="2" placeholder="e.g., Read 2 chapters"></textarea>
                <label for="newQuestTargetXP">Target XP to Earn in Area for Quest:</label>
                <input type="number" id="newQuestTargetXP" min="1" value="30">
                <label for="newQuestRewardXP">Quest Reward XP:</label>
                <input type="number" id="newQuestRewardXP" min="1" value="50">
            </div>
            <div class="modal-footer">
                <button id="saveNewQuestBtn" class="xp-button">Save Quest</button>
                <button class="xp-button" data-modal-id="createQuestModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmRefreshQuestModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Quest Refresh</span>
                <span class="close-button" data-modal-id="confirmRefreshQuestModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to refresh this quest? Current progress on this quest will be lost and a new quest will be generated.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmRefreshQuestBtn" class="xp-button">Refresh Quest</button>
                <button class="xp-button" data-modal-id="confirmRefreshQuestModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="changeBgImageModal" class="modal">
        <div class="modal-content" style="max-width: 550px;"> <div class="modal-title-bar">
                <span>Change Background</span>
                <span class="close-button" data-modal-id="changeBgImageModal">r</span>
            </div>
            <div class="modal-body">
                <p>Choose a background type for the application:</p>
                <div>
                    <label for="newBgImageInput">1. Upload image file:</label>
                    <input type="file" id="newBgImageInput" accept="image/*">
                     <p><small>Max 5MB recommended for file uploads due to browser storage limits.</small></p>
                    <button id="uploadBgImageBtn" class="xp-button" style="margin-top: 5px;">Upload File & Apply</button>
                </div>
                <hr>
                <div>
                    <label for="bgImageUrlInput">2. Enter image URL:</label>
                    <input type="text" id="bgImageUrlInput" placeholder="https://example.com/image.png">
                    <p><small>Using a URL is recommended for very large images from the web.</small></p>
                    <button id="applyBgImageUrlBtn" class="xp-button" style="margin-top: 5px;">Apply URL</button>
                </div>
                <hr>
                <div>
                    <label>3. Pick a solid color:</label>
                    <div id="bgColorSwatchesContainer" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; justify-content: center;">
                          </div>
                     <p style="margin-top: 8px;"><small>Click a color swatch to apply it immediately.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="xp-button" data-modal-id="changeBgImageModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="playJockeyContextMenu" class="context-modal">
        <div class="context-modal-item" id="pjContextRename">Rename</div>
        <div class="context-modal-item" id="pjContextRemove">Remove</div>
    </div>

<script src="https://www.youtube.com/iframe_api"></script>

<script>
    "use strict";

    const WEEKDAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    const XP_PER_REGULAR_ACHIEVEMENT = 10;
    const XP_PER_QUEST_COMPLETED_BASE = 50;
    const STORAGE_KEY = 'lifeXpData_v1.9.9'; 
    const MAX_WEEKLY_QUESTS = 5;
    const ICON_GRID_SIZE = 25; 

    let minTrackerAppWidth; 
    const MIN_TRACKER_APP_HEIGHT = 250;
    const MIN_TEXTEDITOR_WIDTH = 450; 
    const MIN_TEXTEDITOR_HEIGHT = 300; 
    const MIN_PLAYJOCKEY_WIDTH = 480;
    const MIN_PLAYJOCKEY_HEIGHT = 400; 


    const STANDARD_COLORS = [
        { name: 'Black', value: '#000000' }, { name: 'Silver', value: '#C0C0C0' },
        { name: 'Gray', value: '#808080' }, { name: 'White', value: '#FFFFFF' },
        { name: 'Maroon', value: '#800000' }, { name: 'Red', value: '#FF0000' },
        { name: 'Purple', value: '#800080' }, { name: 'Fuchsia', value: '#FF00FF' },
        { name: 'Green', value: '#008000' }, { name: 'Lime', value: '#00FF00' },
        { name: 'Olive', value: '#808000' }, { name: 'Yellow', value: '#FFFF00' },
        { name: 'Navy', value: '#000080' }, { name: 'Blue', value: '#0000FF' },
        { name: 'Teal', value: '#008080' }, { name: 'Aqua', value: '#00FFFF' },
        { name: 'Orange', value: '#FFA500' }, { name: 'Brown', value: '#A52A2A' },
        { name: 'Pink', value: '#FFC0CB' }, { name: 'Gold', value: '#FFD700' },
        { name: 'Dark Green', value: '#006400' }, { name: 'Light Blue', value: '#ADD8E6' },
        { name: 'Indigo', value: '#4B0082' }, { name: 'Violet', value: '#EE82EE' },
        { name: 'Coral', value: '#FF7F50' }, { name: 'Sky Blue', value: '#87CEEB' }
    ];

    const MODAL_IDS = {
        NEW_AREA: 'newAreaModal',
        ADD_EDIT_ACHIEVEMENT: 'addEditAchievementModal',
        QUESTS: 'questsModal',
        CONFIRM_REMOVE_AREA: 'confirmRemoveAreaModal',
        CONFIRM_DELETE_ACHIEVEMENT: 'confirmDeleteAchievementModal',
        CREATE_QUEST: 'createQuestModal',
        CONFIRM_REFRESH_QUEST: 'confirmRefreshQuestModal',
        CHANGE_BG_IMAGE: 'changeBgImageModal'
    };

    const getById = (id) => document.getElementById(id);

    const DOM = {
        xpMainWindow: getById('xpMainWindow'),
        xpMainWindowTitleBar: getById('xpMainWindowTitleBar'),
        xpMainWindowResizeHandle: getById('xpMainWindowResizeHandle'),
        xpMainWindowMinimizeBtn: getById('xpMainWindowMinimizeBtn'),
        xpMainWindowMaximizeBtn: getById('xpMainWindowMaximizeBtn'),
        xpMainWindowCloseBtn: getById('xpMainWindowCloseBtn'), 
        weekdayHeaders: getById('weekdayHeaders'),
        gridBody: getById('gridBody'),
        addAreaBtn: getById('addAreaBtn'),
        prevWeekBtn: getById('prevWeekBtn'),
        nextWeekBtn: getById('nextWeekBtn'),
        thisWeekBtn: getById('thisWeekBtn'),
        toggleViewBtn: getById('toggleViewBtn'),
        currentWeekDisplay: getById('currentWeekDisplay'),
        weekCountDisplay: getById('weekCountDisplay'),
        showQuestsBtn: getById('showQuestsBtn'),
        controlsBar: getById('controlsBar'),

        textEditorWindow: getById('textEditorWindow'),
        textEditorWindowTitleBar: getById('textEditorWindowTitleBar'),
        textEditorWindowBody: getById('textEditorWindowBody'),
        textEditorFrame: getById('textEditorFrame'),
        textEditorResizeHandle: getById('textEditorResizeHandle'),
        textEditorMinimizeBtn: getById('textEditorMinimizeBtn'),
        textEditorMaximizeBtn: getById('textEditorMaximizeBtn'),
        textEditorCloseBtn: getById('textEditorCloseBtn'),

        playJockeyWindow: getById('playJockeyWindow'),
        playJockeyTitleBar: getById('playJockeyTitleBar'),
        playJockeyWindowBody: getById('playJockeyWindowBody'),
        playJockeyResizeHandle: getById('playJockeyResizeHandle'),
        playJockeyMinimizeBtn: getById('playJockeyMinimizeBtn'),
        playJockeyMaximizeBtn: getById('playJockeyMaximizeBtn'),
        playJockeyCloseBtn: getById('playJockeyCloseBtn'),
        playJockeyLinkInput: getById('playJockeyLinkInput'),
        playJockeyAddBtn: getById('playJockeyAddBtn'),
        playJockeyPlayer: getById('playJockeyPlayer'), 
        playJockeyPlaylist: getById('playJockeyPlaylist'),
        playJockeyContextMenu: getById('playJockeyContextMenu'),
        pjContextRenameBtn: getById('pjContextRename'),
        pjContextRemoveBtn: getById('pjContextRemove'),
        playJockeyRandomBtn: getById('playJockeyRandomBtn'), 
        playJockeyAutoPlayBtn: getById('playJockeyAutoPlayBtn'), 
        playJockeyRepeatBtn: getById('playJockeyRepeatBtn'), 


        textEditorIcon: getById('textEditorIcon'), 
        trackerIcon: getById('trackerIcon'),
        playJockeyIcon: getById('playJockeyIcon'),

        newAreaModal: getById(MODAL_IDS.NEW_AREA),
        newAreaNameInput: getById('newAreaName'),
        saveNewAreaBtn: getById('saveNewAreaBtn'),
        addEditAchievementModal: getById(MODAL_IDS.ADD_EDIT_ACHIEVEMENT),
        addEditAchievementModalTitle: getById('addEditAchievementModalTitle'),
        achievementAreaNameInput: getById('achievementAreaName'),
        achievementDayIndexInput: getById('achievementDayIndex'),
        editingAchievementKeyInput: getById('editingAchievementKey'),
        editingAchievementIdInput: getById('editingAchievementId'),
        achievementTypeRadios: document.getElementsByName('achievementType'),
        textInputDiv: getById('textInputDiv'),
        imageInputDiv: getById('imageInputDiv'),
        achievementTextInput: getById('achievementText'),
        achievementImageInput: getById('achievementImage'),
        saveAchievementBtn: getById('saveAchievementBtn'),
        questsModal: getById(MODAL_IDS.QUESTS),
        questsList: getById('questsList'),
        addQuestBtn: getById('addQuestBtn'),
        createQuestModal: getById(MODAL_IDS.CREATE_QUEST),
        newQuestAreaNameSelect: getById('newQuestAreaName'),
        newQuestDescriptionInput: getById('newQuestDescription'),
        newQuestTargetXPInput: getById('newQuestTargetXP'),
        newQuestRewardXPInput: getById('newQuestRewardXP'),
        saveNewQuestBtn: getById('saveNewQuestBtn'),
        confirmRefreshQuestModal: getById(MODAL_IDS.CONFIRM_REFRESH_QUEST),
        confirmRefreshQuestBtn: getById('confirmRefreshQuestBtn'),
        modalCloseButtons: document.querySelectorAll('.modal .close-button, .modal .xp-button[data-modal-id]'),
        confirmRemoveAreaModal: getById(MODAL_IDS.CONFIRM_REMOVE_AREA),
        confirmRemoveAreaMessage: getById('confirmRemoveAreaMessage'),
        confirmRemoveBtn: getById('confirmRemoveBtn'),
        confirmDeleteAchievementModal: getById(MODAL_IDS.CONFIRM_DELETE_ACHIEVEMENT),
        confirmDeleteAchievementBtn: getById('confirmDeleteAchievementBtn'),
        changeBgImageModal: getById(MODAL_IDS.CHANGE_BG_IMAGE),
        newBgImageInput: getById('newBgImageInput'),
        uploadBgImageBtn: getById('uploadBgImageBtn'),
        bgImageUrlInput: getById('bgImageUrlInput'),        
        applyBgImageUrlBtn: getById('applyBgImageUrlBtn'),
        bgColorSwatchesContainer: getById('bgColorSwatchesContainer')
    };

    let appData = {
        areas: [],
        achievements: {},
        quests: {},        
        currentWeekStartDate: null, 
        viewMode: 'week', 
        selectedDayIndex: 0, 
        windowStates: {}, 
        iconPositions: {}, 
        customBgImage: null,
        customBgColor: null,
        playJockeyPlaylist: [], 
        playJockeyCurrentVideo: null,
        playJockeyAutoPlayEnabled: true, 
        playJockeyRandomEnabled: false,  
        playJockeyRepeatState: "off",
        playJockeyRandomHistory: [] 
    };
    
    let lastNormalStates = {}; 
    let highestZIndex = 9; 

    let activeDragWindow = null;
    let activeResizeWindow = null;
    let dragOffsetX, dragOffsetY;
    let resizeInitialX, resizeInitialY, resizeInitialWidth, resizeInitialHeight;

    let activeDragIcon = null;
    let iconDragOffsetX, iconDragOffsetY;

    let pjDraggedItem = null; 

    let ytPlayerInstance = null;
    let isYouTubeApiReady = false;
    let pendingVideoToLoad = null; 


    function parseYYYYMMDDToLocalDate(dateString) {
        const [year, month, day] = dateString.split('-').map(Number);
        return new Date(year, month - 1, day);
    }

    function getDayOfYear(date) {
        const startOfYear = new Date(date.getFullYear(), 0, 0);
        const diff = date - startOfYear;
        const oneDay = 1000 * 60 * 60 * 24;
        return Math.floor(diff / oneDay);
    }

    function applyCurrentBackgroundStyle() {
        if (appData.customBgColor) {
            document.body.style.backgroundImage = 'none';
            document.body.style.backgroundColor = appData.customBgColor;
        } else if (appData.customBgImage) {
            document.body.style.backgroundColor = '';
            document.body.style.backgroundImage = `url('${appData.customBgImage}')`;
        } else {
            document.body.style.backgroundColor = '#3A6EA5'; 
            document.body.style.backgroundImage = "url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png')"; 
        }
    }

    function init() {
        loadData();
        applyCurrentBackgroundStyle();
        populateColorSwatches();
        initDesktopIcons(); 

        if (appData.viewMode === 'week') {
            minTrackerAppWidth = 905;
        } else {
            minTrackerAppWidth = 375;
        }
        if (appData.viewMode !== 'week' && appData.viewMode !== 'day') {
             console.warn("Invalid viewMode loaded, defaulting to week.");
             appData.viewMode = 'week';
             minTrackerAppWidth = 905;
        }

        if (!appData.currentWeekStartDate) {
            appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        }
        if (appData.viewMode === 'day' && (appData.selectedDayIndex === undefined || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) ) {
             appData.selectedDayIndex = 0;
        }

        initWindowInteractions('xpMainWindow');
        restoreWindowState('xpMainWindow');
        updateMinMaxButtonStates('xpMainWindow'); 
        
        DOM.textEditorFrame.srcdoc = getTextEditorHTMLContent();
        initWindowInteractions('textEditorWindow');
        restoreWindowState('textEditorWindow');
        updateMinMaxButtonStates('textEditorWindow'); 
        
        initWindowInteractions('playJockeyWindow');
        restoreWindowState('playJockeyWindow');
        updateMinMaxButtonStates('playJockeyWindow');
        renderPlayJockeyPlaylist(); 
        updatePlayJockeyAutoPlayButtonState(); 
        updatePlayJockeyRandomButtonState(); 
        updatePlayJockeyRepeatButtonState(); 


        if (appData.playJockeyCurrentVideo && (isYouTubeApiReady || typeof YT !== 'undefined')) {
            playYouTubeVideoById(appData.playJockeyCurrentVideo.videoId, appData.playJockeyAutoPlayEnabled); 
        } else if (appData.playJockeyCurrentVideo) {
            pendingVideoToLoad = { videoId: appData.playJockeyCurrentVideo.videoId, autoplayIntent: appData.playJockeyAutoPlayEnabled };
        }


        let maxLoadedWindowZ = highestZIndex; 
        ['xpMainWindow', 'textEditorWindow', 'playJockeyWindow'].forEach(windowId => {
            if (appData.windowStates[windowId] && appData.windowStates[windowId].zIndex) {
                maxLoadedWindowZ = Math.max(maxLoadedWindowZ, parseInt(appData.windowStates[windowId].zIndex));
            }
        });
        highestZIndex = maxLoadedWindowZ;


        addEventListeners(); 
        initPlayJockeyContextMenu(); 

        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        handleAppWindowResize(); 

        const trackerWindowObserver = new ResizeObserver(handleAppWindowResize);
        trackerWindowObserver.observe(DOM.xpMainWindow);
    }

    function initDesktopIcons() {
        const icons = [DOM.textEditorIcon, DOM.trackerIcon, DOM.playJockeyIcon]; 
        const iconData = [
            { id: 'trackerIcon', defaultX: 0, defaultY: 0, element: DOM.trackerIcon },
            { id: 'textEditorIcon', defaultX: 0, defaultY: 100, element: DOM.textEditorIcon },
            { id: 'playJockeyIcon', defaultX: 0, defaultY: 200, element: DOM.playJockeyIcon }
        ];

        iconData.forEach(data => {
            const iconElement = data.element;
            if (!iconElement) return;

            const iconId = iconElement.id; 
            if (appData.iconPositions && appData.iconPositions[iconId]) {
                iconElement.style.left = appData.iconPositions[iconId].x + 'px';
                iconElement.style.top = appData.iconPositions[iconId].y + 'px';
            } else {
                const { x: finalX, y: finalY } = findNonCollidingPosition(iconElement, data.defaultX, data.defaultY);
                
                iconElement.style.left = finalX + 'px';
                iconElement.style.top = finalY + 'px';

                if (!appData.iconPositions) appData.iconPositions = {};
                appData.iconPositions[iconId] = { x: finalX, y: finalY };
            }

            iconElement.addEventListener('mousedown', handleIconMouseDown);
            iconElement.addEventListener('dblclick', handleIconDoubleClick);
        });
        saveData(); 
    }


    function handleIconMouseDown(e) {
        if (e.button !== 0 || activeDragWindow || activeResizeWindow) return;

        activeDragIcon = e.currentTarget;
        const windowId = activeDragIcon.dataset.windowId;
        const windowEl = getById(windowId);
        if(windowEl && windowEl.style.display !== 'none' && !windowEl.classList.contains('minimized')) {
             bringToFront(windowEl);
        }

        iconDragOffsetX = e.clientX - activeDragIcon.offsetLeft;
        iconDragOffsetY = e.clientY - activeDragIcon.offsetTop;

        activeDragIcon.style.cursor = 'grabbing';
        activeDragIcon.style.zIndex = '6'; 

        document.addEventListener('mousemove', handleIconMouseMove);
        document.addEventListener('mouseup', handleIconMouseUp);
        e.preventDefault(); 
    }

    function handleIconMouseMove(e) {
        if (!activeDragIcon) return;
        let newX = e.clientX - iconDragOffsetX;
        let newY = e.clientY - iconDragOffsetY;

        const bodyRect = document.body.getBoundingClientRect();
        const iconWidth = activeDragIcon.offsetWidth || 90;
        const iconHeight = activeDragIcon.offsetHeight || 100;

        newX = Math.max(0, Math.min(newX, bodyRect.width - iconWidth));
        newY = Math.max(0, Math.min(newY, bodyRect.height - iconHeight));

        activeDragIcon.style.left = newX + 'px';
        activeDragIcon.style.top = newY + 'px';
    }
    
    function findNonCollidingPosition(draggedIcon, initialX, initialY) {
        let currentX = initialX;
        let currentY = initialY;
        let attempt = 0;
        const maxAttempts = 100; 
        const iconWidth = draggedIcon.offsetWidth || 90; 
        const iconHeight = draggedIcon.offsetHeight || 100; 

        const checkCollisionAt = (x, y, currentDraggedIcon) => {
            const iconsToCompare = [DOM.textEditorIcon, DOM.trackerIcon, DOM.playJockeyIcon].filter(
                icon => icon && icon !== currentDraggedIcon 
            );

            for (const otherIcon of iconsToCompare) {
                if (!otherIcon.style.left || !otherIcon.style.top) continue; 

                const otherLeft = parseInt(otherIcon.style.left, 10);
                const otherTop = parseInt(otherIcon.style.top, 10);
                const otherWidth = otherIcon.offsetWidth || 90;
                const otherHeight = otherIcon.offsetHeight || 100;

                if (x < otherLeft + otherWidth &&
                    x + iconWidth > otherLeft &&
                    y < otherTop + otherHeight &&
                    y + iconHeight > otherTop) {
                    return true; 
                }
            }
            return false; 
        };

        if (!checkCollisionAt(currentX, currentY, draggedIcon)) {
            return { x: currentX, y: currentY };
        }

        let layer = 1;
        while (attempt < maxAttempts) {
            const positionsToTry = [];
            for (let i = -layer; i <= layer; i++) {
                positionsToTry.push({ x: initialX + i * ICON_GRID_SIZE, y: initialY - layer * ICON_GRID_SIZE });
                if (layer !==0 ) positionsToTry.push({ x: initialX + i * ICON_GRID_SIZE, y: initialY + layer * ICON_GRID_SIZE });
            }
            for (let i = -layer + 1; i < layer; i++) {
                positionsToTry.push({ x: initialX - layer * ICON_GRID_SIZE, y: initialY + i * ICON_GRID_SIZE });
                if (layer !== 0) positionsToTry.push({ x: initialX + layer * ICON_GRID_SIZE, y: initialY + i * ICON_GRID_SIZE });
            }

            for (const pos of positionsToTry) {
                attempt++;
                if (attempt >= maxAttempts) break;

                let testX = Math.round(pos.x / ICON_GRID_SIZE) * ICON_GRID_SIZE;
                let testY = Math.round(pos.y / ICON_GRID_SIZE) * ICON_GRID_SIZE;

                testX = Math.max(0, Math.min(testX, document.body.clientWidth - iconWidth));
                testY = Math.max(0, Math.min(testY, document.body.clientHeight - iconHeight));
                testX = Math.round(testX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
                testY = Math.round(testY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

                if (!checkCollisionAt(testX, testY, draggedIcon)) {
                    return { x: testX, y: testY };
                }
            }
            if (attempt >= maxAttempts) break;
            layer++;
            if (layer * ICON_GRID_SIZE > Math.max(document.body.clientWidth, document.body.clientHeight) && attempt > 20) {
                 console.warn("Collision search boundary too large for icon placement."); break;
            }
        }
        
        console.warn("Could not find a non-colliding position for the icon after " + attempt + " attempts. Using original snapped position.");
        return { x: initialX, y: initialY }; 
    }


    function handleIconMouseUp() {
        if (!activeDragIcon) return;

        activeDragIcon.style.zIndex = '5'; 

        let finalX = activeDragIcon.offsetLeft;
        let finalY = activeDragIcon.offsetTop;

        let snappedX = Math.round(finalX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        let snappedY = Math.round(finalY / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        
        const iconWidth = activeDragIcon.offsetWidth || 90;
        const iconHeight = activeDragIcon.offsetHeight || 100;
        snappedX = Math.max(0, Math.min(snappedX, document.body.clientWidth - iconWidth));
        snappedY = Math.max(0, Math.min(snappedY, document.body.clientHeight - iconHeight));
        snappedX = Math.round(snappedX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        snappedY = Math.round(snappedY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

        const { x: finalSnappedX, y: finalSnappedY } = findNonCollidingPosition(activeDragIcon, snappedX, snappedY);

        activeDragIcon.style.left = finalSnappedX + 'px';
        activeDragIcon.style.top = finalSnappedY + 'px';

        const iconId = activeDragIcon.id;
        if (!appData.iconPositions) appData.iconPositions = {};
        appData.iconPositions[iconId] = { x: finalSnappedX, y: finalSnappedY };
        saveData();

        activeDragIcon.style.cursor = 'grab';
        activeDragIcon = null;
        document.removeEventListener('mousemove', handleIconMouseMove);
        document.removeEventListener('mouseup', handleIconMouseUp);
    }

    function handleIconDoubleClick(e) {
        const iconElement = e.currentTarget;
        const windowId = iconElement.dataset.windowId;
        const windowElement = getById(windowId);

        if (!windowElement) return;

        if (windowElement.style.display === 'none') {
            windowElement.style.display = 'flex';
            if (appData.windowStates[windowId]) {
                appData.windowStates[windowId].hiddenByUser = false;
            }
            if (windowId === 'playJockeyWindow' && appData.playJockeyCurrentVideo && !ytPlayerInstance && isYouTubeApiReady) {
                playYouTubeVideoById(appData.playJockeyCurrentVideo.videoId, false); 
            }
        }


        if (windowElement.classList.contains('minimized')) {
            maximizeWindow(windowId); 
        } else {
            bringToFront(windowElement);
        }
        saveWindowState(windowId);
    }


    function getTextEditorHTMLContent() {
        return `
<html lang="en">
<head>
    <title>Jotter</title> 
    <style>
        :root { --n: rgb(20,20,20); --o: rgb(235,235,235) }
        html, body { height: 100%; margin: 0; padding: 0; box-sizing: border-box; overflow: hidden; }
        [contenteditable]:focus { outline: 0 }
        body, body.inverted { font: 24px/1.5 monospace; color: var(--o); background: var(--n); padding: 20px; box-sizing: border-box; height: 100%; display: flex; flex-direction: column;}
        body.inverted { background: var(--o); color: var(--n) }
        .b { font: 18px monospace; background-color: var(--n); border: 1px solid var(--o); border-radius: 5px; padding: 5px 10px; cursor: pointer; color: var(--o); }
        .inverted.b { background-color: var(--o); color: var(--n); border: 1px solid var(--n); }
        #d { 
            box-sizing: border-box; 
            width: 100%; 
            flex-grow: 1;
            overflow-y: auto; 
            margin-top: 10px; 
            padding: 10px;
        }
        body.inverted #d { border-color: var(--n); }
        #t table { width: auto; margin-top: 5px; }
        #t table td { padding: 2px 5px; }

        .editor-top-actions {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            align-items: center;
            gap: 8px; 
            z-index: 10;
        }
        .options-menu {
            position: absolute; 
            top: 45px; 
            right: 10px; 
            z-index: 10; 
            display:none;
        }
    </style>
</head>
<body>
    <div class="editor-top-actions">
        <button class="b menu-toggle" id="m">+</button>
        <button class="b" onclick="f()">Save</button>
    </div>

    <div class="options-menu" id="t">
        <table class="b">
            <tbody>
                <tr>
                    <td style="text-align:left"><button class="b" id="-">-</button></td>
                    <td style="text-align:center">zoom</td>
                    <td style="text-align:right"><button class="b" id="+">+</button></td>
                </tr>
                <tr>
                    <td colspan="3" style="text-align:center;"><button class="b" id="l">light mode</button></td>
                </tr>
            </tbody>
        </table>
    </div>
    <div id="d" contenteditable="true"></div> 
    <script>
        function f() {
            let a = prompt("Filename:", "jotter_content.html"); 
            if (a) {
                let htmlContent = \`<!DOCTYPE html>
<html>
<head>
    <title>Saved Content</title>
    <meta charset="UTF-8">
    <style>
        body { font: 24px/1.5 monospace; margin: 50px; }
    </style>
</head>
<body>
    \${document.getElementById("d").innerHTML}
</body>
</html>\`;
                let b = new Blob([htmlContent], { type: "text/html" });
                let c = URL.createObjectURL(b);
                let downloadLink = document.createElement("a");
                downloadLink.setAttribute("href", c);
                downloadLink.setAttribute("download", a);
                downloadLink.click();
                URL.revokeObjectURL(c);
            }
        }
        let d_editor = document.getElementById("d");
        d_editor.focus();

        let p_menuToggle = document.getElementById("m");
        let t_optionsMenu = document.getElementById("t");
        let s_iframeBody = document.querySelector("body");
        let q_buttons = document.querySelectorAll(".b");

        p_menuToggle.addEventListener("click", () => { 
            t_optionsMenu.style.display = (t_optionsMenu.style.display === "none" ? "block" : "none");
            p_menuToggle.innerText = (t_optionsMenu.style.display === "none" ? "+" : "-");
        });
        
        document.addEventListener('click', function(event) {
            if (!t_optionsMenu.contains(event.target) && event.target !== p_menuToggle && !p_menuToggle.contains(event.target) ) {
                if (!event.target.closest || (event.target.closest && !event.target.closest('.options-menu'))) {
                     t_optionsMenu.style.display = 'none';
                     p_menuToggle.innerText = "+";
                }
            }
        });

        t_optionsMenu.addEventListener("click", e => {
            if (e.target.id === "+") {
                let currentFontSize = parseInt(window.getComputedStyle(s_iframeBody).fontSize);
                s_iframeBody.style.fontSize = (currentFontSize + 2) + "px";
            } else if (e.target.id === "-") {
                let currentFontSize = parseInt(window.getComputedStyle(s_iframeBody).fontSize);
                s_iframeBody.style.fontSize = Math.max(8, currentFontSize - 2) + "px";
            } else if (e.target.id === "l") {
                s_iframeBody.classList.toggle("inverted");
                q_buttons.forEach(btn => btn.classList.toggle("inverted"));
                let lightModeButton = document.getElementById("l");
                if (lightModeButton) {
                    lightModeButton.innerText = s_iframeBody.classList.contains("inverted") ? "dark mode" : "light mode";
                }
            }
        });
    <\/script>
</body>
</html>`;
    }


    function populateColorSwatches() {
        STANDARD_COLORS.forEach(color => {
            const swatch = document.createElement('div');
            swatch.style.width = '30px';
            swatch.style.height = '30px';
            swatch.style.backgroundColor = color.value;
            swatch.style.border = '1px solid #7F7F7F';
            swatch.style.cursor = 'pointer';
            swatch.title = color.name;
            swatch.dataset.colorValue = color.value;
            swatch.classList.add('color-swatch-item');
            DOM.bgColorSwatchesContainer.appendChild(swatch);
        });
    }

    function bringToFront(windowElement) {
        if (!windowElement) return;
        highestZIndex++;
        windowElement.style.zIndex = highestZIndex;
        const windowId = windowElement.id;
        if (appData.windowStates[windowId]) {
            appData.windowStates[windowId].zIndex = highestZIndex;
        } else { 
            appData.windowStates[windowId] = { zIndex: highestZIndex };
        }
    }


    function initWindowInteractions(windowId) {
        const windowElement = getById(windowId);
        let titleBarElement;
        let resizeHandleElement;

        if (windowId === 'xpMainWindow') {
            titleBarElement = DOM.xpMainWindowTitleBar;
            resizeHandleElement = DOM.xpMainWindowResizeHandle; 
        } else if (windowId === 'textEditorWindow') {
            titleBarElement = DOM.textEditorWindowTitleBar;
            resizeHandleElement = DOM.textEditorResizeHandle; 
        } else if (windowId === 'playJockeyWindow') {
            titleBarElement = DOM.playJockeyTitleBar;
            resizeHandleElement = DOM.playJockeyResizeHandle;
        }


        if (!windowElement || !titleBarElement) {
            console.error("Window or TitleBar element not found for ID:", windowId);
            return;
        }
        
        windowElement.addEventListener('mousedown', (e) => {
             if (e.target.closest('.desktop-icon') || e.target.closest('.context-modal')) return; 

            if (e.target === windowElement || 
                (e.target === titleBarElement && !e.target.closest('button')) ||
                (windowElement.contains(e.target) && !e.target.closest('button, input, select, textarea, .resize-handle, .achievement-item, .xp-button, iframe, #playJockeyPlayer, .playjockey-playlist-item'))) { 
                 bringToFront(windowElement);
            }
        }, true); 

        titleBarElement.addEventListener('mousedown', (e) => {
            if (e.target.closest('button') || windowElement.classList.contains('true-maximized') || activeDragIcon) return; 
            activeDragWindow = windowElement;
            dragOffsetX = e.clientX - activeDragWindow.offsetLeft;
            dragOffsetY = e.clientY - activeDragWindow.offsetTop;
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDragOrResize);
            bringToFront(windowElement);
        });

        if (resizeHandleElement) {
            resizeHandleElement.addEventListener('mousedown', (e) => {
                if (windowElement.classList.contains('true-maximized') || activeDragIcon) return;
                activeResizeWindow = windowElement;
                activeResizeWindow.classList.add('disable-selection');
                resizeInitialX = e.clientX;
                resizeInitialY = e.clientY;
                resizeInitialWidth = activeResizeWindow.offsetWidth;
                resizeInitialHeight = activeResizeWindow.offsetHeight;
                document.addEventListener('mousemove', doResize);
                document.addEventListener('mouseup', stopDragOrResize);
                bringToFront(windowElement);
            });
        }
    }

    function doDrag(e) {
        if (!activeDragWindow) return;
        activeDragWindow.style.left = (e.clientX - dragOffsetX) + 'px';
        activeDragWindow.style.top = (e.clientY - dragOffsetY) + 'px';
        if (appData.windowStates[activeDragWindow.id]) {
            appData.windowStates[activeDragWindow.id].userManuallySet = true;
        }
    }

    function doResize(e) {
        if (!activeResizeWindow) return;
        const windowId = activeResizeWindow.id;
        let currentMinWidth, currentMinHeight;

        if (windowId === 'xpMainWindow') {
            currentMinWidth = minTrackerAppWidth;
            currentMinHeight = MIN_TRACKER_APP_HEIGHT;
        } else if (windowId === 'textEditorWindow') {
            currentMinWidth = MIN_TEXTEDITOR_WIDTH;
            currentMinHeight = MIN_TEXTEDITOR_HEIGHT;
        } else if (windowId === 'playJockeyWindow') {
            currentMinWidth = MIN_PLAYJOCKEY_WIDTH;
            currentMinHeight = MIN_PLAYJOCKEY_HEIGHT;
        } else {
            return;
        }


        let newWidth = resizeInitialWidth + (e.clientX - resizeInitialX);
        let newHeight = resizeInitialHeight + (e.clientY - resizeInitialY);
        activeResizeWindow.style.width = Math.max(currentMinWidth, newWidth) + 'px';
        activeResizeWindow.style.height = Math.max(currentMinHeight, newHeight) + 'px';

        if (appData.windowStates[windowId]) {
            appData.windowStates[windowId].userManuallySet = true;
        }
        if (windowId === 'xpMainWindow') { 
            handleAppWindowResize();
        }
    }

    function stopDragOrResize() {
        if (activeDragWindow || activeResizeWindow) {
            const windowId = activeDragWindow ? activeDragWindow.id : activeResizeWindow.id;
            saveWindowState(windowId);
        }
        if (activeResizeWindow) {
            activeResizeWindow.classList.remove('disable-selection');
        }
        activeDragWindow = null;
        activeResizeWindow = null;
        document.removeEventListener('mousemove', doDrag);
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', stopDragOrResize);
    }


    function setWindowDefaults(windowId, isBrowserResize = false) {
        const appWindow = getById(windowId);
        if (!appWindow || appWindow.classList.contains('minimized')) return;

        if (appWindow.classList.contains('true-maximized') && !isBrowserResize) { 
            appWindow.style.width = '100vw';
            appWindow.style.height = '100vh';
            appWindow.style.top = '0px';
            appWindow.style.left = '0px';
            return;
        }

        const state = appData.windowStates[windowId] || {};
        const hasValidSavedSize = state.width && state.width > 0 && state.height && state.height > 0;
        const hasValidSavedPosition = state.x !== null && state.y !== null;
        
        let currentMinWidth, currentMinHeight, defaultWidth, defaultHeight, defaultOffsetX, defaultOffsetY;

        if (windowId === 'xpMainWindow') {
            currentMinWidth = minTrackerAppWidth; 
            currentMinHeight = MIN_TRACKER_APP_HEIGHT;
            defaultWidth = 905;
            defaultHeight = 645;
            defaultOffsetX = 0; 
            defaultOffsetY = 0; 
        } else if (windowId === 'textEditorWindow') {
            currentMinWidth = MIN_TEXTEDITOR_WIDTH;
            currentMinHeight = MIN_TEXTEDITOR_HEIGHT;
            defaultWidth = 450;
            defaultHeight = 600;
            defaultOffsetX = 50; 
            defaultOffsetY = 50; 
        } else if (windowId === 'playJockeyWindow') {
            currentMinWidth = MIN_PLAYJOCKEY_WIDTH;
            currentMinHeight = MIN_PLAYJOCKEY_HEIGHT;
            defaultWidth = 520; 
            defaultHeight = 450;
            defaultOffsetX = 100; 
            defaultOffsetY = 100; 
        } else {
            return; 
        }

        if (isBrowserResize || !state.userManuallySet || !hasValidSavedSize) {
            let newWidth = defaultWidth;
            let newHeight = defaultHeight;
            
            newWidth = Math.max(currentMinWidth, newWidth);
            newHeight = Math.max(currentMinHeight, newHeight);

            let newLeft = defaultOffsetX === 0 ? (window.innerWidth - newWidth) / 2 : defaultOffsetX;
            let newTop =  defaultOffsetY === 0 ? (window.innerHeight - newHeight) / 2 : defaultOffsetY;
            
            newTop = Math.max(10, Math.min(newTop, window.innerHeight - newHeight - 10));
            newLeft = Math.max(10, Math.min(newLeft, window.innerWidth - newWidth - 10));

            appWindow.style.width = newWidth + 'px';
            appWindow.style.height = newHeight + 'px';
            appWindow.style.left = newLeft + 'px';
            appWindow.style.top = newTop + 'px';
            if(state) state.userManuallySet = false; 
        } else if (hasValidSavedSize && hasValidSavedPosition && state.userManuallySet && !isBrowserResize) {
            appWindow.style.width = Math.max(currentMinWidth, state.width) + 'px'; 
            appWindow.style.height = Math.max(currentMinHeight, state.height) + 'px';
            appWindow.style.left = state.x + 'px';
            appWindow.style.top = state.y + 'px';
        }
        if (appWindow.classList.contains('true-maximized')) {
             appWindow.style.width = '100vw';
             appWindow.style.height = '100vh';
             appWindow.style.top = '0px';
             appWindow.style.left = '0px';
             if (state) state.userManuallySet = false; 
        }
        saveWindowState(windowId);
    }


    function handleAppWindowResize() { 
        if (DOM.xpMainWindow.classList.contains('minimized')) return;
        checkControlsBarLayout();
        checkToggleDayView(); 
    }

    function checkControlsBarLayout() {
        const controlsBar = DOM.controlsBar;
        const children = [
            controlsBar.querySelector('.week-navigation'),
            controlsBar.querySelector('.controls-group'),
            controlsBar.querySelector('.global-actions')
        ].filter(el => el);

        if (children.length === 0 || !controlsBar.clientWidth) return;

        const originalClasses = controlsBar.className;
        controlsBar.className = 'controls-bar layout-single-row'; 

        let totalChildrenWidth = 0;
        children.forEach(child => {
            const childStyle = getComputedStyle(child);
            totalChildrenWidth += child.scrollWidth + parseFloat(childStyle.marginLeft) + parseFloat(childStyle.marginRight);
        });
        
        controlsBar.className = originalClasses; 

        const controlsBarClientWidth = controlsBar.clientWidth - (parseFloat(getComputedStyle(controlsBar).paddingLeft) + parseFloat(getComputedStyle(controlsBar).paddingRight));

        if (totalChildrenWidth > controlsBarClientWidth && controlsBarClientWidth > 0) {
            controlsBar.classList.add('layout-multi-row');
            controlsBar.classList.remove('layout-single-row');
        } else {
            controlsBar.classList.add('layout-single-row');
            controlsBar.classList.remove('layout-multi-row');
        }
    }


    function checkToggleDayView() { }


    function addEventListeners() {
        document.body.addEventListener('contextmenu', function(event) {
            if (event.target === document.body) { 
                event.preventDefault();
                DOM.newBgImageInput.value = null; 
                DOM.bgImageUrlInput.value = '';    
                openModal(MODAL_IDS.CHANGE_BG_IMAGE);
            }
        });

        DOM.uploadBgImageBtn.addEventListener('click', function() {
            const file = DOM.newBgImageInput.files[0];
            if (file) {
                if (file.size > 5 * 1024 * 1024) { 
                    alert("Image file is large (over 5MB). This might exceed browser storage limits when saved. Consider using a smaller file or a URL.");
                }
                const reader = new FileReader();
                reader.onloadend = function() {
                    document.body.style.backgroundColor = ''; 
                    document.body.style.backgroundImage = `url('${reader.result}')`;
                    appData.customBgImage = reader.result; 
                    appData.customBgColor = null; 
                    saveData();
                    closeModal(MODAL_IDS.CHANGE_BG_IMAGE);
                }
                reader.onerror = function() {
                    alert("Error reading image file.");
                }
                reader.readAsDataURL(file);
            } else {
                alert("Please select an image file first.");
            }
        });

        DOM.applyBgImageUrlBtn.addEventListener('click', function() {
            const imageUrl = DOM.bgImageUrlInput.value.trim();
            if (imageUrl) {
                try {
                    new URL(imageUrl); 
                    document.body.style.backgroundColor = ''; 
                    document.body.style.backgroundImage = `url('${imageUrl}')`;
                    appData.customBgImage = imageUrl; 
                    appData.customBgColor = null; 
                    saveData();
                    closeModal(MODAL_IDS.CHANGE_BG_IMAGE);
                } catch (e) {
                    alert("Invalid image URL provided. Please enter a complete and valid URL (e.g., https://example.com/image.png).");
                }
            } else {
                alert("Please enter an image URL.");
            }
        });

        DOM.bgColorSwatchesContainer.addEventListener('click', function(event) {
            if (event.target.classList.contains('color-swatch-item')) {
                const selectedColor = event.target.dataset.colorValue;
                if (selectedColor) {
                    document.body.style.backgroundImage = 'none'; 
                    document.body.style.backgroundColor = selectedColor;

                    appData.customBgColor = selectedColor;
                    appData.customBgImage = null; 
                    saveData();
                    closeModal(MODAL_IDS.CHANGE_BG_IMAGE);
                }
            }
        });


        DOM.gridBody.addEventListener('click', function(event) {
            if (event.target.classList.contains('delete-area-btn')) {
                const areaName = event.target.dataset.areaName;
                if (areaName) {
                    promptRemoveArea(areaName);
                }
            } else if (event.target.classList.contains('edit-ach-btn')) {
                const achKey = event.target.dataset.achKey;
                const achId = event.target.dataset.achId;
                openAddEditAchievementModal(null, null, achKey, achId);
            } else if (event.target.classList.contains('remove-ach-btn')) {
                const achKey = event.target.dataset.achKey;
                const achId = event.target.dataset.achId;
                promptRemoveAchievement(achKey, achId);
            } else if (event.target.classList.contains('achievement-add-btn-cell')) { 
                const areaName = event.target.dataset.areaName;
                const dayIndex = parseInt(event.target.dataset.dayIndex);
                openAddEditAchievementModal(areaName, dayIndex);
            }
        });

        DOM.addAreaBtn.addEventListener('click', () => openModal(MODAL_IDS.NEW_AREA));
        DOM.saveNewAreaBtn.addEventListener('click', saveNewArea);
        DOM.newAreaNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveNewArea();
        });

        DOM.saveAchievementBtn.addEventListener('click', saveOrUpdateAchievement);
        DOM.achievementTypeRadios.forEach(radio => {
            radio.addEventListener('change', toggleAchievementInputType);
        });

        DOM.prevWeekBtn.addEventListener('click', () => {
            if (appData.viewMode === 'week') navigateWeek(-7);
            else navigateDay(-1);
        });
        DOM.nextWeekBtn.addEventListener('click', () => {
            if (appData.viewMode === 'week') navigateWeek(7);
            else navigateDay(1);
        });
        DOM.thisWeekBtn.addEventListener('click', goToThisWeek);
        DOM.toggleViewBtn.addEventListener('click', toggleViewMode);

        DOM.showQuestsBtn.addEventListener('click', showQuests);
        DOM.addQuestBtn.addEventListener('click', openCreateQuestModal);
        DOM.saveNewQuestBtn.addEventListener('click', saveNewQuest);

        DOM.questsList.addEventListener('click', function(event) {
            if (event.target.classList.contains('refresh-quest-btn')) {
                const questId = event.target.dataset.questId;
                promptRefreshQuest(questId);
            }
        });
        DOM.confirmRefreshQuestBtn.addEventListener('click', confirmAndRefreshQuest);

        DOM.xpMainWindowMinimizeBtn.addEventListener('click', () => minimizeWindow('xpMainWindow'));
        DOM.xpMainWindowMaximizeBtn.addEventListener('click', () => maximizeWindow('xpMainWindow'));
        DOM.xpMainWindowCloseBtn.addEventListener('click', () => { 
            const trackerWindow = DOM.xpMainWindow;
            trackerWindow.style.display = 'none';
            if(appData.windowStates.xpMainWindow) {
                appData.windowStates.xpMainWindow.hiddenByUser = true;
            }
            saveWindowState('xpMainWindow');
        });
        
        DOM.textEditorMinimizeBtn.addEventListener('click', () => minimizeWindow('textEditorWindow'));
        DOM.textEditorMaximizeBtn.addEventListener('click', () => maximizeWindow('textEditorWindow'));
        DOM.textEditorCloseBtn.addEventListener('click', () => {
            const textEditor = DOM.textEditorWindow;
            textEditor.style.display = 'none';
            if(appData.windowStates.textEditorWindow) {
                appData.windowStates.textEditorWindow.hiddenByUser = true; 
            }
            saveWindowState('textEditorWindow'); 
        });

        DOM.playJockeyMinimizeBtn.addEventListener('click', () => minimizeWindow('playJockeyWindow'));
        DOM.playJockeyMaximizeBtn.addEventListener('click', () => maximizeWindow('playJockeyWindow'));
        DOM.playJockeyCloseBtn.addEventListener('click', () => {
            const playJockey = DOM.playJockeyWindow;
            playJockey.style.display = 'none';
            if (appData.windowStates.playJockeyWindow) {
                appData.windowStates.playJockeyWindow.hiddenByUser = true;
            }
            if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                ytPlayerInstance.stopVideo();
            }
            appData.playJockeyCurrentVideo = null; 
            saveWindowState('playJockeyWindow');
            saveData(); 
        });
        
        DOM.playJockeyAddBtn.addEventListener('click', addYouTubeLinkToPlayJockey);
        DOM.playJockeyLinkInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addYouTubeLinkToPlayJockey();
        });
        
        DOM.playJockeyPlaylist.addEventListener('dragstart', handlePjDragStart);
        DOM.playJockeyPlaylist.addEventListener('dragend', handlePjDragEnd);
        DOM.playJockeyPlaylist.addEventListener('dragover', handlePjDragOver);
        DOM.playJockeyPlaylist.addEventListener('dragleave', handlePjDragLeave); 
        DOM.playJockeyPlaylist.addEventListener('drop', handlePjDrop);
        DOM.playJockeyPlaylist.addEventListener('contextmenu', showPjContextMenu);
        
        DOM.playJockeyRandomBtn.addEventListener('click', togglePlayJockeyRandom); 
        DOM.playJockeyAutoPlayBtn.addEventListener('click', togglePlayJockeyAutoPlay); 
        DOM.playJockeyRepeatBtn.addEventListener('click', cyclePlayJockeyRepeat); 


        DOM.modalCloseButtons = document.querySelectorAll('.modal .close-button, .modal .xp-button[data-modal-id]');
        DOM.modalCloseButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const modalId = event.target.dataset.modalId || event.target.closest('.modal').id;
                if (modalId) {
                     closeModal(modalId);
                }
            });
        });

        DOM.confirmRemoveBtn.addEventListener('click', function() {
            const areaNameToRemove = this.dataset.areaNameToRemove;
            if (areaNameToRemove) {
                removeArea(areaNameToRemove);
                closeModal(MODAL_IDS.CONFIRM_REMOVE_AREA);
                delete this.dataset.areaNameToRemove;
            }
        });
        
        DOM.confirmDeleteAchievementBtn.addEventListener('click', function() {
            const key = this.dataset.achievementKey;
            const id = this.dataset.achievementId;
            if (key && id) {
                confirmRemoveAchievement(key, id); 
                closeModal(MODAL_IDS.CONFIRM_DELETE_ACHIEVEMENT);
            }
        });


        window.addEventListener('resize', () => {
            setWindowDefaults('xpMainWindow', true);
            setWindowDefaults('textEditorWindow', true);
            setWindowDefaults('playJockeyWindow', true);
        });

        document.addEventListener('click', (e) => {
            if (!DOM.playJockeyContextMenu.contains(e.target) && DOM.playJockeyContextMenu.style.display === 'block') {
                if (!e.target.closest('.playjockey-playlist-item')) { 
                     hidePjContextMenu();
                }
            }
        });
    }
    
    function minimizeWindow(windowId) {
        const appWindow = getById(windowId);
        if (!appWindow || appWindow.classList.contains('minimized')) return;

        const state = appData.windowStates[windowId] || {};
        state.minimized = true;

        if (appWindow.classList.contains('true-maximized')) {
            state.wasMaximizedBeforeMinimize = true; 
        } else {
            state.wasMaximizedBeforeMinimize = false;
            state.width = appWindow.offsetWidth;
            state.height = appWindow.offsetHeight;
            state.x = appWindow.offsetLeft;
            state.y = appWindow.offsetTop;
        }
        appWindow.classList.remove('true-maximized'); 
        appWindow.classList.add('minimized');
        
        updateMinMaxButtonStates(windowId); 
        saveWindowState(windowId);
    }

    function maximizeWindow(windowId) {
        const appWindow = getById(windowId);
        if (!appWindow) return;

        const state = appData.windowStates[windowId] || {};
        const isMinimized = appWindow.classList.contains('minimized');
        let currentLastNormal = lastNormalStates[windowId] || {};


        if (isMinimized) {
            appWindow.classList.remove('minimized');
            state.minimized = false;
            const wasMaximized = state.wasMaximizedBeforeMinimize; 
            delete state.wasMaximizedBeforeMinimize;

            if (wasMaximized) { 
                if (!currentLastNormal.width || !currentLastNormal.height) {
                    let defaultNormalWidth, defaultNormalHeight, minW, minH;
                    if (windowId === 'xpMainWindow') { defaultNormalWidth = (window.innerWidth * 0.9); defaultNormalHeight = (window.innerHeight * 0.75); minW = minTrackerAppWidth; minH = MIN_TRACKER_APP_HEIGHT;}
                    else if (windowId === 'textEditorWindow') { defaultNormalWidth = (window.innerWidth * 0.6); defaultNormalHeight = (window.innerHeight * 0.65); minW = MIN_TEXTEDITOR_WIDTH; minH = MIN_TEXTEDITOR_HEIGHT;}
                    else if (windowId === 'playJockeyWindow') { defaultNormalWidth = (window.innerWidth * 0.5); defaultNormalHeight = (window.innerHeight * 0.6); minW = MIN_PLAYJOCKEY_WIDTH; minH = MIN_PLAYJOCKEY_HEIGHT;}


                    currentLastNormal = {
                        width: Math.max(minW, state.width || defaultNormalWidth) + 'px',
                        height: Math.max(minH, state.height || defaultNormalHeight) + 'px',
                        top: (state.y || (windowId === 'xpMainWindow' ? 20 : (windowId === 'textEditorWindow' ? 50 : 70))) + 'px',
                        left: (state.x || (windowId === 'xpMainWindow' ? (window.innerWidth * 0.05) : (windowId === 'textEditorWindow' ? 50 : 70))) + 'px'
                    };
                    lastNormalStates[windowId] = currentLastNormal;
                }

                appWindow.style.width = '100vw';
                appWindow.style.height = '100vh';
                appWindow.style.top = '0px';
                appWindow.style.left = '0px';
                appWindow.classList.add('true-maximized');
                state.maximized = true;
                state.userManuallySet = false; 
            } else { 
                let minW, minH, defaultW, defaultH, defaultX, defaultY;
                 if (windowId === 'xpMainWindow') { minW = minTrackerAppWidth; minH = MIN_TRACKER_APP_HEIGHT; defaultW = window.innerWidth * 0.9; defaultH = window.innerHeight * 0.75; defaultX = window.innerWidth * 0.05; defaultY = 20; }
                 else if (windowId === 'textEditorWindow') { minW = MIN_TEXTEDITOR_WIDTH; minH = MIN_TEXTEDITOR_HEIGHT; defaultW = window.innerWidth * 0.6; defaultH = window.innerHeight * 0.65; defaultX = 50; defaultY = 50; }
                 else if (windowId === 'playJockeyWindow') { minW = MIN_PLAYJOCKEY_WIDTH; minH = MIN_PLAYJOCKEY_HEIGHT; defaultW = window.innerWidth * 0.5; defaultH = window.innerHeight * 0.6; defaultX = 70; defaultY = 70; }

                
                let restoreWidth = state.width || parseFloat(currentLastNormal.width) || defaultW;
                let restoreHeight = state.height || parseFloat(currentLastNormal.height) || defaultH;
                let restoreX = state.x || parseFloat(currentLastNormal.left) || defaultX;
                let restoreY = state.y || parseFloat(currentLastNormal.top) || defaultY;

                appWindow.style.width = Math.max(minW, restoreWidth) + 'px';
                appWindow.style.height = Math.max(minH, restoreHeight) + 'px';
                appWindow.style.left = restoreX + 'px';
                appWindow.style.top = restoreY + 'px';
                state.maximized = false;
            }
        } else if (appWindow.classList.contains('true-maximized')) { 
             if (currentLastNormal.width && currentLastNormal.height) {
                appWindow.style.width = currentLastNormal.width;
                appWindow.style.height = currentLastNormal.height;
                appWindow.style.top = currentLastNormal.top;
                appWindow.style.left = currentLastNormal.left;
            } else {
                setWindowDefaults(windowId, false); 
            }
            appWindow.classList.remove('true-maximized');
            state.maximized = false;
            state.userManuallySet = true; 
        } else { 
            lastNormalStates[windowId] = { 
                width: appWindow.style.width || (appWindow.offsetWidth + 'px'),
                height: appWindow.style.height || (appWindow.offsetHeight + 'px'),
                top: appWindow.style.top || (appWindow.offsetTop + 'px'),
                left: appWindow.style.left || (appWindow.offsetLeft + 'px')
            };

            appWindow.style.width = '100vw';
            appWindow.style.height = '100vh';
            appWindow.style.top = '0px';
            appWindow.style.left = '0px';
            appWindow.classList.add('true-maximized');
            state.maximized = true;
            state.userManuallySet = false; 
        }
        
        updateMinMaxButtonStates(windowId); 
        saveWindowState(windowId); 
        if (windowId === 'xpMainWindow') handleAppWindowResize(); 
    }


    function updateMinMaxButtonStates(windowId) {
        const win = getById(windowId);
        let minimizeBtn, maximizeBtn;

        if (windowId === 'xpMainWindow') {
            minimizeBtn = DOM.xpMainWindowMinimizeBtn;
            maximizeBtn = DOM.xpMainWindowMaximizeBtn;
        } else if (windowId === 'textEditorWindow') {
            minimizeBtn = DOM.textEditorMinimizeBtn; 
            maximizeBtn = DOM.textEditorMaximizeBtn; 
        } else if (windowId === 'playJockeyWindow') {
            minimizeBtn = DOM.playJockeyMinimizeBtn;
            maximizeBtn = DOM.playJockeyMaximizeBtn;
        }


        if (!win || !minimizeBtn || !maximizeBtn) {
            return;
        }

        const isMinimized = win.classList.contains('minimized');
        const isTrueMaximized = win.classList.contains('true-maximized');

        minimizeBtn.disabled = isMinimized; 
        maximizeBtn.disabled = false; 


        if (isMinimized) {
            maximizeBtn.textContent = '1'; 
            maximizeBtn.title = "Restore";
        } else if (isTrueMaximized) {
            maximizeBtn.textContent = '2'; 
            maximizeBtn.title = "Restore Down";
        } else { 
            maximizeBtn.textContent = '1'; 
            maximizeBtn.title = "Maximize";
        }
    }

    function updateViewControls() { 
        if (appData.viewMode === 'week') {
            DOM.toggleViewBtn.textContent = 'Day View';
            DOM.prevWeekBtn.textContent = '< Prev Week';
            DOM.nextWeekBtn.textContent = 'Next Week >';
            DOM.thisWeekBtn.textContent = 'This Week';
        } else {
            DOM.toggleViewBtn.textContent = 'Week View';
            DOM.prevWeekBtn.textContent = '< Prev Day';
            DOM.nextWeekBtn.textContent = 'Next Day >';
            DOM.thisWeekBtn.textContent = 'Today';
        }
    }

    function saveWindowState(windowId) {
        const win = getById(windowId);
        if (!win) return;

        let state = appData.windowStates[windowId];
        if (!state) {
            appData.windowStates[windowId] = {};
            state = appData.windowStates[windowId];
        }
        
        state.minimized = win.classList.contains('minimized');
        state.maximized = win.classList.contains('true-maximized'); 
        state.zIndex = parseInt(win.style.zIndex) || (highestZIndex + 1); 
        state.hiddenByUser = win.style.display === 'none'; 


        if (!state.minimized && !state.maximized && !state.hiddenByUser) { 
            state.x = win.offsetLeft;
            state.y = win.offsetTop;
            state.width = win.offsetWidth;
            state.height = win.offsetHeight;
        }
        saveData();
    }

    function restoreWindowState(windowId) {
        const win = getById(windowId);
        if (!win) return;

        let state = appData.windowStates[windowId];
        if (!state) { 
            appData.windowStates[windowId] = {}; 
            state = appData.windowStates[windowId];
            setWindowDefaults(windowId, false);
            
            if (!state.zIndex || state.zIndex <= 5) { 
                 let newZ = highestZIndex + 1;
                 win.style.zIndex = newZ;
                 state.zIndex = newZ;
                 highestZIndex = newZ;
            }
            
            if ( (windowId === 'textEditorWindow' || windowId === 'xpMainWindow' || windowId === 'playJockeyWindow') && state.hiddenByUser) {
                win.style.display = 'none';
            } else {
                win.style.display = 'flex'; 
            }
            updateMinMaxButtonStates(windowId); 
            return;
        }
        
        let loadedZ = state.zIndex || (highestZIndex +1);
        if (loadedZ <= 5) { 
            loadedZ = highestZIndex + 1;
        }
        win.style.zIndex = loadedZ;
        state.zIndex = loadedZ; 
        highestZIndex = Math.max(highestZIndex, loadedZ); 


        if ( (windowId === 'textEditorWindow' || windowId === 'xpMainWindow' || windowId === 'playJockeyWindow') && state.hiddenByUser) {
             win.style.display = 'none';
        } else {
             win.style.display = 'flex'; 
        }


        if (state.minimized) {
            win.classList.add('minimized');
            win.classList.remove('true-maximized'); 
        } else if (state.maximized) { 
            let minW, minH, defaultW, defaultH, defaultX, defaultY;
            if (windowId === 'xpMainWindow') { minW = minTrackerAppWidth; minH = MIN_TRACKER_APP_HEIGHT; defaultW = 905; defaultH = 645; defaultX = window.innerWidth * 0.05; defaultY = 20;}
            else if (windowId === 'textEditorWindow') { minW = MIN_TEXTEDITOR_WIDTH; minH = MIN_TEXTEDITOR_HEIGHT; defaultW = 450; defaultH = 600; defaultX = 50; defaultY = 50;}
            else if (windowId === 'playJockeyWindow') { minW = MIN_PLAYJOCKEY_WIDTH; minH = MIN_PLAYJOCKEY_HEIGHT; defaultW = 520; defaultH = 450; defaultX = 100; defaultY = 100;}
            
            lastNormalStates[windowId] = { 
                width: (state.width ? Math.max(minW, state.width) : defaultW) + 'px', 
                height: (state.height ? Math.max(minH, state.height) : defaultH) + 'px',
                top: (state.y || defaultY) + 'px',
                left: (state.x || defaultX) + 'px'
            };
            win.style.width = '100vw';
            win.style.height = '100vh';
            win.style.top = '0px';
            win.style.left = '0px';
            win.classList.add('true-maximized');
            win.classList.remove('minimized');
            state.userManuallySet = false; 
        } else if (state.userManuallySet && state.width !== null && state.width > 0 && !state.hiddenByUser) { 
            let currentMinWidth, currentMinHeight, defaultX, defaultY;
            if (windowId === 'xpMainWindow') { currentMinWidth = minTrackerAppWidth; currentMinHeight = MIN_TRACKER_APP_HEIGHT; defaultX = window.innerWidth * 0.05; defaultY = 20; }
            else if (windowId === 'textEditorWindow') { currentMinWidth = MIN_TEXTEDITOR_WIDTH; currentMinHeight = MIN_TEXTEDITOR_HEIGHT; defaultX = 50; defaultY = 50; }
            else if (windowId === 'playJockeyWindow') { currentMinWidth = MIN_PLAYJOCKEY_WIDTH; currentMinHeight = MIN_PLAYJOCKEY_HEIGHT; defaultX = 100; defaultY = 100; }


            win.style.left = (state.x || defaultX) + 'px';
            win.style.top = (state.y || defaultY) + 'px';
            win.style.width = Math.max(currentMinWidth, state.width) + 'px'; 
            win.style.height = Math.max(currentMinHeight, state.height) + 'px';
            win.classList.remove('minimized');
            win.classList.remove('true-maximized');
        } else if (!state.hiddenByUser) { 
            setWindowDefaults(windowId, false); 
            win.classList.remove('minimized');
            win.classList.remove('true-maximized');
        }
        updateMinMaxButtonStates(windowId);
    }


    function saveData() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(appData));
        } catch (error) {
            console.error("Error saving data to localStorage:", error);
            if (error.name === 'QuotaExceededError') {
                alert("Could not save data: Storage limit exceeded. This might be due to a very large background image from file upload. Try a smaller file or use the URL option for large images.");
            }
        }
    }

    function loadData() {
        const storedData = localStorage.getItem(STORAGE_KEY);
        const defaultAppData = {
            viewMode: 'week', 
            selectedDayIndex: 0, 
            windowStates: { 
                xpMainWindow: { x: null, y: null, width: null, height: null, maximized: false, minimized: false, zIndex: 11, userManuallySet: false, hiddenByUser: false }, 
                textEditorWindow: { x: null, y: null, width: null, height: null, maximized: false, minimized: false, zIndex: 10, userManuallySet: false, hiddenByUser: false },
                playJockeyWindow: { x: null, y: null, width: null, height: null, maximized: false, minimized: false, zIndex: 9, userManuallySet: false, hiddenByUser: true } 
            },
            iconPositions: { 
                trackerIcon: { x: 0, y: 0 }, 
                textEditorIcon: { x: 0, y: 100 },
                playJockeyIcon: { x: 0, y: 200 }
            },
            areas: [], 
            achievements: {}, 
            quests: {}, 
            customBgImage: null,
            customBgColor: null,
            playJockeyPlaylist: [],
            playJockeyCurrentVideo: null,
            playJockeyAutoPlayEnabled: true, 
            playJockeyRandomEnabled: false,
            playJockeyRepeatState: "off",
            playJockeyRandomHistory: [] 
        };
        if (storedData) {
            try {
                const loadedData = JSON.parse(storedData);
                appData = {
                    ...defaultAppData,
                    ...loadedData,
                    windowStates: { 
                        xpMainWindow: { ...defaultAppData.windowStates.xpMainWindow, ...(loadedData.windowStates ? loadedData.windowStates.xpMainWindow : {}) },
                        textEditorWindow: { ...defaultAppData.windowStates.textEditorWindow, ...(loadedData.windowStates ? loadedData.windowStates.textEditorWindow : {}) },
                        playJockeyWindow: { ...defaultAppData.windowStates.playJockeyWindow, ...(loadedData.windowStates ? loadedData.windowStates.playJockeyWindow : {}) }
                    },
                    iconPositions: { ...defaultAppData.iconPositions, ...(loadedData.iconPositions || {}) },
                    playJockeyPlaylist: (loadedData.playJockeyPlaylist || []).map(video => ({
                        ...video,
                        artist: video.artist || "" // Ensure artist field exists
                    })),
                    playJockeyCurrentVideo: loadedData.playJockeyCurrentVideo ? {
                        ...(loadedData.playJockeyCurrentVideo),
                        artist: loadedData.playJockeyCurrentVideo.artist || ""
                    } : null,
                    playJockeyAutoPlayEnabled: typeof loadedData.playJockeyAutoPlayEnabled === 'boolean' ? loadedData.playJockeyAutoPlayEnabled : defaultAppData.playJockeyAutoPlayEnabled,
                    playJockeyRandomEnabled: typeof loadedData.playJockeyRandomEnabled === 'boolean' ? loadedData.playJockeyRandomEnabled : defaultAppData.playJockeyRandomEnabled,
                    playJockeyRepeatState: ["off", "playlist", "song"].includes(loadedData.playJockeyRepeatState) ? loadedData.playJockeyRepeatState : defaultAppData.playJockeyRepeatState,
                    playJockeyRandomHistory: Array.isArray(loadedData.playJockeyRandomHistory) ? loadedData.playJockeyRandomHistory : [] 
                };
                appData.areas = appData.areas || [];
                appData.achievements = appData.achievements || {};
                appData.quests = appData.quests || {};

                if (typeof appData.selectedDayIndex !== 'number' || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) {
                    appData.selectedDayIndex = 0;
                }
                 if (appData.viewMode !== 'week' && appData.viewMode !== 'day') {
                    appData.viewMode = 'week';
                }
            } catch (error) {
                console.error("Error parsing stored data:", error);
                appData = {...defaultAppData, currentWeekStartDate: getMonday(new Date()).toISOString().split('T')[0]};
            }
        } else {
             appData = { ...defaultAppData, currentWeekStartDate: getMonday(new Date()).toISOString().split('T')[0]};
        }
    }

    function getMonday(d) {
        d = new Date(d); 
        const currentDay = d.getDay(); 
        const diffToMondayVal = d.getDate() - currentDay + (currentDay === 0 ? -6 : 1);
        const mondayDate = new Date(d.getFullYear(), d.getMonth(), diffToMondayVal);
        return mondayDate;
    }

    function getWeekNumber(d) {
        d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }

    function getCurrentWeekId() { 
        if (!appData.currentWeekStartDate) {
            appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        }
        const startDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        return `${startDate.getFullYear()}-W${String(getWeekNumber(startDate)).padStart(2, '0')}`;
    }

    function navigateWeek(offsetInDays) { 
        const currentMon = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        currentMon.setDate(currentMon.getDate() + offsetInDays);
        appData.currentWeekStartDate = getMonday(currentMon).toISOString().split('T')[0]; 
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        saveData();
    }

    function navigateDay(offset) { 
        appData.selectedDayIndex += offset;
        let weekChanged = false;
        let currentMonDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);

        if (appData.selectedDayIndex < 0) {
            currentMonDate.setDate(currentMonDate.getDate() - 7); 
            appData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            appData.selectedDayIndex = 6; 
            weekChanged = true;
        } else if (appData.selectedDayIndex > 6) {
            currentMonDate.setDate(currentMonDate.getDate() + 7); 
            appData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            appData.selectedDayIndex = 0; 
            weekChanged = true;
        }

        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        if (weekChanged) {
            generateQuestsForCurrentWeekIfNeeded();
        }
        saveData();
    }

    function goToThisWeek() { 
        appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        if(appData.viewMode === 'day') {
            const today = new Date();
            let currentDayOfWeek = today.getDay(); 
            appData.selectedDayIndex = (currentDayOfWeek === 0) ? 6 : currentDayOfWeek - 1;
        }
        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        saveData();
    }

    function toggleViewMode() { 
        const appWindow = DOM.xpMainWindow;
        const wasMaximized = appWindow.classList.contains('true-maximized');
        const wasMinimized = appWindow.classList.contains('minimized');

        if (appData.viewMode === 'week') {
            appData.viewMode = 'day';
            minTrackerAppWidth = 375; 
            const today = new Date();
            const currentWeekMondayObj = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
            const checkDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const weekStartCheck = new Date(currentWeekMondayObj.getFullYear(), currentWeekMondayObj.getMonth(), currentWeekMondayObj.getDate());
            const weekEndCheck = new Date(weekStartCheck);
            weekEndCheck.setDate(weekStartCheck.getDate() + 6);

            if (checkDate >= weekStartCheck && checkDate <= weekEndCheck) {
                let currentDayOfWeek = today.getDay();
                appData.selectedDayIndex = (currentDayOfWeek === 0) ? 6 : currentDayOfWeek - 1;
            } else {
                if (appData.selectedDayIndex === undefined || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) {
                    appData.selectedDayIndex = 0;
                }
            }
        } else {
            appData.viewMode = 'week';
            minTrackerAppWidth = 905; 
        }

        if (!wasMaximized && !wasMinimized) {
            let currentWidth = appWindow.offsetWidth;
            if (currentWidth < minTrackerAppWidth) {
                appWindow.style.width = minTrackerAppWidth + 'px';
                if(appData.windowStates.xpMainWindow) {
                    appData.windowStates.xpMainWindow.userManuallySet = false; 
                    setWindowDefaults('xpMainWindow', false); 
                }
            } else if (appData.windowStates.xpMainWindow && !appData.windowStates.xpMainWindow.userManuallySet) {
                 setWindowDefaults('xpMainWindow', false);
            }
        }


        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        saveData(); 
    }

    function updateDateDisplay() { 
        const currentMonday = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        if (appData.viewMode === 'week') {
            const weekEndDate = new Date(currentMonday);
            weekEndDate.setDate(currentMonday.getDate() + 6);
            const options = { month: 'short', day: 'numeric' };
            DOM.currentWeekDisplay.textContent = `${currentMonday.toLocaleDateString(undefined, options)} - ${weekEndDate.toLocaleDateString(undefined, options)}`;
            DOM.weekCountDisplay.textContent = `Year Week: ${getWeekNumber(currentMonday)}`;
        } else {
            const selectedDate = new Date(currentMonday);
             if (typeof appData.selectedDayIndex === 'number' && appData.selectedDayIndex >= 0 && appData.selectedDayIndex <=6){
                 selectedDate.setDate(currentMonday.getDate() + appData.selectedDayIndex);
            } else {
                 appData.selectedDayIndex = 0; 
                 selectedDate.setDate(currentMonday.getDate() + appData.selectedDayIndex);
            }
            const dayDisplayOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            DOM.currentWeekDisplay.textContent = selectedDate.toLocaleDateString(undefined, dayDisplayOptions);
            DOM.weekCountDisplay.textContent = `Year Day: ${getDayOfYear(selectedDate)}`;
        }
    }

    function renderWeekdayHeaders() { 
        DOM.weekdayHeaders.innerHTML = '<th>Area</th>';
        if (appData.viewMode === 'week') {
            WEEKDAYS.forEach(day => {
                const th = document.createElement('th');
                th.textContent = day;
                DOM.weekdayHeaders.appendChild(th);
            });
        } else {
            const th = document.createElement('th');
            const dayDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
            const currentDayIndex = (typeof appData.selectedDayIndex === 'number' && appData.selectedDayIndex >= 0 && appData.selectedDayIndex <=6) ? appData.selectedDayIndex : 0;
            dayDate.setDate(dayDate.getDate() + currentDayIndex);
            th.textContent = `${WEEKDAYS[currentDayIndex]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;
            DOM.weekdayHeaders.appendChild(th);
        }
    }

    function renderGrid() { 
        DOM.gridBody.innerHTML = '';
        appData.areas.forEach(area => {
            const tr = document.createElement('tr');
            tr.dataset.areaName = area.name;

            const nameTd = document.createElement('td');
            nameTd.className = 'area-name-cell';
            nameTd.innerHTML = `
                <div class="area-name-wrapper">
                    <span>${area.name}</span>
                    <button class="xp-button delete-area-btn" data-area-name="${area.name}" title="Delete ${area.name}">X</button>
                </div>
                <div class="area-stats">
                    <span>Level: <span class="area-level">${area.level}</span></span>
                    <div class="xp-bar-container">
                        <div class="xp-bar" style="width: ${getXpPercentage(area)}%;"></div>
                        <div class="xp-bar-text"><span class="area-xp">${area.xp}</span> / ${xpForNextLevel(area.level)} XP</div>
                    </div>
                </div>`;
            tr.appendChild(nameTd);

            const renderCellContent = (td, areaName, dayIdx) => {
                const achievementsKey = `${appData.currentWeekStartDate}_${areaName}_${dayIdx}`;
                const cellAchievements = appData.achievements[achievementsKey] || [];

                cellAchievements.forEach(ach => {
                    const achDiv = document.createElement('div');
                    achDiv.className = 'achievement-item';
                    achDiv.dataset.achId = ach.id;
                    achDiv.dataset.achKey = achievementsKey;

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'achievement-content';
                    if (ach.type === 'text') {
                        contentDiv.textContent = ach.content;
                    } else if (ach.type === 'image') {
                        const img = document.createElement('img');
                        img.src = ach.content;
                        img.alt = "Achievement Image";
                        contentDiv.appendChild(img);
                    }
                    achDiv.appendChild(contentDiv);

                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'achievement-item-actions';
                    actionsDiv.innerHTML = `
                        <button class="xp-button xp-button-small edit-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Edit">Edit</button>
                        <button class="xp-button xp-button-small remove-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Delete">Del</button>
                    `;
                    achDiv.appendChild(actionsDiv);
                    achDiv.title = `XP: ${ach.xp} | Added: ${new Date(ach.timestamp).toLocaleString()}`;
                    td.appendChild(achDiv);
                });

                const addAchBtn = document.createElement('button');
                addAchBtn.className = 'xp-button achievement-add-btn-cell'; 
                addAchBtn.textContent = '+';
                addAchBtn.dataset.areaName = areaName;
                addAchBtn.dataset.dayIndex = dayIdx;

                const dayDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
                dayDate.setDate(dayDate.getDate() + dayIdx);
                addAchBtn.title = `Add achievement to ${areaName} on ${WEEKDAYS[dayIdx]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;
                
                td.appendChild(addAchBtn);
            };

            if (appData.viewMode === 'week') {
                WEEKDAYS.forEach((day, dayIndex) => {
                    const td = document.createElement('td');
                    td.dataset.areaName = area.name;
                    td.dataset.dayIndex = dayIndex;
                    renderCellContent(td, area.name, dayIndex);
                    tr.appendChild(td);
                });
            } else {
                const dayIndex = (typeof appData.selectedDayIndex === 'number' && appData.selectedDayIndex >= 0 && appData.selectedDayIndex <=6) ? appData.selectedDayIndex : 0;
                const td = document.createElement('td');
                td.dataset.areaName = area.name;
                td.dataset.dayIndex = dayIndex;
                renderCellContent(td, area.name, dayIndex);
                tr.appendChild(td);
            }
            DOM.gridBody.appendChild(tr);
        });
    }


    function getXpPercentage(area) { 
        const required = xpForNextLevel(area.level);
        return required > 0 ? Math.min((area.xp / required) * 100, 100) : 0;
    }

    function saveNewArea() { 
        const name = DOM.newAreaNameInput.value.trim();
        if (!name) {
            alert("Area name cannot be empty.");
            return;
        }
        if (appData.areas.find(a => a.name.toLowerCase() === name.toLowerCase())) {
            alert("Area with this name already exists.");
            return;
        }

        appData.areas.push({ name: name, level: 1, xp: 0 });
        DOM.newAreaNameInput.value = '';
        closeModal(MODAL_IDS.NEW_AREA);
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded(true); 
        saveData();
    }

    function promptRemoveArea(areaName) { 
        DOM.confirmRemoveAreaMessage.textContent = `Are you sure you want to remove the area "${areaName}"? This action cannot be undone and will delete all associated achievements and quests.`;
        DOM.confirmRemoveBtn.dataset.areaNameToRemove = areaName;
        openModal(MODAL_IDS.CONFIRM_REMOVE_AREA);
    }

    function removeArea(areaName) { 
        appData.areas = appData.areas.filter(area => area.name !== areaName);

        const achievementKeysToDelete = [];
        for (const key in appData.achievements) {
            if (appData.achievements.hasOwnProperty(key)) {
                const parts = key.split('_');
                if (parts.length >= 3) {
                    const keyAreaName = parts.slice(1, parts.length -1).join('_');
                    if (keyAreaName === areaName) {
                        achievementKeysToDelete.push(key);
                    }
                }
            }
        }
        achievementKeysToDelete.forEach(key => delete appData.achievements[key]);

        for (const weekId in appData.quests) {
            if (appData.quests.hasOwnProperty(weekId)) {
                appData.quests[weekId] = appData.quests[weekId].filter(quest => quest.areaName !== areaName);
            }
        }
        
        generateQuestsForCurrentWeekIfNeeded(true); 
        updateDateDisplay(); 
        renderWeekdayHeaders();
        renderGrid();
        saveData();
    }
    
    function openAddEditAchievementModal(areaName, dayIndex, achievementKeyToEdit = null, achievementIdToEdit = null) { 
        DOM.achievementImageInput.value = null; 
        DOM.achievementTextInput.value = '';
        DOM.editingAchievementKeyInput.value = '';
        DOM.editingAchievementIdInput.value = '';

        if (achievementKeyToEdit && achievementIdToEdit) { 
            const achievementsInCell = appData.achievements[achievementKeyToEdit];
            const achievementToEdit = achievementsInCell ? achievementsInCell.find(ach => ach.id === achievementIdToEdit) : null;

            if (!achievementToEdit) {
                alert("Error: Could not find achievement to edit.");
                return;
            }
            
            const keyParts = achievementKeyToEdit.split('_');
            const currentAreaName = keyParts.slice(1, keyParts.length -1).join('_');
            const currentDayIndex = parseInt(keyParts[keyParts.length -1]);

            DOM.achievementAreaNameInput.value = currentAreaName;
            DOM.achievementDayIndexInput.value = currentDayIndex;
            DOM.editingAchievementKeyInput.value = achievementKeyToEdit;
            DOM.editingAchievementIdInput.value = achievementIdToEdit;

            DOM.addEditAchievementModalTitle.textContent = "Edit Achievement";
            DOM.saveAchievementBtn.textContent = "Update Achievement";

            if (achievementToEdit.type === 'text') {
                DOM.achievementTypeRadios[0].checked = true;
                DOM.achievementTextInput.value = achievementToEdit.content;
            } else if (achievementToEdit.type === 'image') {
                DOM.achievementTypeRadios[1].checked = true;
            }
        } else { 
            DOM.achievementAreaNameInput.value = areaName;
            DOM.achievementDayIndexInput.value = dayIndex;
            DOM.addEditAchievementModalTitle.textContent = "Add Achievement";
            DOM.saveAchievementBtn.textContent = "Save Achievement";
            DOM.achievementTypeRadios[0].checked = true; 
        }
        toggleAchievementInputType();
        openModal(MODAL_IDS.ADD_EDIT_ACHIEVEMENT);
        if(DOM.achievementTypeRadios[0].checked) DOM.achievementTextInput.focus();
    }


    function toggleAchievementInputType() { 
        if (DOM.achievementTypeRadios[0].checked) { 
            DOM.textInputDiv.style.display = 'block';
            DOM.imageInputDiv.style.display = 'none';
        } else { 
            DOM.textInputDiv.style.display = 'none';
            DOM.imageInputDiv.style.display = 'block';
        }
    }

    function saveOrUpdateAchievement() { 
        const areaName = DOM.achievementAreaNameInput.value;
        const dayIndex = parseInt(DOM.achievementDayIndexInput.value);
        const type = document.querySelector('input[name="achievementType"]:checked').value;
        const editingKey = DOM.editingAchievementKeyInput.value;
        const editingId = DOM.editingAchievementIdInput.value;

        const isEditing = editingKey && editingId;
        let achievement;
        
        const achievementsKey = isEditing ? editingKey : `${appData.currentWeekStartDate}_${areaName}_${dayIndex}`;
        if (!appData.achievements[achievementsKey] && !isEditing) {
            appData.achievements[achievementsKey] = [];
        }
        
        let achievementList = appData.achievements[achievementsKey] || [];

        if (isEditing) {
            achievement = achievementList.find(ach => ach.id === editingId);
            if (!achievement) {
                alert("Error: Could not find achievement to update.");
                return;
            }
        } else {
            achievement = {
                id: Date.now() + '-' + Math.random().toString(36).substring(2, 9),
                timestamp: new Date().toISOString(),
                xp: XP_PER_REGULAR_ACHIEVEMENT 
            };
        }
        
        achievement.type = type;

        const processSave = (content) => {
            achievement.content = content;
            if (isEditing) {
            } else { 
                achievementList.push(achievement);
                addXpToArea(areaName, achievement.xp);
                updateQuestProgress(areaName, achievement.xp);
            }
            
            closeModal(MODAL_IDS.ADD_EDIT_ACHIEVEMENT);
            renderGrid();
            saveData();
        };


        if (type === 'text') {
            const textContent = DOM.achievementTextInput.value.trim();
            if (!textContent) {
                alert("Achievement description cannot be empty.");
                return;
            }
            processSave(textContent);
        } else if (type === 'image') {
            const file = DOM.achievementImageInput.files[0];
            if (file) { 
                if (file.size > 2 * 1024 * 1024) { 
                    alert("Image file is too large. Please choose an image under 2MB.");
                    return;
                }
                const reader = new FileReader();
                reader.onloadend = function() {
                    processSave(reader.result);
                }
                reader.onerror = function() {
                    alert("Error reading image file.");
                }
                reader.readAsDataURL(file);
            } else if (isEditing && achievement.type === 'image' && achievement.content) {
                processSave(achievement.content);
            } else if (isEditing && achievement.type !== 'image'){ 
                 alert("Please select an image file for an image type achievement.");
                 return;
            }
             else if (!isEditing) { 
                alert("Please select an image file.");
                return;
            }
        }
    }

    function promptRemoveAchievement(achievementKey, achievementId) { 
        DOM.confirmDeleteAchievementBtn.dataset.achievementKey = achievementKey;
        DOM.confirmDeleteAchievementBtn.dataset.achievementId = achievementId;
        openModal(MODAL_IDS.CONFIRM_DELETE_ACHIEVEMENT);
    }

    function confirmRemoveAchievement(achievementKey, achievementId) { 
        if (!appData.achievements[achievementKey]) return;

        const achIndex = appData.achievements[achievementKey].findIndex(ach => ach.id === achievementId);
        if (achIndex === -1) return;

        const achievementToRemove = appData.achievements[achievementKey][achIndex];
        const xpToRemove = achievementToRemove.xp;
        
        const keyParts = achievementKey.split('_');
        const areaName = keyParts.slice(1, keyParts.length -1).join('_');


        appData.achievements[achievementKey].splice(achIndex, 1);
        if (appData.achievements[achievementKey].length === 0) {
            delete appData.achievements[achievementKey];
        }

        subtractXpFromArea(areaName, xpToRemove);
        updateQuestProgress(areaName, -xpToRemove); 

        renderGrid();
        saveData();
    }


    function xpForNextLevel(currentLevel) { 
        if (currentLevel === 0) return 50; 
        return Math.floor(50 * Math.pow(currentLevel, 1.5));
    }

    function addXpToArea(areaName, xpAmount) { 
        const area = appData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp += xpAmount;
            let leveledUp = false;
            let requiredForNext = xpForNextLevel(area.level);

            while (area.xp >= requiredForNext && requiredForNext > 0) { 
                area.xp -= requiredForNext;
                area.level++;
                leveledUp = true;
                requiredForNext = xpForNextLevel(area.level);
            }

            if (leveledUp) {
                alert(`${area.name} leveled up to Level ${area.level}!`);
                generateQuestsForCurrentWeekIfNeeded(true); 
            }
        }
    }
    
    function subtractXpFromArea(areaName, xpAmount) { 
        const area = appData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp -= xpAmount;
            let deLeveled = false;
            while (area.xp < 0) {
                if (area.level > 1) {
                    area.level--;
                    deLeveled = true;
                    area.xp += xpForNextLevel(area.level); 
                } else {
                    area.xp = 0; 
                    break;
                }
            }
            if (deLeveled) {
                generateQuestsForCurrentWeekIfNeeded(true); 
            }
        }
    }


    function generateQuestsForCurrentWeekIfNeeded(forceRegenerate = false) { 
        const weekId = getCurrentWeekId();

        if (!appData.quests) appData.quests = {}; 

        if (!appData.quests[weekId]) {
            appData.quests[weekId] = [];
        }

        if (appData.quests[weekId].length > 0 && !forceRegenerate) {
            return; 
        }

        if (appData.areas.length < 1 && !forceRegenerate) {
            appData.quests[weekId] = []; 
            saveData();
            return;
        }

        if (forceRegenerate || appData.quests[weekId].length === 0) {
            if (forceRegenerate) appData.quests[weekId] = []; 

            const existingQuestCount = appData.quests[weekId].length;
            const questsToPotentiallyGenerate = Math.min(3, appData.areas.length); 
            let generatedCount = 0;
            
            const availableAreasForNewQuests = [...appData.areas].filter(area => 
                !appData.quests[weekId].some(q => q.areaName === area.name) 
            );
            if (availableAreasForNewQuests.length === 0 && appData.areas.length > 0) { 
                 availableAreasForNewQuests.push(...appData.areas); 
            }


            for (let i = 0; i < questsToPotentiallyGenerate && (existingQuestCount + generatedCount) < MAX_WEEKLY_QUESTS; i++) {
                if (availableAreasForNewQuests.length === 0) break;

                const randomAreaIndex = Math.floor(Math.random() * availableAreasForNewQuests.length);
                const selectedArea = availableAreasForNewQuests.splice(randomAreaIndex, 1)[0]; 
                if (!selectedArea) continue;

                const targetXPEarned = 20 + (selectedArea.level * 10);
                const rewardXP = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5);

                appData.quests[weekId].push({
                    id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}_${i}`,
                    areaName: selectedArea.name,
                    description: `Earn ${targetXPEarned} XP in "${selectedArea.name}" this week.`,
                    targetXPEarned: targetXPEarned,
                    currentXPEarned: 0,
                    rewardXP: rewardXP,
                    completed: false
                });
                generatedCount++;
            }
        }
        saveData();
    }

    function updateQuestProgress(areaName, xpGained) { 
        const weekId = getCurrentWeekId();
        if (!appData.quests || !appData.quests[weekId]) return;

        let questCompletedThisUpdate = false;
        appData.quests[weekId].forEach(quest => {
            if (quest.areaName === areaName && !quest.completed) {
                quest.currentXPEarned += xpGained;
                if (quest.currentXPEarned < 0) quest.currentXPEarned = 0; 

                if (quest.currentXPEarned >= quest.targetXPEarned) {
                    quest.completed = true;
                    quest.currentXPEarned = quest.targetXPEarned; 
                    addXpToArea(quest.areaName, quest.rewardXP); 
                    alert(`Quest Completed: ${quest.description}\n+${quest.rewardXP} XP to ${quest.areaName}!`);
                    questCompletedThisUpdate = true;
                }
            }
        });

        if (questCompletedThisUpdate) {
            renderGrid(); 
            saveData();
        }
    }

    function showQuests() { 
        const weekId = getCurrentWeekId();
        DOM.questsList.innerHTML = '';

        generateQuestsForCurrentWeekIfNeeded(); 

        const currentQuests = appData.quests[weekId] || [];

        if (currentQuests.length === 0) {
            DOM.questsList.innerHTML = `<p>No quests available for this week.${appData.areas.length === 0 ? ' Add some areas first to generate quests!' : ' You can create new quests manually.'}</p>`;
        } else {
            currentQuests.forEach(quest => {
                const questDiv = document.createElement('div');
                questDiv.className = 'quest-item';
                if (quest.completed) {
                    questDiv.classList.add('completed');
                }

                const title = document.createElement('div');
                title.className = 'quest-title';
                title.textContent = `Quest for: ${quest.areaName}`;

                const details = document.createElement('div');
                details.className = 'quest-details';
                details.textContent = quest.description;

                const progress = document.createElement('div');
                progress.className = 'quest-progress';
                progress.textContent = `Progress: ${Math.min(quest.currentXPEarned, quest.targetXPEarned)} / ${quest.targetXPEarned} XP. Reward: ${quest.rewardXP} XP.`;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'quest-actions';
                if (!quest.completed) {
                    const refreshBtn = document.createElement('button');
                    refreshBtn.className = 'xp-button xp-button-small refresh-quest-btn';
                    refreshBtn.dataset.questId = quest.id;
                    refreshBtn.textContent = 'Refresh';
                    actionsDiv.appendChild(refreshBtn);
                }


                questDiv.appendChild(title);
                questDiv.appendChild(details);
                questDiv.appendChild(progress);
                questDiv.appendChild(actionsDiv);
                DOM.questsList.appendChild(questDiv);
            });
        }
        DOM.addQuestBtn.disabled = currentQuests.length >= MAX_WEEKLY_QUESTS;
        openModal(MODAL_IDS.QUESTS);
    }
    
    function openCreateQuestModal() { 
        const weekId = getCurrentWeekId();
        if (appData.quests[weekId] && appData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Maximum of ${MAX_WEEKLY_QUESTS} quests per week reached.`);
            return;
        }
        if (appData.areas.length === 0) {
            alert("Please create at least one Area before adding quests.");
            return;
        }

        DOM.newQuestAreaNameSelect.innerHTML = '';
        appData.areas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.name;
            option.textContent = area.name;
            DOM.newQuestAreaNameSelect.appendChild(option);
        });
        DOM.newQuestDescriptionInput.value = '';
        DOM.newQuestTargetXPInput.value = 30; 
        DOM.newQuestRewardXPInput.value = 50; 
        openModal(MODAL_IDS.CREATE_QUEST);
    }

    function saveNewQuest() { 
        const weekId = getCurrentWeekId();
        if (appData.quests[weekId] && appData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Cannot add new quest: Maximum of ${MAX_WEEKLY_QUESTS} quests reached.`);
            return;
        }

        const areaName = DOM.newQuestAreaNameSelect.value;
        const description = DOM.newQuestDescriptionInput.value.trim();
        const targetXP = parseInt(DOM.newQuestTargetXPInput.value);
        const rewardXP = parseInt(DOM.newQuestRewardXPInput.value);

        if (!areaName) { alert("Please select an area."); return; }
        if (!description) { alert("Please enter a description."); return; }
        if (isNaN(targetXP) || targetXP <= 0) { alert("Target XP must be a positive number."); return; }
        if (isNaN(rewardXP) || rewardXP <= 0) { alert("Reward XP must be a positive number."); return; }

        const newQuest = {
            id: `quest_${weekId}_${areaName.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName: areaName,
            description: description,
            targetXPEarned: targetXP,
            currentXPEarned: 0,
            rewardXP: rewardXP,
            completed: false
        };

        if (!appData.quests[weekId]) appData.quests[weekId] = [];
        appData.quests[weekId].push(newQuest);
        
        closeModal(MODAL_IDS.CREATE_QUEST);
        showQuests(); 
        saveData();
    }

    function promptRefreshQuest(questId) { 
        DOM.confirmRefreshQuestBtn.dataset.questIdToRefresh = questId;
        openModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
    }

    function generateSingleRandomQuest(weekId, questToReplace = null) { 
        if (appData.areas.length === 0) return null;
        
        let potentialAreas = [...appData.areas];
        if (questToReplace && potentialAreas.length > 1) {
            const filteredAreas = potentialAreas.filter(a => a.name !== questToReplace.areaName);
            if (filteredAreas.length > 0) {
                potentialAreas = filteredAreas;
            }
        } else if (potentialAreas.length === 1 && questToReplace && potentialAreas[0].name === questToReplace.areaName) {
        }
        
        const randomAreaIndex = Math.floor(Math.random() * potentialAreas.length);
        const selectedArea = potentialAreas[randomAreaIndex];

        const baseTarget = 20 + (selectedArea.level * 10);
        const targetXPEarned = Math.max(10, Math.round(baseTarget + (Math.random() * baseTarget * 0.3) - (baseTarget * 0.15)) ); 
        const baseReward = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5);
        const rewardXP = Math.max(10, Math.round(baseReward + (Math.random() * baseReward * 0.2) - (baseReward * 0.1))); 

        return {
            id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName: selectedArea.name,
            description: `Earn ${targetXPEarned} XP in "${selectedArea.name}" this week. (Refreshed)`,
            targetXPEarned: targetXPEarned,
            currentXPEarned: 0,
            rewardXP: rewardXP,
            completed: false
        };
    }

    function confirmAndRefreshQuest() { 
        const questIdToRefresh = DOM.confirmRefreshQuestBtn.dataset.questIdToRefresh;
        const weekId = getCurrentWeekId();

        if (!questIdToRefresh || !appData.quests[weekId]) {
            closeModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
            return;
        }

        const questIndex = appData.quests[weekId].findIndex(q => q.id === questIdToRefresh);
        if (questIndex === -1) {
            closeModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
            return;
        }
        
        const oldQuest = appData.quests[weekId][questIndex];
        appData.quests[weekId].splice(questIndex, 1); 

        const newQuest = generateSingleRandomQuest(weekId, oldQuest); 
        if (newQuest) {
            appData.quests[weekId].push(newQuest);
        } else if (appData.areas.length > 0) {
            alert("Could not generate a new quest. Try again or create one manually.");
        }
        closeModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
        showQuests(); 
        saveData(); 
    }

    // --- PlayJockey Functions ---

    function onYouTubeIframeAPIReady() {
        isYouTubeApiReady = true;
        if (pendingVideoToLoad) {
            playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
            pendingVideoToLoad = null;
        } else if (appData.playJockeyCurrentVideo && !ytPlayerInstance && DOM.playJockeyWindow.style.display !== 'none' && !DOM.playJockeyWindow.classList.contains('minimized')) {
            playYouTubeVideoById(appData.playJockeyCurrentVideo.videoId, appData.playJockeyAutoPlayEnabled); 
        }
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        const regex = /(?:youtube\.com\/(?:[^\/\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }

    function addYouTubeLinkToPlayJockey() {
        const link = DOM.playJockeyLinkInput.value.trim();
        if (!link) {
            alert("Please enter a YouTube link.");
            return;
        }
        const videoId = extractYouTubeVideoId(link);
        if (!videoId) {
            alert("Invalid YouTube link. Please ensure it's a valid YouTube video URL.");
            return;
        }

        if (appData.playJockeyPlaylist.some(video => video.videoId === videoId)) {
            alert("This video is already in the playlist.");
            return;
        }

        const tempId = 'pj_' + Date.now() + '_' + Math.random().toString(36).substring(2,7);
        const videoEntry = {
            id: tempId,
            originalUrl: link,
            videoId: videoId,
            title: "Loading title...",
            artist: "" 
        };

        appData.playJockeyPlaylist.push(videoEntry);
        renderPlayJockeyPlaylist(); 
        DOM.playJockeyLinkInput.value = '';
        
        fetchYouTubeTitle(videoEntry); 

        if (!ytPlayerInstance || appData.playJockeyPlaylist.length === 1) {
            playYouTubeVideoById(videoId, true, true); 
        }
    }

    async function fetchYouTubeTitle(videoEntryToUpdate) {
        try {
            // Use direct noembed.com URL
            const oEmbedUrl = `https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoEntryToUpdate.videoId}`;
            const response = await fetch(oEmbedUrl);
            let newTitle = videoEntryToUpdate.originalUrl; 
            let newArtist = "";

            if (response.ok) {
                const data = await response.json();
                if (data.title) {
                    newTitle = data.title;
                }
                if (data.author_name) {
                    newArtist = data.author_name.replace(/\s-\sTopic$/, '').trim();
                }
                // Noembed might return `error` field for certain videos (e.g. private, deleted)
                if (data.error) {
                    console.warn(`Error fetching title/author via noembed for ${videoEntryToUpdate.videoId}: ${data.error}`);
                    // Keep original URL as title if error
                    newTitle = videoEntryToUpdate.originalUrl; 
                    newArtist = "";
                }
            } else {
                console.warn(`Failed to fetch title/author for ${videoEntryToUpdate.videoId} from noembed. Status: ${response.status}`);
                // Keep original URL as title on fetch failure
                newTitle = videoEntryToUpdate.originalUrl; 
                newArtist = "";
            }

            const itemInPlaylist = appData.playJockeyPlaylist.find(item => item.id === videoEntryToUpdate.id);
            if (itemInPlaylist) {
                itemInPlaylist.title = newTitle;
                itemInPlaylist.artist = newArtist;
                renderPlayJockeyPlaylist(); 
                saveData(); 
            }

        } catch (error) {
            console.error(`Error in fetchYouTubeTitle for ${videoEntryToUpdate.videoId}:`, error);
            const itemInPlaylist = appData.playJockeyPlaylist.find(item => item.id === videoEntryToUpdate.id);
            if (itemInPlaylist) {
                 if (itemInPlaylist.title === "Loading title...") itemInPlaylist.title = videoEntryToUpdate.originalUrl;
                 itemInPlaylist.artist = ""; // Fallback to empty artist
                renderPlayJockeyPlaylist();
                saveData();
            }
        }
    }


    function renderPlayJockeyPlaylist() {
        DOM.playJockeyPlaylist.innerHTML = '';
        if (!appData.playJockeyPlaylist || appData.playJockeyPlaylist.length === 0) {
            const emptyMsg = document.createElement('div');
            emptyMsg.textContent = "Playlist is empty. Add some YouTube links!";
            emptyMsg.style.padding = "10px";
            emptyMsg.style.textAlign = "center";
            emptyMsg.style.color = "#555";
            DOM.playJockeyPlaylist.appendChild(emptyMsg);
            return;
        }

        appData.playJockeyPlaylist.forEach(video => {
            const item = document.createElement('div');
            item.className = 'playjockey-playlist-item';
            
            let displayTitle = video.title;
            if (video.title === "Loading title..." || video.title === video.originalUrl) {
                displayTitle = video.originalUrl.length > 40 ? video.originalUrl.substring(0, 37) + '...' : video.originalUrl;
            } else {
                 displayTitle = video.title.length > 40 ? video.title.substring(0, 37) + '...' : video.title;
            }

            let itemText = displayTitle;
            let itemTooltip = video.title !== "Loading title..." ? video.title : video.originalUrl;

            if (video.artist && video.artist.trim() !== "") {
                const artistShort = video.artist.length > 20 ? video.artist.substring(0, 17) + '...' : video.artist;
                itemText = `${displayTitle} - ${artistShort}`;
                itemTooltip = `${itemTooltip} by ${video.artist}`;
            }
            
            item.textContent = itemText;
            item.title = itemTooltip;
            
            item.dataset.videoId = video.videoId;
            item.dataset.playlistItemId = video.id; 
            item.draggable = true; 

            if (appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === video.id) { 
                item.classList.add('playing');
            }
            item.addEventListener('click', (event) => {
                if (event.target.closest('.context-modal')) return;
                if (item.classList.contains('dragging')) return; 

                const clickedItem = event.currentTarget; 
                if (clickedItem && clickedItem.dataset.videoId) {
                    playYouTubeVideoById(clickedItem.dataset.videoId, true, true); 
                }
            });
            DOM.playJockeyPlaylist.appendChild(item);
        });
    }

    function playYouTubeVideoById(videoId, autoplayIntent = true, isManualPlay = false) { 
        if (!videoId) return;

        const videoToPlay = appData.playJockeyPlaylist.find(v => v.videoId === videoId);
        
        if (
            isManualPlay && 
            videoToPlay &&    
            appData.playJockeyRandomEnabled &&
            appData.playJockeyAutoPlayEnabled && 
            appData.playJockeyRepeatState === "off" &&
            appData.playJockeyPlaylist.length > 0 &&
            new Set(appData.playJockeyRandomHistory).size >= new Set(appData.playJockeyPlaylist.map(v => v.id)).size
        ) {
            console.log("Manual play after random cycle (Repeat:Off). Resetting random history for new pass.");
            appData.playJockeyRandomHistory = [videoToPlay.id]; 
        }
        

        appData.playJockeyCurrentVideo = videoToPlay ? { ...videoToPlay } : null;
        updatePlayingClassInPlaylist(videoToPlay ? videoToPlay.id : null); 
        saveData(); 

        if (!appData.playJockeyCurrentVideo && videoId) { 
             if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                ytPlayerInstance.stopVideo();
             }
             return; 
        }


        if (!isYouTubeApiReady) {
            pendingVideoToLoad = { videoId, autoplayIntent };
            console.log("YouTube API not ready, video load queued:", videoId);
            return;
        }

        if (ytPlayerInstance && typeof ytPlayerInstance.loadVideoById === 'function') {
            ytPlayerInstance.loadVideoById({ 'videoId': videoId });
        } else {
            if (DOM.playJockeyPlayer.firstChild && DOM.playJockeyPlayer.firstChild.tagName === 'IFRAME') { 
                 DOM.playJockeyPlayer.innerHTML = '';
            }
            ytPlayerInstance = new YT.Player('playJockeyPlayer', { 
                height: '100%',
                width: '100%',
                videoId: videoId,
                playerVars: {
                    'autoplay': autoplayIntent ? 1 : 0,
                    'controls': 1,
                    'enablejsapi': 1,
                    'origin': window.location.origin,
                    'modestbranding': 1, 
                    'rel': 0 
                },
                events: {
                    'onStateChange': onPlayerStateChange
                }
            });
        }
    }

    function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.ENDED && appData.playJockeyAutoPlayEnabled) {
            playNextPjVideo();
        }
    }

    function playNextPjVideo() {
        if (!ytPlayerInstance || !appData.playJockeyCurrentVideo || appData.playJockeyPlaylist.length === 0) {
            return; 
        }

        let nextVideoItem = null;
        const currentVideoUniqueId = appData.playJockeyCurrentVideo.id;

        if (appData.playJockeyRepeatState === "song") {
            nextVideoItem = appData.playJockeyPlaylist.find(item => item.id === currentVideoUniqueId);
        } else if (appData.playJockeyRandomEnabled) {
            if (appData.playJockeyPlaylist.length === 0) return; 
            
            if (appData.playJockeyPlaylist.length === 1) {
                if (appData.playJockeyRepeatState === "off") {
                    if (appData.playJockeyRandomHistory.includes(currentVideoUniqueId)) return; 
                    nextVideoItem = appData.playJockeyPlaylist[0];
                } else { 
                    nextVideoItem = appData.playJockeyPlaylist[0];
                }
            } else { 
                let eligibleVideos = appData.playJockeyPlaylist.filter(
                    video => !appData.playJockeyRandomHistory.includes(video.id)
                );

                if (eligibleVideos.length === 0) { 
                    if (appData.playJockeyRepeatState === "playlist") {
                        appData.playJockeyRandomHistory = [currentVideoUniqueId]; 
                        eligibleVideos = appData.playJockeyPlaylist.filter(video => video.id !== currentVideoUniqueId);
                        if (eligibleVideos.length === 0 ) { 
                             eligibleVideos = [...appData.playJockeyPlaylist.filter(v => v.id !== currentVideoUniqueId)]; 
                             if (eligibleVideos.length === 0) eligibleVideos = [appData.playJockeyPlaylist[0]]; 
                        }
                    } else { 
                        console.log("Random cycle complete with Repeat: Off. Stopping playback.");
                        appData.playJockeyRandomHistory = []; 
                        return; 
                    }
                }
                
                if (eligibleVideos.length > 0) {
                    const randomIndex = Math.floor(Math.random() * eligibleVideos.length);
                    nextVideoItem = eligibleVideos[randomIndex];
                } 
            }
            
            if (nextVideoItem) {
                if (!appData.playJockeyRandomHistory.includes(nextVideoItem.id)) {
                     appData.playJockeyRandomHistory.push(nextVideoItem.id);
                }
                if (appData.playJockeyRepeatState === "playlist") {
                    const maxHistorySize = Math.max(0, appData.playJockeyPlaylist.length - 1);
                    while (appData.playJockeyRandomHistory.length > maxHistorySize && maxHistorySize > 0 && appData.playJockeyRandomHistory.length >= appData.playJockeyPlaylist.length) {
                        appData.playJockeyRandomHistory.shift(); 
                    }
                }
            }

        } else { 
            const currentIndex = appData.playJockeyPlaylist.findIndex(item => item.id === currentVideoUniqueId);
            if (currentIndex === -1) return;

            let nextIndex = currentIndex + 1;
            if (nextIndex >= appData.playJockeyPlaylist.length) { 
                if (appData.playJockeyRepeatState === "playlist") {
                    nextIndex = 0; 
                } else { 
                    return; 
                }
            }
            if (appData.playJockeyPlaylist[nextIndex]) {
                nextVideoItem = appData.playJockeyPlaylist[nextIndex];
            }
        }

        if (nextVideoItem && nextVideoItem.videoId) {
            playYouTubeVideoById(nextVideoItem.videoId, true, false); 
        }
    }
    
    function updatePlayingClassInPlaylist(playingItemId) {
        const items = DOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item');
        items.forEach(item => {
            if (item.dataset.playlistItemId === playingItemId) {
                item.classList.add('playing');
            } else {
                item.classList.remove('playing');
            }
        });
    }


    function initPlayJockeyContextMenu() {
        DOM.pjContextRenameBtn.addEventListener('click', handlePjContextRename);
        DOM.pjContextRemoveBtn.addEventListener('click', handlePjContextRemove);
    }

    function showPjContextMenu(e) {
        e.preventDefault();
        hidePjContextMenu(); 

        const clickedPlaylistItem = e.target.closest('.playjockey-playlist-item');
        if (clickedPlaylistItem) {
            DOM.playJockeyContextMenu.style.display = 'block';
            let x = e.clientX;
            let y = e.clientY;
            const menuWidth = DOM.playJockeyContextMenu.offsetWidth;
            const menuHeight = DOM.playJockeyContextMenu.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (x + menuWidth > viewportWidth) {
                x = viewportWidth - menuWidth - 5; 
            }
            if (y + menuHeight > viewportHeight) {
                y = viewportHeight - menuHeight - 5; 
            }
            DOM.playJockeyContextMenu.style.left = `${x}px`;
            DOM.playJockeyContextMenu.style.top = `${y}px`;
            DOM.playJockeyContextMenu.dataset.currentItemId = clickedPlaylistItem.dataset.playlistItemId;
        }
    }

    function hidePjContextMenu() {
        DOM.playJockeyContextMenu.style.display = 'none';
        delete DOM.playJockeyContextMenu.dataset.currentItemId;
    }

    function handlePjContextRename() {
        const itemId = DOM.playJockeyContextMenu.dataset.currentItemId;
        if (!itemId) return;

        const itemToRename = appData.playJockeyPlaylist.find(video => video.id === itemId);
        if (itemToRename) {
            const currentDisplayTitle = itemToRename.title === itemToRename.originalUrl || itemToRename.title === "Loading title..." ? "" : itemToRename.title;
            const newName = prompt("Enter new name for the video:", currentDisplayTitle);
            if (newName !== null && newName.trim() !== "") {
                itemToRename.title = newName.trim();
                 if (itemToRename.artist === "" && newName.includes(" - ")) { // Basic attempt to re-parse artist if not set
                    const parts = newName.split(" - ");
                    if (parts.length > 1) {
                        itemToRename.title = parts.slice(0, -1).join(" - ").trim();
                        itemToRename.artist = parts[parts.length - 1].trim().replace(/\s-\sTopic$/, '').trim();
                    }
                }
                renderPlayJockeyPlaylist();
                saveData();
            }
        }
        hidePjContextMenu();
    }

    function handlePjContextRemove() {
        const itemId = DOM.playJockeyContextMenu.dataset.currentItemId;
        if (!itemId) return;

        const itemIndex = appData.playJockeyPlaylist.findIndex(video => video.id === itemId);
        if (itemIndex > -1) {
            const removedItem = appData.playJockeyPlaylist.splice(itemIndex, 1)[0];
            
            const historyIndex = appData.playJockeyRandomHistory.indexOf(removedItem.id);
            if (historyIndex > -1) {
                appData.playJockeyRandomHistory.splice(historyIndex, 1);
            }

            if (appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === removedItem.id) {
                if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                    ytPlayerInstance.stopVideo();
                }
                appData.playJockeyCurrentVideo = null;
                if (appData.playJockeyAutoPlayEnabled && appData.playJockeyPlaylist.length > 0) {
                    playNextPjVideo(); 
                }
            }
            renderPlayJockeyPlaylist();
            saveData();
        }
        hidePjContextMenu();
    }
    
    function handlePjDragStart(e) {
        const target = e.target.closest('.playjockey-playlist-item');
        if (target) {
            pjDraggedItem = target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', target.dataset.playlistItemId);
            setTimeout(() => { 
                target.classList.add('dragging');
            }, 0);
            hidePjContextMenu(); 
        }
    }

    function handlePjDragEnd(e) {
        if (pjDraggedItem) {
            pjDraggedItem.classList.remove('dragging');
        }
        DOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
        pjDraggedItem = null;
    }
    
    function clearPjDragOverHighlights() {
        DOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
    }

    function handlePjDragOver(e) {
        e.preventDefault(); 
        const targetItem = e.target.closest('.playjockey-playlist-item');
        
        clearPjDragOverHighlights();

        if (targetItem && pjDraggedItem && targetItem !== pjDraggedItem) {
            const rect = targetItem.getBoundingClientRect();
            const midpointY = rect.top + rect.height / 2;
            if (e.clientY < midpointY) {
                targetItem.classList.add('drag-over-target-before');
            } else {
                targetItem.classList.add('drag-over-target-after');
            }
        }
    }
    
    function handlePjDragLeave(e) {
        const relatedTargetIsChild = DOM.playJockeyPlaylist.contains(e.relatedTarget);
        if (!relatedTargetIsChild) { 
             clearPjDragOverHighlights();
        } else { 
            const targetItem = e.target.closest('.playjockey-playlist-item');
            if (targetItem) {
                 targetItem.classList.remove('drag-over-target-before', 'drag-over-target-after');
            }
        }
    }


    function handlePjDrop(e) {
        e.preventDefault();
        clearPjDragOverHighlights();
        if (!pjDraggedItem) return;

        const draggedItemId = e.dataTransfer.getData('text/plain');
        const targetItemElement = e.target.closest('.playjockey-playlist-item');
        
        const draggedItemIndex = appData.playJockeyPlaylist.findIndex(item => item.id === draggedItemId);
        if (draggedItemIndex === -1) return;

        const itemToMove = appData.playJockeyPlaylist[draggedItemIndex];
        appData.playJockeyPlaylist.splice(draggedItemIndex, 1); 

        let targetIndex = -1;

        if (targetItemElement && targetItemElement.dataset.playlistItemId !== draggedItemId) {
            const targetItemId = targetItemElement.dataset.playlistItemId;
            targetIndex = appData.playJockeyPlaylist.findIndex(item => item.id === targetItemId);

            const rect = targetItemElement.getBoundingClientRect();
            const midpointY = rect.top + rect.height / 2;
            if (e.clientY < midpointY) {
            } else {
                targetIndex++;
            }
        }

        if (targetIndex !== -1) {
            appData.playJockeyPlaylist.splice(targetIndex, 0, itemToMove);
        } else {
            appData.playJockeyPlaylist.push(itemToMove);
        }
        
        renderPlayJockeyPlaylist();
        saveData();
        pjDraggedItem = null; 
    }


    function togglePlayJockeyAutoPlay() {
        appData.playJockeyAutoPlayEnabled = !appData.playJockeyAutoPlayEnabled;
        updatePlayJockeyAutoPlayButtonState();
        saveData();
    }

    function updatePlayJockeyAutoPlayButtonState() {
        if (appData.playJockeyAutoPlayEnabled) {
            DOM.playJockeyAutoPlayBtn.textContent = 'Auto Play: On';
            DOM.playJockeyAutoPlayBtn.classList.add('autoplay-on');
        } else {
            DOM.playJockeyAutoPlayBtn.textContent = 'Auto Play: Off';
            DOM.playJockeyAutoPlayBtn.classList.remove('autoplay-on');
        }
    }

    function togglePlayJockeyRandom() {
        appData.playJockeyRandomEnabled = !appData.playJockeyRandomEnabled;
        appData.playJockeyRandomHistory = []; 
        if (appData.playJockeyRandomEnabled && appData.playJockeyCurrentVideo && appData.playJockeyPlaylist.length > 0) {
            if (appData.playJockeyPlaylist.length > 1 || appData.playJockeyRepeatState !== "off") {
                appData.playJockeyRandomHistory.push(appData.playJockeyCurrentVideo.id);
            }
        }
        updatePlayJockeyRandomButtonState();
        saveData();
    }

    function updatePlayJockeyRandomButtonState() {
        if (appData.playJockeyRandomEnabled) {
            DOM.playJockeyRandomBtn.textContent = 'Random: On';
            DOM.playJockeyRandomBtn.classList.add('random-on'); 
        } else {
            DOM.playJockeyRandomBtn.textContent = 'Random: Off';
            DOM.playJockeyRandomBtn.classList.remove('random-on');
        }
    }

    function cyclePlayJockeyRepeat() {
        if (appData.playJockeyRepeatState === "off") {
            appData.playJockeyRepeatState = "playlist";
        } else if (appData.playJockeyRepeatState === "playlist") {
            appData.playJockeyRepeatState = "song";
        } else { 
            appData.playJockeyRepeatState = "off";
        }
        appData.playJockeyRandomHistory = [];
        if (appData.playJockeyRandomEnabled && appData.playJockeyCurrentVideo && appData.playJockeyPlaylist.length > 0) {
             if (appData.playJockeyPlaylist.length > 1 || appData.playJockeyRepeatState !== "off") {
                 appData.playJockeyRandomHistory.push(appData.playJockeyCurrentVideo.id);
            }
        }
        updatePlayJockeyRepeatButtonState();
        saveData();
    }

    function updatePlayJockeyRepeatButtonState() {
        DOM.playJockeyRepeatBtn.classList.remove('repeat-on'); 
        switch (appData.playJockeyRepeatState) {
            case "off":
                DOM.playJockeyRepeatBtn.textContent = 'Repeat: Off';
                break;
            case "playlist":
                DOM.playJockeyRepeatBtn.textContent = 'Repeat: List';
                DOM.playJockeyRepeatBtn.classList.add('repeat-on');
                break;
            case "song":
                DOM.playJockeyRepeatBtn.textContent = 'Repeat: One';
                DOM.playJockeyRepeatBtn.classList.add('repeat-on');
                break;
        }
    }


    function openModal(modalId) {
        const modal = getById(modalId);
        if (modal) {
            modal.style.display = 'flex';
        } else {
            console.error(`Modal with ID "${modalId}" not found.`);
        }
    }

    function closeModal(modalId) {
        const modal = getById(modalId);
         if (modal) {
            modal.style.display = 'none';
        } else {
            console.error(`Modal with ID "${modalId}" not found for closing.`);
        }
    }

    document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>