<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life XP OS</title>
    <style>
        body {
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #3A6EA5;
            background-image: url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png');
            background-size: cover;
            background-position: 0% 0%;
            background-repeat: no-repeat;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
            position: relative;
        }
        .xp-window {
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            min-height: 30px;
            display: flex;
            flex-direction: column;
            position: absolute;
            overflow: hidden;
            z-index: 10;
        }
        .xp-window.disable-selection,
        .xp-window.disable-selection * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #000;
            cursor: grab;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
            user-select: none;
        }
        .title-bar:active {
            cursor: grabbing;
        }
        .title-bar-text {
            margin-left: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        .title-bar-controls button {
            background-color: #ECE9D8;
            border: 1px solid #000;
            width: 22px;
            height: 18px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-size: 12px;
            line-height: 16px;
            margin-left: 2px;
            box-shadow: 1px 1px 0px #FFF inset, -1px -1px 0px #808080 inset;
            padding: 0;
            text-align: center;
            cursor: default;
        }
        .title-bar-controls button:active:not(:disabled) {
            box-shadow: -1px -1px 0px #FFF inset, 1px 1px 0px #808080 inset;
        }
        .title-bar-controls button:disabled {
            color: #7F7F7F;
            cursor: default;
            opacity: 0.7;
        }
        .window-body {
            flex-grow: 1;
            opacity: 1;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.2s ease-out;
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
        }
        .xp-window.minimized .window-body,
        .xp-window.minimized .xp-menu-bar { /* Assuming xp-menu-bar might be generic */
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            opacity: 0 !important;
            overflow: hidden !important;
            border-top: none !important;
        }
        .xp-window.minimized {
            min-height: 28px !important;
            height: 28px !important;
            overflow: hidden;
        }
        .resize-handle {
            width: 12px;
            height: 12px;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            z-index: 10; /* Ensure it's above window body content but below other windows if overlapped */
            box-sizing: border-box;
            opacity: 0.6;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center center;
        }
        .resize-handle:hover {
            opacity: 1;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
        }
        .xp-window.true-maximized .resize-handle {
            display: none;
        }
        .desktop-icon-container { /* Generic container for icons loaded from apps */
            position: absolute;
            width: 90px;
            height: 100px;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 1px black;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 10px;
            box-sizing: border-box;
            z-index: 5;
        }
        .desktop-icon-container:active {
            cursor: grabbing;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000; /* Modals should be above most things */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #ECE9D8;
            margin: auto;
            padding: 0;
            border: 1px solid #000;
            width: 80%;
            max-width: 500px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
            display: flex;
            flex-direction: column;
        }
        .modal-title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            border-bottom: 1px solid #000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .modal-title-bar .close-button {
            color: white;
            font-size: 16px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-weight: normal;
            background: #E04343;
            border: 1px outset white;
            width: 22px;
            height: 18px;
            text-align: center;
            line-height: 16px;
            padding: 0;
            cursor: pointer;
        }
        .modal-title-bar .close-button:hover,
        .modal-title-bar .close-button:focus {
            background: #FF6363;
            text-decoration: none;
        }
         .modal-title-bar .close-button:active {
            border-style: inset;
        }
        .modal-body {
            padding: 15px;
            overflow-y: auto;
            flex-grow: 1;
        }
        .modal-body p { margin-top: 0; margin-bottom: 10px; }
        .modal-body label { display: block; margin-bottom: 5px; margin-top: 12px; }
        .modal-body input[type="text"],
        .modal-body input[type="number"],
        .modal-body textarea,
        .modal-body select {
            width: calc(100% - 12px); padding: 5px; margin-bottom: 10px;
            border: 1px solid #ACA899; box-sizing: border-box;
        }
        .modal-body input[type="file"] { margin-bottom: 5px; }
         .modal-body hr { border: 0; height: 1px; background: #ACA899; margin: 20px 0; }
        .modal-footer {
            padding: 10px 15px; text-align: right;
            background-color: #F0F0F0; border-top: 1px solid #ACA899;
            flex-shrink: 0;
        }
        @keyframes fadeIn {
            from {opacity: 0; transform: scale(0.9);}
            to {opacity: 1; transform: scale(1);}
        }
        /* Common button style that apps might use or extend */
        .xp-button {
            background-color: #ECE9D8;
            border: 1px outset #7F7F7F;
            padding: 5px 12px;
            min-width: 75px;
            text-align: center;
            cursor: pointer;
            margin: 2px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
        }
        .xp-button:active { border-style: inset; }
        .xp-button:hover { border-color: #005CFE; }
        .xp-button:disabled { color: #7F7F7F; border-color: #ACA899; cursor: default; }

        /* Styles for context menus that might be used by apps via OS API */
        .context-modal {
            display: none;
            position: fixed;
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            z-index: 2000; /* Above normal modals */
            padding: 3px 0;
            min-width: 120px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
        }
        .context-modal-item {
            padding: 5px 12px;
            cursor: default;
            color: black;
        }
        .context-modal-item:hover {
            background-color: #005CFE;
            color: white;
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-remote-config.js"></script>
</head>
<body>
    <div id="desktop"></div>

    <div id="changeBgImageModal" class="modal">
        <div class="modal-content" style="max-width: 550px;">
            <div class="modal-title-bar">
                <span>Change Background</span>
                <span class="close-button" data-modal-id="changeBgImageModal">r</span>
            </div>
            <div class="modal-body">
                <p>Choose a background type for the application:</p>
                <div>
                    <label for="newBgImageInput">1. Upload image file:</label>
                    <input type="file" id="newBgImageInput" accept="image/*">
                     <p><small>Max 5MB recommended for file uploads due to browser storage limits.</small></p>
                    <button id="uploadBgImageBtn" class="xp-button" style="margin-top: 5px;">Upload File & Apply</button>
                </div>
                <hr>
                <div>
                    <label for="bgImageUrlInput">2. Enter image URL:</label>
                    <input type="text" id="bgImageUrlInput" placeholder="https://example.com/image.png">
                    <p><small>Using a URL is recommended for very large images from the web.</small></p>
                    <button id="applyBgImageUrlBtn" class="xp-button" style="margin-top: 5px;">Apply URL</button>
                </div>
                <hr>
                <div>
                    <label>3. Pick a solid color:</label>
                    <div id="bgColorSwatchesContainer" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; justify-content: center;">
                    </div>
                     <p style="margin-top: 8px;"><small>Click a color swatch to apply it immediately.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="xp-button" data-modal-id="changeBgImageModal">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        "use strict";
        let YOUTUBE_API_KEY = "";
        let GEMINI_API_KEY = "";
        const ICON_GRID_SIZE = 25;
        const STANDARD_COLORS = [
            { name: 'Black', value: '#000000' }, { name: 'Silver', value: '#C0C0C0' },
            { name: 'Gray', value: '#808080' }, { name: 'White', value: '#FFFFFF' },
            { name: 'Maroon', value: '#800000' }, { name: 'Red', value: '#FF0000' },
            { name: 'Purple', value: '#800080' }, { name: 'Fuchsia', value: '#FF00FF' },
            { name: 'Green', value: '#008000' }, { name: 'Lime', value: '#00FF00' },
            { name: 'Olive', value: '#808000' }, { name: 'Yellow', value: '#FFFF00' },
            { name: 'Navy', value: '#000080' }, { name: 'Blue', value: '#0000FF' },
            { name: 'Teal', value: '#008080' }, { name: 'Aqua', value: '#00FFFF' },
            { name: 'Orange', value: '#FFA500' }, { name: 'Brown', value: '#A52A2A' },
            { name: 'Pink', value: '#FFC0CB' }, { name: 'Gold', value: '#FFD700' },
            { name: 'Dark Green', value: '#006400' }, { name: 'Light Blue', value: '#ADD8E6' },
            { name: 'Indigo', value: '#4B0082' }, { name: 'Violet', value: '#EE82EE' },
            { name: 'Coral', value: '#FF7F50' }, { name: 'Sky Blue', value: '#87CEEB' }
        ];
        const MODAL_IDS_OS = { CHANGE_BG_IMAGE: 'changeBgImageModal' };
        const firebaseConfig = {
          apiKey: "AIzaSyCVWUnnXiOvKRqbvngafdZC7DedEY-7vpg",
          authDomain: "lifexpapp-f5578.firebaseapp.com",
          projectId: "lifexpapp-f5578",
          storageBucket: "lifexpapp-f5578.appspot.com",
          messagingSenderId: "194098013746",
          appId: "1:194098013746:web:720ba296ee9e40dee37e2b"
        };
        firebase.initializeApp(firebaseConfig);
        const remoteConfig = firebase.remoteConfig();
        remoteConfig.defaultConfig = { 'youtube_api_key': '', 'gemini_api_key': '' };
        remoteConfig.settings.minimumFetchIntervalMillis = 3600000;

        const getById = (id) => document.getElementById(id);
        const desktopElement = getById('desktop');

        let osData = {
            windowStates: {},
            iconPositions: {},
            customBgImage: null,
            customBgColor: null,
            appSpecificData: {} // Centralized app data storage
        };
        const OS_STORAGE_KEY = 'lifeXpOsData_v1.0.0';

        let lastNormalStates = {};
        let highestZIndex = 10;
        let activeDragWindow = null;
        let activeResizeWindow = null;
        let dragOffsetX, dragOffsetY;
        let resizeInitialX, resizeInitialY, resizeInitialWidth, resizeInitialHeight;
        let activeDragIcon = null;
        let iconDragOffsetX, iconDragOffsetY;

        const appRegistry = {}; // Stores loaded app configurations and data

        const APP_FILES = [ // List of app files to load
            'xp-tracker.app.html',
            'jotter.app.html',
            'play-jockey.app.html',
            'gemini-chat.app.html',
            'pixel-craft.app.html',
            'capture.app.html'
        ];

        function applyCurrentBackgroundStyle() {
            if (osData.customBgColor) {
                document.body.style.backgroundImage = 'none';
                document.body.style.backgroundColor = osData.customBgColor;
            } else if (osData.customBgImage) {
                document.body.style.backgroundColor = ''; // Clear color if image is set
                document.body.style.backgroundImage = `url('${osData.customBgImage}')`;
            } else {
                // Default background
                document.body.style.backgroundColor = '#3A6EA5';
                document.body.style.backgroundImage = "url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png')";
            }
        }

        function populateColorSwatches() {
            const container = getById('bgColorSwatchesContainer');
            if (!container) return;
            STANDARD_COLORS.forEach(color => {
                const swatch = document.createElement('div');
                swatch.style.width = '30px';
                swatch.style.height = '30px';
                swatch.style.backgroundColor = color.value;
                swatch.style.border = '1px solid #7F7F7F';
                swatch.style.cursor = 'pointer';
                swatch.title = color.name;
                swatch.dataset.colorValue = color.value;
                swatch.classList.add('color-swatch-item'); // For potential hover/active effects
                container.appendChild(swatch);
            });
        }

        function bringToFront(windowElement) {
            if (!windowElement || !(windowElement instanceof HTMLElement)) return;
            highestZIndex++;
            windowElement.style.zIndex = highestZIndex;
            const windowId = windowElement.id;
            if (windowId && osData.windowStates[windowId]) { // Only save if it's a tracked window
                osData.windowStates[windowId].zIndex = highestZIndex;
                saveOsData();
            }
        }

        function initWindowInteractions(windowId, windowElement, titleBarElement, resizeHandleElement) {
            if (!windowElement || !titleBarElement || !(windowElement instanceof HTMLElement) || !(titleBarElement instanceof HTMLElement)) {
                 console.error("initWindowInteractions: Invalid elements for windowId:", windowId, "windowElement:", windowElement, "titleBarElement:", titleBarElement);
                 return;
            }

            windowElement.addEventListener('mousedown', (e) => {
                 if (e.target.closest('.desktop-icon-container') || e.target.closest('.context-modal') || e.target.closest('.xp-menu-bar')) return;
                 if (e.target === windowElement ||
                    (titleBarElement.contains(e.target) && !e.target.closest('button')) ||
                    (windowElement.querySelector('.window-body')?.contains(e.target) &&
                     !e.target.closest('button, input, select, textarea, .resize-handle, iframe, canvas, [contenteditable=true], .playjockey-playlist-item, .playjockey-tab'))
                 ) {
                     bringToFront(windowElement);
                 }
            }, true);

            titleBarElement.addEventListener('mousedown', (e) => {
                if (e.target.closest('button') || windowElement.classList.contains('true-maximized') || activeDragIcon) return;
                activeDragWindow = windowElement;
                dragOffsetX = e.clientX - activeDragWindow.offsetLeft;
                dragOffsetY = e.clientY - activeDragWindow.offsetTop;
                activeDragWindow.classList.add('disable-selection');
                
                const iframe = activeDragWindow.querySelector('iframe');
                if (iframe) iframe.style.pointerEvents = 'none';
                const canvasEl = activeDragWindow.querySelector('canvas');
                if (canvasEl) canvasEl.style.pointerEvents = 'none';


                document.addEventListener('mousemove', doDrag);
                document.addEventListener('mouseup', stopDragOrResize);
                bringToFront(windowElement);
            });

            if (resizeHandleElement && resizeHandleElement instanceof HTMLElement) {
                resizeHandleElement.addEventListener('mousedown', (e) => {
                    if (windowElement.classList.contains('true-maximized') || activeDragIcon) return;
                    activeResizeWindow = windowElement;
                    activeResizeWindow.classList.add('disable-selection');
                    resizeInitialX = e.clientX;
                    resizeInitialY = e.clientY;
                    resizeInitialWidth = activeResizeWindow.offsetWidth;
                    resizeInitialHeight = activeResizeWindow.offsetHeight;

                    const iframe = activeResizeWindow.querySelector('iframe');
                    if (iframe) iframe.style.pointerEvents = 'none';
                    const canvasEl = activeResizeWindow.querySelector('canvas');
                    if (canvasEl) canvasEl.style.pointerEvents = 'none';

                    document.addEventListener('mousemove', doResize);
                    document.addEventListener('mouseup', stopDragOrResize);
                    bringToFront(windowElement);
                });
            }
        }

        function doDrag(e) {
            if (!activeDragWindow) return;
            let newLeft = e.clientX - dragOffsetX;
            let newTop = e.clientY - dragOffsetY;
            const windowWidth = activeDragWindow.offsetWidth;
            const windowHeight = activeDragWindow.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            newLeft = Math.max(0, Math.min(newLeft, viewportWidth - windowWidth));
            newTop = Math.max(0, Math.min(newTop, viewportHeight - windowHeight));
            activeDragWindow.style.left = newLeft + 'px';
            activeDragWindow.style.top = newTop + 'px';
            if (osData.windowStates[activeDragWindow.id]) {
                osData.windowStates[activeDragWindow.id].userManuallySet = true;
            }
        }

        function doResize(e) {
            if (!activeResizeWindow) return;
            const windowId = activeResizeWindow.id;
            const appConfig = appRegistry[windowId.replace('Window', '')]; // Get app's config
            const currentMinWidth = appConfig?.minWidth || 200; // Use app-specific or default
            const currentMinHeight = appConfig?.minHeight || 150;

            let newWidth = resizeInitialWidth + (e.clientX - resizeInitialX);
            let newHeight = resizeInitialHeight + (e.clientY - resizeInitialY);
            activeResizeWindow.style.width = Math.max(currentMinWidth, newWidth) + 'px';
            activeResizeWindow.style.height = Math.max(currentMinHeight, newHeight) + 'px';
            if (osData.windowStates[windowId]) {
                osData.windowStates[windowId].userManuallySet = true;
            }
            // Call app-specific resize handler if it exists
            if (typeof appConfig?.onResize === 'function') {
                appConfig.onResize(activeResizeWindow);
            }
        }

        function stopDragOrResize() {
            let windowToSaveState = null;
            if (activeDragWindow) {
                activeDragWindow.classList.remove('disable-selection');
                const iframe = activeDragWindow.querySelector('iframe');
                if (iframe) iframe.style.pointerEvents = 'auto';
                const canvasEl = activeDragWindow.querySelector('canvas');
                if (canvasEl) canvasEl.style.pointerEvents = 'auto';
                windowToSaveState = activeDragWindow.id;
                activeDragWindow = null;
            }
            if (activeResizeWindow) {
                activeResizeWindow.classList.remove('disable-selection');
                const iframe = activeResizeWindow.querySelector('iframe');
                if (iframe) iframe.style.pointerEvents = 'auto';
                const canvasEl = activeResizeWindow.querySelector('canvas');
                if (canvasEl) canvasEl.style.pointerEvents = 'auto';
                windowToSaveState = activeResizeWindow.id;
                activeResizeWindow = null;
            }
            if (windowToSaveState) {
                saveWindowState(windowToSaveState);
            }
            document.removeEventListener('mousemove', doDrag);
            document.removeEventListener('mousemove', doResize);
            document.removeEventListener('mouseup', stopDragOrResize);
        }
        
        function findNonCollidingPosition(draggedIcon, initialX, initialY, allIcons) {
            const iconWidth = draggedIcon.offsetWidth || 90;
            const iconHeight = draggedIcon.offsetHeight || 100;

            const checkCollisionAt = (x, y, currentDraggedIcon) => {
                for (const otherIcon of allIcons) {
                    if (otherIcon === currentDraggedIcon || !otherIcon.style.left || !otherIcon.style.top) continue;
                    const otherLeft = parseInt(otherIcon.style.left, 10);
                    const otherTop = parseInt(otherIcon.style.top, 10);
                    const otherWidth = otherIcon.offsetWidth || 90;
                    const otherHeight = otherIcon.offsetHeight || 100;
                    if (x < otherLeft + otherWidth && x + iconWidth > otherLeft &&
                        y < otherTop + otherHeight && y + iconHeight > otherTop) {
                        return true; 
                    }
                }
                return false; 
            };

            let snappedX = Math.max(0, Math.min(Math.round(initialX / ICON_GRID_SIZE) * ICON_GRID_SIZE, document.body.clientWidth - iconWidth));
            let snappedY = Math.max(0, Math.min(Math.round(initialY / ICON_GRID_SIZE) * ICON_GRID_SIZE, document.body.clientHeight - iconHeight));

            if (!checkCollisionAt(snappedX, snappedY, draggedIcon)) {
                return { x: snappedX, y: snappedY };
            }
            
            let layer = 1;
            const maxAttemptsPerLayer = 50; 
            let totalAttempts = 0;

            while(totalAttempts < 500) { 
                for (let i = -layer; i <= layer; i++) {
                    for (let j = -layer; j <= layer; j++) {
                        if (Math.abs(i) !== layer && Math.abs(j) !== layer) continue; 

                        totalAttempts++;
                        if (totalAttempts >= 500) break;

                        let testX = snappedX + i * ICON_GRID_SIZE;
                        let testY = snappedY + j * ICON_GRID_SIZE;

                        testX = Math.max(0, Math.min(testX, document.body.clientWidth - iconWidth));
                        testY = Math.max(0, Math.min(testY, document.body.clientHeight - iconHeight));
                        
                        testX = Math.round(testX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
                        testY = Math.round(testY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

                        if (!checkCollisionAt(testX, testY, draggedIcon)) {
                            return { x: testX, y: testY };
                        }
                    }
                    if (totalAttempts >= 500) break;
                }
                layer++;
                if (layer * ICON_GRID_SIZE > Math.max(document.body.clientWidth, document.body.clientHeight) && totalAttempts > maxAttemptsPerLayer * 2) {
                     break; 
                }
            }
            return { x: initialX, y: initialY }; // Fallback if no good spot found
        }


        function handleIconMouseDown(e) {
            if (e.button !== 0 || activeDragWindow || activeResizeWindow) return;
            activeDragIcon = e.currentTarget;
            const windowId = activeDragIcon.dataset.windowId;
            const windowEl = getById(windowId);
            if (windowEl && windowEl.style.display !== 'none' && !windowEl.classList.contains('minimized')) {
                 bringToFront(windowEl);
            }
            iconDragOffsetX = e.clientX - activeDragIcon.offsetLeft;
            iconDragOffsetY = e.clientY - activeDragIcon.offsetTop;
            activeDragIcon.style.cursor = 'grabbing';
            activeDragIcon.style.zIndex = (highestZIndex + 1).toString(); // Ensure icon is on top while dragging
            document.addEventListener('mousemove', handleIconMouseMove);
            document.addEventListener('mouseup', handleIconMouseUp);
            e.preventDefault();
        }

        function handleIconMouseMove(e) {
            if (!activeDragIcon) return;
            let newX = e.clientX - iconDragOffsetX;
            let newY = e.clientY - iconDragOffsetY;
            const bodyRect = document.body.getBoundingClientRect();
            const iconWidth = activeDragIcon.offsetWidth || 90; // Use actual or default
            const iconHeight = activeDragIcon.offsetHeight || 100;
            newX = Math.max(0, Math.min(newX, bodyRect.width - iconWidth));
            newY = Math.max(0, Math.min(newY, bodyRect.height - iconHeight));
            activeDragIcon.style.left = newX + 'px';
            activeDragIcon.style.top = newY + 'px';
        }

        function handleIconMouseUp() {
            if (!activeDragIcon) return;
            activeDragIcon.style.zIndex = '5'; // Reset z-index
            let finalX = activeDragIcon.offsetLeft;
            let finalY = activeDragIcon.offsetTop;
            
            const allDesktopIcons = Array.from(desktopElement.querySelectorAll('.desktop-icon-container'));
            const { x: finalSnappedX, y: finalSnappedY } = findNonCollidingPosition(activeDragIcon, finalX, finalY, allDesktopIcons);

            activeDragIcon.style.left = finalSnappedX + 'px';
            activeDragIcon.style.top = finalSnappedY + 'px';

            const iconId = activeDragIcon.id;
            if (!osData.iconPositions) osData.iconPositions = {};
            osData.iconPositions[iconId] = { x: finalSnappedX, y: finalSnappedY };
            saveOsData();
            activeDragIcon.style.cursor = 'grab';
            activeDragIcon = null;
            document.removeEventListener('mousemove', handleIconMouseMove);
            document.removeEventListener('mouseup', handleIconMouseUp);
        }

        function handleIconDoubleClick(e) {
            const iconElement = e.currentTarget;
            const appId = iconElement.dataset.appId;
            const appConfig = appRegistry[appId];
            if (!appConfig) {
                console.error("No appConfig found for appId:", appId);
                return;
            }

            let windowElement = getById(appConfig.windowId);

            if (!windowElement) {
                const windowTemplate = appConfig.windowTemplate;
                if (!windowTemplate || !(windowTemplate instanceof HTMLTemplateElement) || !(windowTemplate.content instanceof DocumentFragment)) {
                    console.error(`Invalid windowTemplate or content for ${appId}`);
                    return;
                }

                const clonedFragment = windowTemplate.content.cloneNode(true);
                // The main window div inside the template should have the ID appConfig.windowId
                let actualWindowElement = clonedFragment.querySelector('#' + appConfig.windowId); 

                if (!actualWindowElement || typeof actualWindowElement.querySelector !== 'function') {
                    // Fallback: try to get the first element child if ID query fails
                    for (let i = 0; i < clonedFragment.childNodes.length; i++) {
                        if (clonedFragment.childNodes[i].nodeType === Node.ELEMENT_NODE) {
                            actualWindowElement = clonedFragment.childNodes[i];
                            break;
                        }
                    }
                    if (!actualWindowElement || typeof actualWindowElement.querySelector !== 'function') {
                        console.error(`Could not extract a valid window element with ID ${appConfig.windowId} or as first child from template for ${appId}.`);
                        console.log("Template's innerHTML:", appConfig.windowTemplate.innerHTML);
                        const tempDivLog = document.createElement('div');
                        tempDivLog.appendChild(clonedFragment.cloneNode(true));
                        console.log("Cloned fragment structure for " + appId + ":", tempDivLog.innerHTML);
                        return;
                    }
                }
                windowElement = actualWindowElement;
                document.body.appendChild(windowElement);
                
                const titleBar = windowElement.querySelector('.title-bar');
                const resizeHandle = windowElement.querySelector('.resize-handle');
                if (!titleBar) console.error("Title bar not found in window for", appId, "Template:", windowTemplate.innerHTML);
                
                initWindowInteractions(appConfig.windowId, windowElement, titleBar, resizeHandle);
                
                const minimizeBtn = windowElement.querySelector(`[data-app-action="minimize"]`);
                const maximizeBtn = windowElement.querySelector(`[data-app-action="maximize"]`);
                const closeBtn = windowElement.querySelector(`[data-app-action="close"]`);

                if(minimizeBtn) minimizeBtn.addEventListener('click', () => minimizeWindow(appConfig.windowId));
                if(maximizeBtn) maximizeBtn.addEventListener('click', () => maximizeWindow(appConfig.windowId));
                if(closeBtn) closeBtn.addEventListener('click', () => closeWindow(appConfig.windowId));

                if (!osData.appSpecificData || !osData.appSpecificData[appId]) {
                    osData.appSpecificData = osData.appSpecificData || {};
                    osData.appSpecificData[appId] = {}; 
                }
                appRegistry[appId].appData = osData.appSpecificData[appId];

                if (appConfig.script) {
                    try {
                        const scriptContext = {
                            appWindow: windowElement,
                            appData: appRegistry[appId].appData,
                            os: createOsApiForApp(appId),
                            onOpen: null, onClose: null, onMinimize: null, onRestore: null, onResize: null
                        };
                        const scriptFunction = new Function('appWindow', 'appData', 'os', appConfig.script);
                        scriptFunction.call(scriptContext, scriptContext.appWindow, scriptContext.appData, scriptContext.os);
                        
                        if(typeof scriptContext.onOpen === 'function') appConfig.onOpen = scriptContext.onOpen;
                        if(typeof scriptContext.onClose === 'function') appConfig.onClose = scriptContext.onClose;
                        if(typeof scriptContext.onMinimize === 'function') appConfig.onMinimize = scriptContext.onMinimize;
                        if(typeof scriptContext.onRestore === 'function') appConfig.onRestore = scriptContext.onRestore;
                        if(typeof scriptContext.onResize === 'function') appConfig.onResize = scriptContext.onResize;

                    } catch (err) {
                        console.error(`Error executing script for ${appId}:`, err);
                    }
                }
                if (typeof appConfig.onOpen === 'function') {
                    appConfig.onOpen(windowElement, appRegistry[appId].appData, createOsApiForApp(appId));
                }
                restoreWindowState(appConfig.windowId, appConfig);

            } else { // Window element already exists
                 if (typeof windowElement.querySelector !== 'function') { // Check if it's a valid element
                    console.error("Existing windowElement for", appConfig.windowId, "is not a valid DOM element:", windowElement);
                    windowElement.remove(); // Remove corrupted element
                    if (osData.windowStates[appConfig.windowId]) delete osData.windowStates[appConfig.windowId];
                    handleIconDoubleClick({ currentTarget: iconElement }); // Retry
                    return;
                }
            }
            
            let state = osData.windowStates[appConfig.windowId];
            if (!state) {
                restoreWindowState(appConfig.windowId, appConfig);
                state = osData.windowStates[appConfig.windowId];
            }
             if (!state) {
                console.error("Window state could not be initialized for", appConfig.windowId);
                return;
            }

            if (state.hiddenByUser || windowElement.style.display === 'none') {
                state.hiddenByUser = false;
                windowElement.style.display = 'flex';
                if (state.minimized) { 
                    state.minimized = false;
                    windowElement.classList.remove('minimized');
                }
                restoreWindowState(appConfig.windowId, appConfig); 
                if (typeof appConfig.onRestore === 'function') {
                    appConfig.onRestore(windowElement);
                } else if (typeof appConfig.onOpen === 'function' && !state.minimized) {
                    // If it was just hidden, not minimized, onOpen might be more appropriate
                    // But onRestore is generally for making it visible again from minimized or restoring size
                    appConfig.onOpen(windowElement, appRegistry[appId].appData, createOsApiForApp(appId));
                }
            } else if (state.minimized) {
                maximizeWindow(appConfig.windowId); 
            }
            
            bringToFront(windowElement);
            updateMinMaxButtonStates(appConfig.windowId, windowElement);
            saveWindowState(appConfig.windowId);
        }
        
        function createOsApiForApp(appId) {
            return {
                getGlobalConfig: (key) => {
                    if (key === 'YOUTUBE_API_KEY') return YOUTUBE_API_KEY;
                    if (key === 'GEMINI_API_KEY') return GEMINI_API_KEY;
                    return undefined;
                },
                getAppWindow: () => getById(appRegistry[appId].windowId),
                getAppData: () => appRegistry[appId].appData,
                saveAppData: () => {
                    // osData.appSpecificData is already the reference to appRegistry[appId].appData
                    // So just saving osData is enough.
                    saveOsData();
                },
                openModal: (modalElementOrSelector) => {
                    let modal = typeof modalElementOrSelector === 'string' 
                        ? (appRegistry[appId] && getById(appRegistry[appId].windowId)?.querySelector('#'+modalElementOrSelector) || getById(modalElementOrSelector)) 
                        : modalElementOrSelector;
                    if (modal && modal.classList.contains('modal')) {
                        modal.style.display = 'flex';
                        bringToFront(modal); // Modals should be on top
                    } else {
                        console.warn("OS API: Modal not found or not a modal:", modalElementOrSelector);
                    }
                },
                closeModal: (modalElementOrSelector) => {
                     let modal = typeof modalElementOrSelector === 'string' 
                        ? (appRegistry[appId] && getById(appRegistry[appId].windowId)?.querySelector('#'+modalElementOrSelector) || getById(modalElementOrSelector)) 
                        : modalElementOrSelector;
                    if (modal && modal.classList.contains('modal')) {
                        modal.style.display = 'none';
                    } else {
                         console.warn("OS API: Modal to close not found or not a modal:", modalElementOrSelector);
                    }
                },
                bringToFront: (element) => bringToFront(element),
                decodeHtmlEntities: (text) => {
                    if (typeof text !== 'string') return text;
                    const textarea = document.createElement('textarea');
                    textarea.innerHTML = text;
                    return textarea.value;
                },
                getById: (id) => document.getElementById(id)
            };
        }


        function minimizeWindow(windowId) {
            const appWindow = getById(windowId);
            if (!appWindow || appWindow.classList.contains('minimized')) return;
            const state = osData.windowStates[windowId];
            if (!state) return;

            state.minimized = true;
            if (appWindow.classList.contains('true-maximized')) {
                state.wasMaximizedBeforeMinimize = true;
                if (lastNormalStates[windowId]) {
                    state.width = parseInt(lastNormalStates[windowId].width);
                    state.height = parseInt(lastNormalStates[windowId].height);
                    state.x = parseInt(lastNormalStates[windowId].left);
                    state.y = parseInt(lastNormalStates[windowId].top);
                }
            } else {
                state.wasMaximizedBeforeMinimize = false;
                state.width = appWindow.offsetWidth;
                state.height = appWindow.offsetHeight;
                state.x = appWindow.offsetLeft;
                state.y = appWindow.offsetTop;
            }
            appWindow.classList.remove('true-maximized');
            appWindow.classList.add('minimized');
            
            const appConfig = appRegistry[windowId.replace('Window', '')];
            if (appConfig && typeof appConfig.onMinimize === 'function') {
                appConfig.onMinimize(appWindow);
            }

            updateMinMaxButtonStates(windowId, appWindow);
            saveWindowState(windowId);
        }

        function maximizeWindow(windowId) {
            const appWindow = getById(windowId);
            if (!appWindow) return;
            const state = osData.windowStates[windowId];
            if (!state) return;

            const isMinimized = appWindow.classList.contains('minimized');
            let currentLastNormal = lastNormalStates[windowId] || {};
            const appConfig = appRegistry[windowId.replace('Window', '')];
            const minW = appConfig?.minWidth || 200;
            const minH = appConfig?.minHeight || 150;


            if (isMinimized) {
                appWindow.classList.remove('minimized');
                state.minimized = false;
                const wasMaximized = state.wasMaximizedBeforeMinimize;
                delete state.wasMaximizedBeforeMinimize;

                if (wasMaximized) {
                    appWindow.style.width = '100vw';
                    appWindow.style.height = '100vh';
                    appWindow.style.top = '0px';
                    appWindow.style.left = '0px';
                    appWindow.classList.add('true-maximized');
                    state.maximized = true;
                } else {
                    appWindow.style.width = Math.max(minW, state.width || parseInt(currentLastNormal.width) || minW) + 'px';
                    appWindow.style.height = Math.max(minH, state.height || parseInt(currentLastNormal.height) || minH) + 'px';
                    appWindow.style.left = (state.x ?? parseInt(currentLastNormal.left) ?? 50) + 'px';
                    appWindow.style.top = (state.y ?? parseInt(currentLastNormal.top) ?? 50) + 'px';
                    state.maximized = false;
                }
                 if (appConfig && typeof appConfig.onRestore === 'function') {
                    appConfig.onRestore(appWindow);
                }

            } else if (appWindow.classList.contains('true-maximized')) {
                if (currentLastNormal.width && currentLastNormal.height) {
                    appWindow.style.width = currentLastNormal.width;
                    appWindow.style.height = currentLastNormal.height;
                    appWindow.style.top = currentLastNormal.top;
                    appWindow.style.left = currentLastNormal.left;
                    state.width = parseInt(currentLastNormal.width);
                    state.height = parseInt(currentLastNormal.height);
                    state.x = parseInt(currentLastNormal.left);
                    state.y = parseInt(currentLastNormal.top);
                } else {
                    setWindowDefaults(windowId, appWindow, appConfig);
                }
                appWindow.classList.remove('true-maximized');
                state.maximized = false;
                state.userManuallySet = true;
            } else {
                lastNormalStates[windowId] = {
                    width: appWindow.style.width || (appWindow.offsetWidth + 'px'),
                    height: appWindow.style.height || (appWindow.offsetHeight + 'px'),
                    top: appWindow.style.top || (appWindow.offsetTop + 'px'),
                    left: appWindow.style.left || (appWindow.offsetLeft + 'px')
                };
                appWindow.style.width = '100vw';
                appWindow.style.height = '100vh';
                appWindow.style.top = '0px';
                appWindow.style.left = '0px';
                appWindow.classList.add('true-maximized');
                state.maximized = true;
                state.userManuallySet = false;
            }
            updateMinMaxButtonStates(windowId, appWindow);
            saveWindowState(windowId);
            if (appConfig && typeof appConfig.onResize === 'function' && !isMinimized) { // Call onResize if window changed size
                 appConfig.onResize(appWindow);
            }
        }
        
        function closeWindow(windowId) {
            const appWindow = getById(windowId);
            if (!appWindow) return;
            let state = osData.windowStates[windowId];
            if (state) {
                state.hiddenByUser = true;
            } else { // Should not happen if window exists, but as a fallback
                osData.windowStates[windowId] = { hiddenByUser: true };
            }
            appWindow.style.display = 'none';
            const appConfig = appRegistry[windowId.replace('Window', '')];
            if (appConfig && typeof appConfig.onClose === 'function') {
                appConfig.onClose(appWindow);
            }
            saveWindowState(windowId);
        }


        function updateMinMaxButtonStates(windowId, win) {
            if (!win) win = getById(windowId);
            if (!win || !(win instanceof HTMLElement)) return;

            const minimizeBtn = win.querySelector(`[data-app-action="minimize"]`);
            const maximizeBtn = win.querySelector(`[data-app-action="maximize"]`);
            if (!minimizeBtn || !maximizeBtn) return;

            const isMinimized = win.classList.contains('minimized');
            const isTrueMaximized = win.classList.contains('true-maximized');

            minimizeBtn.disabled = isMinimized;
            maximizeBtn.disabled = false; 

            if (isMinimized) {
                maximizeBtn.textContent = '1'; 
                maximizeBtn.title = "Restore";
            } else if (isTrueMaximized) {
                maximizeBtn.textContent = '2'; 
                maximizeBtn.title = "Restore Down";
            } else {
                maximizeBtn.textContent = '1'; 
                maximizeBtn.title = "Maximize";
            }
        }
        
        function setWindowDefaults(windowId, appWindow, appConfig, isBrowserResize = false) {
            if (!appWindow || !(appWindow instanceof HTMLElement) || appWindow.classList.contains('minimized')) return;
            if (appWindow.classList.contains('true-maximized') && !isBrowserResize) {
                appWindow.style.width = '100vw';
                appWindow.style.height = '100vh';
                appWindow.style.top = '0px';
                appWindow.style.left = '0px';
                return;
            }

            const state = osData.windowStates[windowId];
            if (!state) return;

            const hasValidSavedSize = state.width && state.width > 0 && state.height && state.height > 0;
            const hasValidSavedPosition = state.x != null && state.y != null;

            const currentMinWidth = appConfig?.minWidth || 200;
            const currentMinHeight = appConfig?.minHeight || 150;
            const defaultWidth = appConfig?.defaultWidth || 500;
            const defaultHeight = appConfig?.defaultHeight || 400;
            // Default positioning: cascade slightly based on number of apps loaded
            const appIndex = Object.keys(appRegistry).indexOf(appConfig.id);
            const defaultOffsetX = appConfig?.defaultOffsetX ?? ((appIndex % 5) * 50 + 20);
            const defaultOffsetY = appConfig?.defaultOffsetY ?? ((appIndex % 5) * 50 + 20);


            if (isBrowserResize || !state.userManuallySet || !hasValidSavedSize || !hasValidSavedPosition) {
                let newWidth = defaultWidth;
                let newHeight = defaultHeight;
                newWidth = Math.max(currentMinWidth, newWidth);
                newHeight = Math.max(currentMinHeight, newHeight);

                let newLeft = defaultOffsetX;
                let newTop = defaultOffsetY;

                // Ensure window is within viewport bounds
                newTop = Math.max(10, Math.min(newTop, window.innerHeight - newHeight - 10));
                newLeft = Math.max(10, Math.min(newLeft, window.innerWidth - newWidth - 10));
                if (window.innerHeight <= newHeight + 20) newTop = 10; // If viewport too small, stick to top
                if (window.innerWidth <= newWidth + 20) newLeft = 10;  // If viewport too small, stick to left


                appWindow.style.width = newWidth + 'px';
                appWindow.style.height = newHeight + 'px';
                appWindow.style.left = newLeft + 'px';
                appWindow.style.top = newTop + 'px';
                
                state.width = newWidth;
                state.height = newHeight;
                state.x = newLeft;
                state.y = newTop;
                state.userManuallySet = false; // Reset since we are setting defaults
            }
        }


        function saveWindowState(windowId) {
            const win = getById(windowId);
            if (!win) return;
            let state = osData.windowStates[windowId];
            if (!state) {
                osData.windowStates[windowId] = {}; // Initialize if not present
                state = osData.windowStates[windowId];
            }
            state.hiddenByUser = (win.style.display === 'none');
            state.minimized = win.classList.contains('minimized');
            state.maximized = win.classList.contains('true-maximized');
            state.zIndex = parseInt(win.style.zIndex) || highestZIndex; // Ensure zIndex is saved

            // Only save position/size if not minimized or maximized, to preserve normal state
            if (!state.minimized && !state.maximized) {
                state.x = win.offsetLeft;
                state.y = win.offsetTop;
                state.width = win.offsetWidth;
                state.height = win.offsetHeight;
            }
            saveOsData();
        }

        function restoreWindowState(windowId, appConfig) {
            const win = getById(windowId);
            if (!win || !(win instanceof HTMLElement)) {
                console.warn("restoreWindowState: Window element not found or invalid for ID:", windowId);
                return;
            }

            let state = osData.windowStates[windowId];
            const defaultStateTemplate = {
                x: null, y: null, width: null, height: null,
                maximized: false, minimized: false, zIndex: highestZIndex + 1,
                userManuallySet: false, hiddenByUser: true 
            };

            if (!state) {
                osData.windowStates[windowId] = { ...defaultStateTemplate };
                state = osData.windowStates[windowId];
            } else {
                 // Ensure all properties from template exist if loading older saved data
                 state = { ...defaultStateTemplate, ...state };
                 osData.windowStates[windowId] = state;
            }
            
            if (state.hiddenByUser) {
                win.style.display = 'none';
            } else {
                win.style.display = 'flex';
            }

            let loadedZ = state.zIndex;
            if (loadedZ <= 5) loadedZ = highestZIndex + 1; // Ensure it's above icons
            win.style.zIndex = loadedZ;
            state.zIndex = loadedZ; // Save the potentially updated zIndex
            highestZIndex = Math.max(highestZIndex, loadedZ);

            if (state.minimized) {
                win.classList.add('minimized');
                win.classList.remove('true-maximized');
            } else if (state.maximized) {
                win.classList.add('true-maximized');
                win.classList.remove('minimized');
                win.style.width = '100vw';
                win.style.height = '100vh';
                win.style.top = '0px';
                win.style.left = '0px';
                // Ensure lastNormalStates has a fallback if state.width/height are null
                const lnWidth = state.width ? Math.max(appConfig?.minWidth || 200, state.width) : (appConfig?.defaultWidth || 500);
                const lnHeight = state.height ? Math.max(appConfig?.minHeight || 150, state.height) : (appConfig?.defaultHeight || 400);
                const lnTop = state.y ?? appConfig?.defaultOffsetY ?? 50;
                const lnLeft = state.x ?? appConfig?.defaultOffsetX ?? 50;

                lastNormalStates[windowId] = {
                    width: lnWidth + 'px', height: lnHeight + 'px',
                    top: lnTop + 'px', left: lnLeft + 'px'
                };
            } else { // Normal state
                win.classList.remove('minimized', 'true-maximized');
                if (state.userManuallySet && state.width != null && state.height != null && state.x != null && state.y != null) {
                    const currentMinWidth = appConfig?.minWidth || 200;
                    const currentMinHeight = appConfig?.minHeight || 150;
                    win.style.left = state.x + 'px';
                    win.style.top = state.y + 'px';
                    win.style.width = Math.max(currentMinWidth, state.width) + 'px';
                    win.style.height = Math.max(currentMinHeight, state.height) + 'px';
                } else { // Not manually set, or missing some state properties
                    if (!state.hiddenByUser) { // Only apply defaults if it's supposed to be visible
                         setWindowDefaults(windowId, win, appConfig);
                    }
                }
            }
            updateMinMaxButtonStates(windowId, win);
        }

        function saveOsData() {
            try {
                localStorage.setItem(OS_STORAGE_KEY, JSON.stringify(osData));
            } catch (error) {
                console.error("Could not save OS data:", error);
                // Potentially alert user if storage is full
                if (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                    alert("Storage limit exceeded. OS settings might not be saved.");
                }
            }
        }

        function loadOsData() {
            const storedData = localStorage.getItem(OS_STORAGE_KEY);
            const defaultOsData = {
                windowStates: {}, iconPositions: {},
                customBgImage: null, customBgColor: null,
                appSpecificData: {} // Initialize appSpecificData
            };
            if (storedData) {
                try {
                    const parsed = JSON.parse(storedData);
                    // Merge deeply for windowStates and iconPositions to preserve defaults for new apps
                    osData = { ...defaultOsData, ...parsed };
                    osData.windowStates = { ...defaultOsData.windowStates, ...(parsed.windowStates || {}) };
                    osData.iconPositions = { ...defaultOsData.iconPositions, ...(parsed.iconPositions || {}) };
                    osData.appSpecificData = { ...defaultOsData.appSpecificData, ...(parsed.appSpecificData || {}) };

                } catch (e) {
                    console.error("Error parsing OS data, using defaults.", e);
                    osData = defaultOsData; // Fallback to complete defaults
                }
            } else {
                osData = defaultOsData;
            }
        }
        
        function openModal(modalId) {
            const modal = getById(modalId);
            if (modal) modal.style.display = 'flex';
        }
        function closeModal(modalId) {
            const modal = getById(modalId);
            if (modal) modal.style.display = 'none';
        }

        async function loadApp(appFile) {
            try {
                const response = await fetch(appFile);
                if (!response.ok) {
                    console.error(`Failed to load app file: ${appFile}, status: ${response.status}`);
                    return;
                }
                const html = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');

                const appIdFromBody = doc.body.dataset.appId; // Get appId from body data attribute
                if (!appIdFromBody) {
                    console.error(`App ID missing in body data-app-id of ${appFile}`);
                    return;
                }
                const appId = appIdFromBody;


                const iconTemplate = doc.getElementById(`${appId}-icon-template`);
                const windowTemplate = doc.getElementById(`${appId}-window-template`);
                const scriptElement = doc.getElementById(`${appId}-script`);
                const appConfigElement = doc.getElementById(`${appId}-config`);


                if (!iconTemplate || !windowTemplate) {
                    console.error(`Icon or window template missing for ${appId} in ${appFile}`);
                    return;
                }
                
                let appConfigData = { // Base defaults for an app
                    id: appId,
                    windowId: `${appId}Window`,
                    iconId: `${appId}Icon`,
                    minWidth: 200, minHeight: 150,
                    defaultWidth: 500, defaultHeight: 400,
                    defaultOffsetX: 50, defaultOffsetY: 50
                };

                if (appConfigElement) {
                    try {
                        const jsonData = JSON.parse(appConfigElement.textContent);
                        appConfigData = {...appConfigData, ...jsonData}; // Merge with JSON config
                    } catch (e) {
                        console.error(`Error parsing config for ${appId}:`, e);
                    }
                }


                const iconContainer = document.createElement('div');
                iconContainer.id = appConfigData.iconId;
                iconContainer.className = 'desktop-icon-container';
                iconContainer.innerHTML = iconTemplate.innerHTML;
                iconContainer.dataset.appId = appId; // Store appId on the icon
                iconContainer.dataset.windowId = appConfigData.windowId; // Store windowId for dblclick
                
                const iconPos = osData.iconPositions[iconContainer.id];
                // Simple default positioning for new icons
                const appCount = Object.keys(appRegistry).length;
                const defaultX = (appCount % 8) * (90 + 10); // 90px width + 10px gap
                const defaultY = Math.floor(appCount / 8) * (100 + 10); // 100px height + 10px gap


                if (iconPos && typeof iconPos.x === 'number' && typeof iconPos.y === 'number') {
                    iconContainer.style.left = iconPos.x + 'px';
                    iconContainer.style.top = iconPos.y + 'px';
                } else {
                     const allIcons = Array.from(desktopElement.querySelectorAll('.desktop-icon-container'));
                     allIcons.push(iconContainer); // Temporarily add for collision check
                     const { x: finalX, y: finalY } = findNonCollidingPosition(iconContainer, defaultX, defaultY, allIcons);
                     iconContainer.style.left = finalX + 'px';
                     iconContainer.style.top = finalY + 'px';
                     osData.iconPositions[iconContainer.id] = { x: finalX, y: finalY }; // Save new position
                }


                iconContainer.addEventListener('mousedown', handleIconMouseDown);
                iconContainer.addEventListener('dblclick', handleIconDoubleClick);
                desktopElement.appendChild(iconContainer);

                // Store app configuration and its data (loaded from osData or default)
                appRegistry[appId] = {
                    ...appConfigData, // Merged defaults and JSON config
                    iconTemplate: iconTemplate,
                    windowTemplate: windowTemplate,
                    script: scriptElement ? scriptElement.textContent : null,
                    appData: (osData.appSpecificData && osData.appSpecificData[appId]) || {} // Load saved app data or init empty
                };
                
                // If window was open previously, attempt to reopen it
                if (osData.windowStates[appConfigData.windowId] && !osData.windowStates[appConfigData.windowId].hiddenByUser) {
                    handleIconDoubleClick({ currentTarget: iconContainer }); // Simulate double click to open/restore
                }


            } catch (error) {
                console.error(`Error loading or parsing app ${appFile}:`, error);
            }
        }

        async function loadAllApps() {
            for (const appFile of APP_FILES) {
                await loadApp(appFile);
            }
            saveOsData(); // Save any new default icon positions or initial appData structures
        }
        
        function initOsEventListeners() {
            document.body.addEventListener('contextmenu', function(event) {
                if (event.target === document.body || event.target === desktopElement) {
                    event.preventDefault();
                    getById('newBgImageInput').value = null; // Clear file input
                    getById('bgImageUrlInput').value = ''; // Clear URL input
                    openModal(MODAL_IDS_OS.CHANGE_BG_IMAGE);
                }
            });
            getById('uploadBgImageBtn').addEventListener('click', function() {
                const file = getById('newBgImageInput').files[0];
                if (file) {
                    if (file.size > 5 * 1024 * 1024) alert("Image file is large (over 5MB). This might exceed browser storage limits when saved. Try a smaller file or use the URL option for large images.");
                    const reader = new FileReader();
                    reader.onloadend = function() {
                        document.body.style.backgroundColor = ''; // Clear color
                        document.body.style.backgroundImage = `url('${reader.result}')`;
                        osData.customBgImage = reader.result;
                        osData.customBgColor = null; // Clear color preference
                        saveOsData();
                        closeModal(MODAL_IDS_OS.CHANGE_BG_IMAGE);
                    }
                    reader.onerror = function() { alert("Error reading image file."); }
                    reader.readAsDataURL(file);
                } else {
                    alert("Please select an image file first.");
                }
            });
            getById('applyBgImageUrlBtn').addEventListener('click', function() {
                const imageUrl = getById('bgImageUrlInput').value.trim();
                if (imageUrl) {
                    try {
                        new URL(imageUrl); // Basic URL validation
                        document.body.style.backgroundColor = ''; // Clear color
                        document.body.style.backgroundImage = `url('${imageUrl}')`;
                        osData.customBgImage = imageUrl;
                        osData.customBgColor = null; // Clear color preference
                        saveOsData();
                        closeModal(MODAL_IDS_OS.CHANGE_BG_IMAGE);
                    } catch (e) {
                        alert("Invalid image URL provided. Please enter a complete and valid URL (e.g., https://example.com/image.png).");
                    }
                } else {
                    alert("Please enter an image URL.");
                }
            });
            getById('bgColorSwatchesContainer').addEventListener('click', function(event) {
                if (event.target.classList.contains('color-swatch-item')) {
                    const selectedColor = event.target.dataset.colorValue;
                    if (selectedColor) {
                        document.body.style.backgroundImage = 'none'; // Clear image
                        document.body.style.backgroundColor = selectedColor;
                        osData.customBgColor = selectedColor;
                        osData.customBgImage = null; // Clear image preference
                        saveOsData();
                        closeModal(MODAL_IDS_OS.CHANGE_BG_IMAGE);
                    }
                }
            });
            
            // Generic modal close buttons (for OS modals)
            document.querySelectorAll(`#${MODAL_IDS_OS.CHANGE_BG_IMAGE} .close-button, #${MODAL_IDS_OS.CHANGE_BG_IMAGE} .xp-button[data-modal-id]`).forEach(button => {
                button.addEventListener('click', (event) => {
                    const modalId = event.target.dataset.modalId || event.target.closest('.modal').id;
                    if (modalId) closeModal(modalId);
                });
            });

            window.addEventListener('resize', () => {
                Object.values(appRegistry).forEach(appConfig => {
                    const win = getById(appConfig.windowId);
                    if (win && win.style.display !== 'none' && !(win instanceof SVGElement)) { // Check if it's an HTMLElement
                         setWindowDefaults(appConfig.windowId, win, appConfig, true); // Pass true for browser resize
                         if(typeof appConfig.onResize === 'function') appConfig.onResize(win);
                    }
                });
                saveOsData(); // Save potentially adjusted window states
            });
        }

        async function main() {
            loadOsData(); // Load OS and all app data first
            applyCurrentBackgroundStyle();
            populateColorSwatches();
            initOsEventListeners();

            try {
                await remoteConfig.fetchAndActivate();
                YOUTUBE_API_KEY = remoteConfig.getString('youtube_api_key');
                GEMINI_API_KEY = remoteConfig.getString('gemini_api_key');
            } catch (err) {
                console.error("Firebase Remote Config failed to load. API keys might be unavailable.", err);
            }
            
            await loadAllApps(); // This will create icons and restore open windows
            
            // Ensure highestZIndex is correctly set after all windows might have been restored
            let maxLoadedZ = highestZIndex;
             Object.values(osData.windowStates).forEach(state => {
                if (state && state.zIndex) {
                    maxLoadedZ = Math.max(maxLoadedZ, parseInt(state.zIndex));
                }
            });
            highestZIndex = maxLoadedZ;
        }

        document.addEventListener('DOMContentLoaded', main);
    </script>
</body>
</html>
