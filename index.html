<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life XP</title>
    <style>
        body {
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #3A6EA5;
            background-image: url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png');
            background-size: cover;
            background-position: 0% 0%;
            background-repeat: no-repeat;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        .xp-window {
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            min-height: 30px;
            display: flex;
            flex-direction: column;
            position: absolute;
            overflow: hidden;
        }
        .xp-window.disable-selection,
        .xp-window.disable-selection * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #000;
            cursor: grab;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
            user-select: none;
        }
        .title-bar:active {
            cursor: grabbing;
        }
        .title-bar-text {
            margin-left: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }
        .title-bar-controls button {
            background-color: #ECE9D8;
            border: 1px solid #000;
            width: 22px;
            height: 18px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-size: 12px;
            line-height: 16px;
            margin-left: 2px;
            box-shadow: 1px 1px 0px #FFF inset, -1px -1px 0px #808080 inset;
            padding: 0;
            text-align: center;
            cursor: default;
        }
        .title-bar-controls button:active:not(:disabled) {
            box-shadow: -1px -1px 0px #FFF inset, 1px 1px 0px #808080 inset;
        }
        .title-bar-controls button:disabled {
            color: #7F7F7F;
            cursor: default;
            opacity: 0.7;
        }
        .window-body {
            flex-grow: 1;
            opacity: 1;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.2s ease-out;
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
        }
        .window-body iframe {
            width: 100%;
            height: 100%;
            border: none;
            display: block;
        }
        .xp-window.minimized .window-body,
        .xp-window.minimized .xp-menu-bar {
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            opacity: 0 !important;
            overflow: hidden !important;
            border-top: none !important;
        }
        .xp-window.minimized {
            min-height: 28px !important;
            height: 28px !important;
            overflow: hidden;
        }
        .resize-handle {
            width: 12px;
            height: 12px;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            z-index: 10;
            box-sizing: border-box;
            opacity: 0.6;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center center;
        }
        .resize-handle:hover {
            opacity: 1;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
        }
        .xp-window.true-maximized .resize-handle {
            display: none;
        }
        .desktop-icon {
            position: absolute;
            width: 90px;
            height: 100px;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 1px black;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 10px;
            box-sizing: border-box;
            z-index: 5;
        }
        .desktop-icon:active {
            cursor: grabbing;
        }
        .desktop-icon .icon-image {
            font-size: 48px;
            line-height: 1;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
            height: 50px;
        }
        .desktop-icon .icon-label {
            font-size: 12px;
            font-weight: normal;
            word-wrap: break-word;
            max-width: 100%;
        }
        .desktop-icon.playJockeyIconStyle .icon-image-base {
            filter: hue-rotate(140deg) saturate(1000%) brightness(70%);
        }
        .desktop-icon.playJockeyIconStyle .icon-image-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            filter: hue-rotate(140deg) saturate(1000%);
            mix-blend-mode: luminosity;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #ECE9D8;
            margin: auto;
            padding: 0;
            border: 1px solid #000;
            width: 80%;
            max-width: 550px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
            display: flex;
            flex-direction: column;
        }
        .modal-title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            border-bottom: 1px solid #000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .modal-title-bar .close-button {
            color: white;
            font-size: 16px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-weight: normal;
            background: #E04343;
            border: 1px outset white;
            width: 22px;
            height: 18px;
            text-align: center;
            line-height: 16px;
            padding: 0;
            cursor: pointer;
        }
        .modal-title-bar .close-button:hover,
        .modal-title-bar .close-button:focus {
            background: #FF6363;
            text-decoration: none;
        }
         .modal-title-bar .close-button:active {
            border-style: inset;
        }
        .modal-body {
            padding: 15px;
            overflow-y: auto;
            flex-grow: 1;
        }
        .modal-body p { margin-top: 0; margin-bottom: 10px; }
        .modal-body label { display: block; margin-bottom: 5px; margin-top: 12px; }
        .modal-body input[type="text"], .modal-body input[type="file"] {
            width: calc(100% - 12px); padding: 5px; margin-bottom: 10px;
            border: 1px solid #ACA899; box-sizing: border-box;
        }
        .modal-body hr { border: 0; height: 1px; background: #ACA899; margin: 20px 0; }
        .modal-footer {
            padding: 10px 15px; text-align: right;
            background-color: #F0F0F0; border-top: 1px solid #ACA899; flex-shrink: 0;
        }
        @keyframes fadeIn {
            from {opacity: 0; transform: scale(0.9);}
            to {opacity: 1; transform: scale(1);}
        }
        .xp-button {
            background-color: #ECE9D8; border: 1px outset #7F7F7F; padding: 5px 12px;
            min-width: 75px; text-align: center; cursor: pointer; margin: 2px;
        }
        .xp-button:active { border-style: inset; }
        .xp-button:hover { border-color: #005CFE; }
        .color-swatch-item {
            box-sizing: border-box;
            transition: transform 0.1s ease-out;
        }
        .color-swatch-item:hover {
            outline: 2px solid #005CFE;
            outline-offset: 1px;
            transform: scale(1.1);
        }
        #alertModal .modal-content {
            max-width: 400px;
        }
        #alertModal .modal-body {
            display: flex;
            align-items: center;
            padding: 20px;
        }
        #alertModal .alert-icon {
            font-size: 32px;
            margin-right: 15px;
            color: #f0ad4e;
        }
        #alertModal .modal-footer {
            text-align: center;
        }
    </style>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-remote-config.js"></script>
</head>
<body>
    <div id="desktop"></div>

    <!-- Background Image Chooser Modal -->
    <div id="changeBgImageModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Change Background</span>
                <span class="close-button" data-modal-id="changeBgImageModal">r</span>
            </div>
            <div class="modal-body">
                <p>Choose a background type for the application:</p>
                <div>
                    <label for="newBgImageInput">1. Upload image file:</label>
                    <input type="file" id="newBgImageInput" accept="image/*">
                     <p><small>Max 5MB recommended for file uploads due to browser storage limits.</small></p>
                    <button id="uploadBgImageBtn" class="xp-button" style="margin-top: 5px;">Upload File & Apply</button>
                </div>
                <hr>
                <div>
                    <label for="bgImageUrlInput">2. Enter image URL:</label>
                    <input type="text" id="bgImageUrlInput" placeholder="https://example.com/image.png">
                    <p><small>Using a URL is recommended for very large images from the web.</small></p>
                    <button id="applyBgImageUrlBtn" class="xp-button" style="margin-top: 5px;">Apply URL</button>
                </div>
                <hr>
                <div>
                    <label>3. Pick a solid color:</label>
                    <div id="bgColorSwatchesContainer" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; justify-content: center;">
                    </div>
                     <p style="margin-top: 8px;"><small>Click a color swatch to apply it immediately.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="xp-button close-modal-btn" data-modal-id="changeBgImageModal">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Generic Alert Modal -->
    <div id="alertModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span id="alertModalTitle">System Message</span>
                 <span class="close-button" data-modal-id="alertModal">r</span>
            </div>
            <div class="modal-body">
                <div class="alert-icon">!</div>
                <p id="alertModalMessage" style="word-break: break-word;"></p>
            </div>
            <div class="modal-footer">
                <button id="alertModalOkBtn" class="xp-button close-modal-btn" data-modal-id="alertModal">OK</button>
            </div>
        </div>
    </div>


    <script>
        "use strict";
        const OS_STORAGE_KEY = 'lifeXpOsData_v1.0.1';
        const ICON_GRID_SIZE = 25;
        const STANDARD_COLORS = [
            { name: 'Black', value: '#000000' }, { name: 'Silver', value: '#C0C0C0' },
            { name: 'Gray', value: '#808080' }, { name: 'White', value: '#FFFFFF' },
            { name: 'Maroon', value: '#800000' }, { name: 'Red', value: '#FF0000' },
            { name: 'Purple', value: '#800080' }, { name: 'Fuchsia', value: '#FF00FF' },
            { name: 'Green', value: '#008000' }, { name: 'Lime', value: '#00FF00' },
            { name: 'Olive', value: '#808000' }, { name: 'Yellow', value: '#FFFF00' },
            { name: 'Navy', value: '#000080' }, { name: 'Blue', value: '#0000FF' },
            { name: 'Teal', value: '#008080' }, { name: 'Aqua', value: '#00FFFF' },
            { name: 'Orange', value: '#FFA500' }, { name: 'Brown', value: '#A52A2A' },
            { name: 'Pink', value: '#FFC0CB' }, { name: 'Gold', value: '#FFD700' }
        ];
        const FIREBASE_CONFIG = {
          apiKey: "AIzaSyCVWUnnXiOvKRqbvngafdZC7DedEY-7vpg",
          authDomain: "lifexpapp-f5578.firebaseapp.com",
          projectId: "lifexpapp-f5578",
          storageBucket: "lifexpapp-f5578.appspot.com",
          messagingSenderId: "194098013746",
          appId: "1:194098013746:web:720ba296ee9e40dee37e2b"
        };

        let osData = {
            windowStates: {},
            iconPositions: {},
            customBgImage: null,
            customBgColor: null,
            appApiKeys: {
                youtube: "",
                gemini: "",
                googleMaps: ""
            }
        };
        let lastNormalStates = {};
        let highestZIndex = 10;
        let activeDragWindow = null;
        let activeResizeWindow = null;
        let dragOffsetX, dragOffsetY;
        let resizeInitialX, resizeInitialY, resizeInitialWidth, resizeInitialHeight;
        let activeDragIcon = null;
        let iconDragOffsetX, iconDragOffsetY;
        let appManifest = [];
        let firebaseRemoteConfig;


        const DOM = {
            desktop: document.getElementById('desktop'),
            changeBgImageModal: document.getElementById('changeBgImageModal'),
            newBgImageInput: document.getElementById('newBgImageInput'),
            uploadBgImageBtn: document.getElementById('uploadBgImageBtn'),
            bgImageUrlInput: document.getElementById('bgImageUrlInput'),
            applyBgImageUrlBtn: document.getElementById('applyBgImageUrlBtn'),
            bgColorSwatchesContainer: document.getElementById('bgColorSwatchesContainer'),
            alertModal: document.getElementById('alertModal'),
            alertModalMessage: document.getElementById('alertModalMessage'),
            alertModalOkBtn: document.getElementById('alertModalOkBtn'),
            modalCloseButtons: null
        };
        DOM.modalCloseButtons = document.querySelectorAll('.modal .close-button, .modal .close-modal-btn');


        function getById(id) { return document.getElementById(id); }

        function showAlert(message, title = 'System Message') {
            DOM.alertModalMessage.textContent = message;
            getById('alertModalTitle').textContent = title;
            openModal('alertModal');
        }

        async function initializeFirebaseAndLoadKeys() {
            try {
                if (typeof firebase !== 'undefined' && FIREBASE_CONFIG) {
                    firebase.initializeApp(FIREBASE_CONFIG);
                    firebaseRemoteConfig = firebase.remoteConfig();
                    firebaseRemoteConfig.defaultConfig = {
                        'youtube_api_key': '',
                        'gemini_api_key': '',
                        'google_maps_api_key': ''
                    };
                    firebaseRemoteConfig.settings.minimumFetchIntervalMillis = 3600000;
                    await firebaseRemoteConfig.fetchAndActivate();
                    osData.appApiKeys.youtube = firebaseRemoteConfig.getString('youtube_api_key');
                    osData.appApiKeys.gemini = firebaseRemoteConfig.getString('gemini_api_key');
                    osData.appApiKeys.googleMaps = firebaseRemoteConfig.getString('google_maps_api_key');\
                    console.log("Firebase Remote Config fetched. YouTube Key:", osData.appApiKeys.youtube ? "Loaded" : "Not found", "Gemini Key:", osData.appApiKeys.gemini ? "Loaded" : "Not found", "Google Maps Key:", osData.appApiKeys.googleMaps ? "Loaded" : "Not found");
                    saveOsData();
                } else {
                    console.warn("Firebase SDK or config not available. API keys will not be fetched.");
                }
            } catch (err) {
                console.error("Error initializing Firebase Remote Config or fetching keys:", err);
            }
        }


        async function initOS() {
            loadOsData();
            await initializeFirebaseAndLoadKeys();

            applyCurrentBackgroundStyle();
            populateColorSwatches();

            try {
                const response = await fetch('app-manifest.json');
                if (!response.ok) throw new Error(`Failed to load app-manifest.json: ${response.statusText}`);
                appManifest = await response.json();
            } catch (error) {
                console.error("Error loading app manifest:", error);
                showAlert("Could not load application list. Desktop might not function correctly.", "Loading Error");
                return;
            }

            initDesktopIcons();
            restoreAllWindowStates();
            addEventListeners();

            window.addEventListener('message', handleIframeMessages);
        }

        function initDesktopIcons() {
            DOM.desktop.innerHTML = '';
            appManifest.forEach((app, index) => {
                const iconElement = document.createElement('div');
                iconElement.className = 'desktop-icon';
                iconElement.id = `icon-${app.id}`;
                iconElement.dataset.appId = app.id;
                iconElement.title = `Open ${app.name}`;

                let iconHTML = `<div class="icon-image"><span>${app.icon}</span></div>`;

                if (app.customIconClass && app.id === 'playJockey') {
                    iconElement.classList.add(app.customIconClass);
                    iconHTML = `
                        <div class="icon-image">
                            <span class="icon-image-base">${app.icon}</span>
                            <span class="icon-image-overlay">${app.icon}</span>
                        </div>`;
                }

                iconElement.innerHTML = `${iconHTML}<div class="icon-label">${app.name}</div>`;

                const defaultX = 0;
                const defaultY = index * 100;

                if (osData.iconPositions && osData.iconPositions[app.id]) {
                    iconElement.style.left = osData.iconPositions[app.id].x + 'px';
                    iconElement.style.top = osData.iconPositions[app.id].y + 'px';
                } else {
                    const { x: finalX, y: finalY } = findNonCollidingPosition(iconElement, defaultX, defaultY);
                    iconElement.style.left = finalX + 'px';
                    iconElement.style.top = finalY + 'px';
                    if (!osData.iconPositions) osData.iconPositions = {};
                    osData.iconPositions[app.id] = { x: finalX, y: finalY };
                }

                iconElement.addEventListener('mousedown', handleIconMouseDown);
                iconElement.addEventListener('dblclick', handleIconDoubleClick);
                DOM.desktop.appendChild(iconElement);
            });
            saveOsData();
        }

        function handleIconMouseDown(e) {
            if (e.button !== 0 || activeDragWindow || activeResizeWindow) return;
            activeDragIcon = e.currentTarget;
            const appId = activeDragIcon.dataset.appId;
            const windowEl = getById(`window-${appId}`);
            if(windowEl && windowEl.style.display !== 'none' && !windowEl.classList.contains('minimized')) {
                 bringToFront(windowEl);
            }
            iconDragOffsetX = e.clientX - activeDragIcon.offsetLeft;
            iconDragOffsetY = e.clientY - activeDragIcon.offsetTop;
            activeDragIcon.style.cursor = 'grabbing';
            activeDragIcon.style.zIndex = (parseInt(activeDragIcon.style.zIndex) || 5) + highestZIndex + 1;
            document.addEventListener('mousemove', handleIconMouseMove);
            document.addEventListener('mouseup', handleIconMouseUp);
            e.preventDefault();
        }

        function handleIconMouseMove(e) {
            if (!activeDragIcon) return;
            let newX = e.clientX - iconDragOffsetX;
            let newY = e.clientY - iconDragOffsetY;
            const bodyRect = document.body.getBoundingClientRect();
            const iconWidth = activeDragIcon.offsetWidth || 90;
            const iconHeight = activeDragIcon.offsetHeight || 100;
            newX = Math.max(0, Math.min(newX, bodyRect.width - iconWidth));
            newY = Math.max(0, Math.min(newY, bodyRect.height - iconHeight));
            activeDragIcon.style.left = newX + 'px';
            activeDragIcon.style.top = newY + 'px';
        }

        function findNonCollidingPosition(draggedIcon, initialX, initialY) {
            let currentX = initialX;
            let currentY = initialY;
            let attempt = 0;
            const maxAttempts = 100;
            const iconWidth = draggedIcon.offsetWidth || 90;
            const iconHeight = draggedIcon.offsetHeight || 100;

            const checkCollisionAt = (x, y, currentDraggedIconId) => {
                const iconsToCompare = Array.from(DOM.desktop.querySelectorAll('.desktop-icon')).filter(
                    icon => icon.id !== currentDraggedIconId && icon.style.left && icon.style.top
                );
                for (const otherIcon of iconsToCompare) {
                    const otherLeft = parseInt(otherIcon.style.left, 10);
                    const otherTop = parseInt(otherIcon.style.top, 10);
                    const otherWidth = otherIcon.offsetWidth || 90;
                    const otherHeight = otherIcon.offsetHeight || 100;
                    if (x < otherLeft + otherWidth &&
                        x + iconWidth > otherLeft &&
                        y < otherTop + otherHeight &&
                        y + iconHeight > otherTop) {
                        return true;
                    }
                }
                return false;
            };

            let snappedX = Math.round(initialX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
            let snappedY = Math.round(initialY / ICON_GRID_SIZE) * ICON_GRID_SIZE;
            snappedX = Math.max(0, Math.min(snappedX, document.body.clientWidth - iconWidth));
            snappedY = Math.max(0, Math.min(snappedY, document.body.clientHeight - iconHeight));

            if (!checkCollisionAt(snappedX, snappedY, draggedIcon.id)) {
                return { x: snappedX, y: snappedY };
            }

            let layer = 1;
            while (attempt < maxAttempts) {
                const positionsToTry = [];
                for (let i = -layer; i <= layer; i++) {
                    positionsToTry.push({ x: snappedX + i * ICON_GRID_SIZE, y: snappedY - layer * ICON_GRID_SIZE });
                    if (layer !== 0) positionsToTry.push({ x: snappedX + i * ICON_GRID_SIZE, y: snappedY + layer * ICON_GRID_SIZE });
                }
                for (let i = -layer + 1; i < layer; i++) {
                    positionsToTry.push({ x: snappedX - layer * ICON_GRID_SIZE, y: snappedY + i * ICON_GRID_SIZE });
                    if (layer !== 0) positionsToTry.push({ x: snappedX + layer * ICON_GRID_SIZE, y: snappedY + i * ICON_GRID_SIZE });
                }

                for (const pos of positionsToTry) {
                    attempt++;
                    if (attempt >= maxAttempts) break;
                    let testX = pos.x;
                    let testY = pos.y;
                    testX = Math.max(0, Math.min(testX, document.body.clientWidth - iconWidth));
                    testY = Math.max(0, Math.min(testY, document.body.clientHeight - iconHeight));
                    testX = Math.round(testX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
                    testY = Math.round(testY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

                    if (!checkCollisionAt(testX, testY, draggedIcon.id)) {
                        return { x: testX, y: testY };
                    }
                }
                if (attempt >= maxAttempts) break;
                layer++;
                 if (layer * ICON_GRID_SIZE > Math.max(document.body.clientWidth, document.body.clientHeight) && attempt > 20) {
                     break;
                }
            }
            return { x: snappedX, y: snappedY };
        }


        function handleIconMouseUp(e) {
            if (!activeDragIcon) return;
            activeDragIcon.style.zIndex = '5';
            let finalX = activeDragIcon.offsetLeft;
            let finalY = activeDragIcon.offsetTop;

            let snappedX = Math.round(finalX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
            let snappedY = Math.round(finalY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

            const iconWidth = activeDragIcon.offsetWidth || 90;
            const iconHeight = activeDragIcon.offsetHeight || 100;

            snappedX = Math.max(0, Math.min(snappedX, document.body.clientWidth - iconWidth));
            snappedY = Math.max(0, Math.min(snappedY, document.body.clientHeight - iconHeight));

            snappedX = Math.round(snappedX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
            snappedY = Math.round(snappedY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

            const { x: finalSnappedX, y: finalSnappedY } = findNonCollidingPosition(activeDragIcon, snappedX, snappedY);

            activeDragIcon.style.left = finalSnappedX + 'px';
            activeDragIcon.style.top = finalSnappedY + 'px';

            const appId = activeDragIcon.dataset.appId;
            if (!osData.iconPositions) osData.iconPositions = {};
            osData.iconPositions[appId] = { x: finalSnappedX, y: finalSnappedY };
            saveOsData();

            activeDragIcon.style.cursor = 'grab';
            activeDragIcon = null;
            document.removeEventListener('mousemove', handleIconMouseMove);
            document.removeEventListener('mouseup', handleIconMouseUp);
        }

        function handleIconDoubleClick(e) {
            const iconElement = e.currentTarget;
            const appId = iconElement.dataset.appId;
            const appConfig = appManifest.find(app => app.id === appId);
            if (appConfig) {
                openAppWindow(appConfig);
            }
        }

        function openAppWindow(appConfig) {
            const windowId = `window-${appConfig.id}`;
            let windowElement = getById(windowId);
            let state = osData.windowStates[appConfig.id];

            if (windowElement) {
                const iframe = windowElement.querySelector('iframe');

                if (state && state.hiddenByUser) {
                    windowElement.style.display = 'flex';
                    state.hiddenByUser = false;

                    if (iframe && !iframe.hasAttribute('src')) {
                        iframe.setAttribute('src', appConfig.file);
                    }

                    if (state.minimized) {
                        state.minimized = false;
                        windowElement.classList.remove('minimized');
                        if (lastNormalStates[appConfig.id]) {
                            windowElement.style.width = lastNormalStates[appConfig.id].width;
                            windowElement.style.height = lastNormalStates[appConfig.id].height;
                            windowElement.style.left = lastNormalStates[appConfig.id].left;
                            windowElement.style.top = lastNormalStates[appConfig.id].top;
                        } else {
                            setWindowDefaults(appConfig.id, false, appConfig);
                        }
                    }
                    updateMinMaxButtonStates(appConfig.id);
                } else if (state && state.minimized) {
                    maximizeWindow(appConfig.id, appConfig);
                }
                bringToFront(windowElement);
                saveWindowState(appConfig.id);
                return windowElement;
            }

            highestZIndex++;
            windowElement = document.createElement('div');
            windowElement.className = 'xp-window';
            windowElement.id = windowId;
            windowElement.style.zIndex = highestZIndex;

            windowElement.innerHTML = `
                <div class="title-bar" id="title-bar-${appConfig.id}">
                    <span class="title-bar-text">${appConfig.name}</span>
                    <div class="title-bar-controls">
                        <button id="minimize-btn-${appConfig.id}" title="Minimize">0</button>
                        <button id="maximize-btn-${appConfig.id}" title="Maximize">1</button>
                        <button id="close-btn-${appConfig.id}" title="Close">r</button>
                    </div>
                </div>
                <div class="window-body" id="window-body-${appConfig.id}">
                    <iframe src="${appConfig.file}" id="iframe-${appConfig.id}" name="iframe-${appConfig.id}"></iframe>
                </div>
                <div class="resize-handle" id="resize-handle-${appConfig.id}"></div>
            `;
            DOM.desktop.appendChild(windowElement);

            const newIframe = windowElement.querySelector('iframe');
            newIframe.onload = () => {
                if (newIframe.contentWindow) {
                    sendApiKeyToApp(appConfig.id, newIframe.contentWindow);
                }
            };

            if (!state) {
                osData.windowStates[appConfig.id] = {};
                state = osData.windowStates[appConfig.id];
                setWindowDefaults(appConfig.id, false, appConfig);
            } else {
                if (state.maximized) {
                    windowElement.classList.add('true-maximized');
                    windowElement.style.width = '100vw';
                    windowElement.style.height = '100vh';
                    windowElement.style.top = '0px';
                    windowElement.style.left = '0px';
                } else if (state.minimized) {
                    windowElement.classList.add('minimized');
                } else if (state.width && state.height && state.x != null && state.y != null) {
                    windowElement.style.width = state.width + 'px';
                    windowElement.style.height = state.height + 'px';
                    windowElement.style.left = state.x + 'px';
                    windowElement.style.top = state.y + 'px';
                } else {
                    setWindowDefaults(appConfig.id, false, appConfig);
                }
            }
            state.hiddenByUser = false;

            initWindowInteractions(appConfig.id, appConfig);
            updateMinMaxButtonStates(appConfig.id);
            saveWindowState(appConfig.id);
            return windowElement;
        }

        function sendApiKeyToApp(appId, iframeContentWindow) {
            if (!iframeContentWindow) return;
            let service = '';
            let key = '';
            
            if (appId === 'geminiChat') {
                service = 'gemini';
                key = osData.appApiKeys.gemini;
            } else if (appId === 'playJockey') {
                service = 'youtube';
                key = osData.appApiKeys.youtube;
            } else if (appId === 'compass') {
                service = 'googleMaps';
                key = osData.appApiKeys.googleMaps;\
            }

            if(service && key) {
                 iframeContentWindow.postMessage({ type: 'apiKeyResponse', service: service, key: key }, '*');
            }
        }

        function restoreAllWindowStates() {
            if (!osData.windowStates || !appManifest) return;
            let maxRestoredZ = highestZIndex;
            appManifest.forEach(appConfig => {
                const state = osData.windowStates[appConfig.id];
                if (state && !state.hiddenByUser) {
                    const win = openAppWindow(appConfig);
                    if (win && state.zIndex) {
                        win.style.zIndex = state.zIndex;
                        maxRestoredZ = Math.max(maxRestoredZ, state.zIndex);
                    }
                }
            });
            highestZIndex = maxRestoredZ;
        }


        function initWindowInteractions(appId, appConfig) {
            const windowElement = getById(`window-${appId}`);
            const titleBarElement = getById(`title-bar-${appId}`);
            const resizeHandleElement = getById(`resize-handle-${appId}`);
            const iframeElement = getById(`iframe-${appId}`);

            if (!windowElement || !titleBarElement) return;

            windowElement.addEventListener('mousedown', (e) => {
                 if (e.target.closest('.desktop-icon') || e.target.closest('.modal')) return;
                 if (e.target === windowElement || titleBarElement.contains(e.target) && !e.target.closest('button') ||
                    (windowElement.querySelector('.window-body')?.contains(e.target) && e.target.tagName !== 'IFRAME' && !e.target.closest('button, input, select, textarea, .resize-handle'))) {
                     bringToFront(windowElement);
                 }
            }, true);

            titleBarElement.addEventListener('mousedown', (e) => {
                if (e.target.closest('button') || windowElement.classList.contains('true-maximized') || activeDragIcon) return;
                activeDragWindow = windowElement;
                dragOffsetX = e.clientX - activeDragWindow.offsetLeft;
                dragOffsetY = e.clientY - activeDragWindow.offsetTop;
                activeDragWindow.classList.add('disable-selection');
                if (iframeElement) iframeElement.style.pointerEvents = 'none';
                document.addEventListener('mousemove', doDrag);
                document.addEventListener('mouseup', stopDragOrResize);
                bringToFront(windowElement);
            });

            if (resizeHandleElement) {
                resizeHandleElement.addEventListener('mousedown', (e) => {
                    if (windowElement.classList.contains('true-maximized') || activeDragIcon) return;
                    activeResizeWindow = windowElement;
                    activeResizeWindow.classList.add('disable-selection');
                    resizeInitialX = e.clientX;
                    resizeInitialY = e.clientY;
                    resizeInitialWidth = activeResizeWindow.offsetWidth;
                    resizeInitialHeight = activeResizeWindow.offsetHeight;
                    if (iframeElement) iframeElement.style.pointerEvents = 'none';

                    const specificDoResize = (ev) => doResize(ev, appConfig);
                    document.addEventListener('mousemove', specificDoResize);
                    document.addEventListener('mouseup', function mouseUpListener() {
                        stopDragOrResize();
                        document.removeEventListener('mousemove', specificDoResize);
                        document.removeEventListener('mouseup', mouseUpListener);
                    });
                    bringToFront(windowElement);
                });
            }

            getById(`minimize-btn-${appId}`).addEventListener('click', () => minimizeWindow(appId));
            getById(`maximize-btn-${appId}`).addEventListener('click', () => maximizeWindow(appId, appConfig));
            getById(`close-btn-${appId}`).addEventListener('click', () => closeWindow(appId));
        }

        function bringToFront(windowElement) {
            if (!windowElement) return;
            highestZIndex++;
            windowElement.style.zIndex = highestZIndex;
            const appId = windowElement.id.replace('window-', '');
            if (osData.windowStates[appId]) {
                osData.windowStates[appId].zIndex = highestZIndex;
            }
        }

        function doDrag(e) {
            if (!activeDragWindow) return;
            let newLeft = e.clientX - dragOffsetX;
            let newTop = e.clientY - dragOffsetY;
            const windowWidth = activeDragWindow.offsetWidth;
            const windowHeight = activeDragWindow.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            newLeft = Math.max(0, Math.min(newLeft, viewportWidth - windowWidth));
            newTop = Math.max(0, Math.min(newTop, viewportHeight - windowHeight));
            activeDragWindow.style.left = newLeft + 'px';
            activeDragWindow.style.top = newTop + 'px';
            const appId = activeDragWindow.id.replace('window-', '');
            if (osData.windowStates[appId]) {
                osData.windowStates[appId].userManuallySetPosition = true;
            }
        }

        function doResize(e, appConfig) {
            if (!activeResizeWindow) return;
            const appId = activeResizeWindow.id.replace('window-', '');
            const currentMinWidth = appConfig.minWidth || 150;
            const currentMinHeight = appConfig.minHeight || 100;

            let newWidth = resizeInitialWidth + (e.clientX - resizeInitialX);
            let newHeight = resizeInitialHeight + (e.clientY - resizeInitialY);
            activeResizeWindow.style.width = Math.max(currentMinWidth, newWidth) + 'px';
            activeResizeWindow.style.height = Math.max(currentMinHeight, newHeight) + 'px';
            if (osData.windowStates[appId]) {
                osData.windowStates[appId].userManuallySetSize = true;
            }
        }

        function stopDragOrResize() {
            let operatedWindow = null;
            if (activeDragWindow) {
                activeDragWindow.classList.remove('disable-selection');
                operatedWindow = activeDragWindow;
                activeDragWindow = null;
            }
            if (activeResizeWindow) {
                activeResizeWindow.classList.remove('disable-selection');
                operatedWindow = activeResizeWindow;
                activeResizeWindow = null;
            }
            if (operatedWindow) {
                const iframe = operatedWindow.querySelector('iframe');
                if (iframe) iframe.style.pointerEvents = 'auto';
                saveWindowState(operatedWindow.id.replace('window-', ''));
            }
        }

        function setWindowDefaults(appId, isBrowserResize = false, appConfig) {
            const appWindow = getById(`window-${appId}`);
            if (!appWindow || appWindow.classList.contains('minimized')) return;

            const state = osData.windowStates[appId];
            if (!state) return;

            if (appWindow.classList.contains('true-maximized') && !isBrowserResize) {
                appWindow.style.width = '100vw';
                appWindow.style.height = '100vh';
                appWindow.style.top = '0px';
                appWindow.style.left = '0px';
                return;
            }

            const hasValidSavedSize = state.width && state.width > 0 && state.height && state.height > 0;
            const hasValidSavedPosition = state.x != null && state.y != null;

            const currentMinWidth = appConfig.minWidth || 150;
            const currentMinHeight = appConfig.minHeight || 100;
            const defaultWidth = appConfig.defaultWidth || 500;
            const defaultHeight = appConfig.defaultHeight || 400;

            const openWindows = Object.keys(osData.windowStates).filter(id => {
                const winEl = getById(`window-${id}`);
                return winEl && winEl.style.display !== 'none' && !osData.windowStates[id].minimized;
            }).length;
            const defaultOffsetX = 20 + (openWindows % 5) * 30;
            const defaultOffsetY = 20 + (openWindows % 5) * 30;


            if (isBrowserResize || !state.userManuallySetPosition || !state.userManuallySetSize || !hasValidSavedSize || !hasValidSavedPosition) {
                let newWidth = defaultWidth;
                let newHeight = defaultHeight;
                newWidth = Math.max(currentMinWidth, newWidth);
                newHeight = Math.max(currentMinHeight, newHeight);

                let newLeft = (defaultOffsetX === 0 && window.innerWidth > newWidth) ? (window.innerWidth - newWidth) / 2 : defaultOffsetX;
                let newTop = (defaultOffsetY === 0 && window.innerHeight > newHeight) ? (window.innerHeight - newHeight) / 2 : defaultOffsetY;

                newTop = Math.max(10, Math.min(newTop, window.innerHeight - newHeight - 10));
                newLeft = Math.max(10, Math.min(newLeft, window.innerWidth - newWidth - 10));
                if (window.innerHeight <= newHeight + 20) newTop = 10;
                if (window.innerWidth <= newWidth + 20) newLeft = 10;

                if (!state.userManuallySetSize || !hasValidSavedSize || isBrowserResize) {
                    appWindow.style.width = newWidth + 'px';
                    appWindow.style.height = newHeight + 'px';
                    state.width = newWidth;
                    state.height = newHeight;
                    state.userManuallySetSize = false;
                }
                if (!state.userManuallySetPosition || !hasValidSavedPosition || isBrowserResize) {
                    appWindow.style.left = newLeft + 'px';
                    appWindow.style.top = newTop + 'px';
                    state.x = newLeft;
                    state.y = newTop;
                    state.userManuallySetPosition = false;
                }
            }
        }


        function minimizeWindow(appId) {
            const appWindow = getById(`window-${appId}`);
            if (!appWindow || appWindow.classList.contains('minimized')) return;
            const state = osData.windowStates[appId];
            if (!state) return;

            state.minimized = true;
            if (appWindow.classList.contains('true-maximized')) {
                state.wasMaximizedBeforeMinimize = true;
                if (lastNormalStates[appId]) {
                    state.width = parseInt(lastNormalStates[appId].width);
                    state.height = parseInt(lastNormalStates[appId].height);
                    state.x = parseInt(lastNormalStates[appId].left);
                    state.y = parseInt(lastNormalStates[appId].top);
                }
            } else {
                state.wasMaximizedBeforeMinimize = false;
                state.width = appWindow.offsetWidth;
                state.height = appWindow.offsetHeight;
                state.x = appWindow.offsetLeft;
                state.y = appWindow.offsetTop;
            }
            appWindow.classList.remove('true-maximized');
            appWindow.classList.add('minimized');
            updateMinMaxButtonStates(appId);
            saveWindowState(appId);
        }

        function maximizeWindow(appId, appConfig) {
            const appWindow = getById(`window-${appId}`);
            if (!appWindow) return;
            const state = osData.windowStates[appId];
            if (!state) return;

            const isMinimized = appWindow.classList.contains('minimized');

            if (isMinimized) {
                appWindow.classList.remove('minimized');
                state.minimized = false;
                const wasMaximized = state.wasMaximizedBeforeMinimize;
                delete state.wasMaximizedBeforeMinimize;

                if (wasMaximized) {
                    appWindow.style.width = '100vw';
                    appWindow.style.height = '100vh';
                    appWindow.style.top = '0px';
                    appWindow.style.left = '0px';
                    appWindow.classList.add('true-maximized');
                    state.maximized = true;
                } else {
                    if (state.width && state.height && state.x != null && state.y != null) {
                        appWindow.style.width = state.width + 'px';
                        appWindow.style.height = state.height + 'px';
                        appWindow.style.left = state.x + 'px';
                        appWindow.style.top = state.y + 'px';
                    } else if (lastNormalStates[appId] && lastNormalStates[appId].width && lastNormalStates[appId].height) {
                        appWindow.style.width = lastNormalStates[appId].width;
                        appWindow.style.height = lastNormalStates[appId].height;
                        appWindow.style.left = lastNormalStates[appId].left;
                        appWindow.style.top = lastNormalStates[appId].top;
                    } else {
                        setWindowDefaults(appId, false, appConfig);
                    }
                    state.maximized = false;
                }
            } else if (appWindow.classList.contains('true-maximized')) {
                if (lastNormalStates[appId] && lastNormalStates[appId].width && lastNormalStates[appId].height) {
                    appWindow.style.width = lastNormalStates[appId].width;
                    appWindow.style.height = lastNormalStates[appId].height;
                    appWindow.style.top = lastNormalStates[appId].top;
                    appWindow.style.left = lastNormalStates[appId].left;
                    state.width = parseInt(lastNormalStates[appId].width);
                    state.height = parseInt(lastNormalStates[appId].height);
                    state.x = parseInt(lastNormalStates[appId].left);
                    state.y = parseInt(lastNormalStates[appId].top);
                } else {
                    setWindowDefaults(appId, false, appConfig);
                }
                appWindow.classList.remove('true-maximized');
                state.maximized = false;
                state.userManuallySetPosition = true;
                state.userManuallySetSize = true;
            } else {
                lastNormalStates[appId] = {
                    width: appWindow.style.width || (appWindow.offsetWidth + 'px'),
                    height: appWindow.style.height || (appWindow.offsetHeight + 'px'),
                    top: appWindow.style.top || (appWindow.offsetTop + 'px'),
                    left: appWindow.style.left || (appWindow.offsetLeft + 'px')
                };
                appWindow.style.width = '100vw';
                appWindow.style.height = '100vh';
                appWindow.style.top = '0px';
                appWindow.style.left = '0px';
                appWindow.classList.add('true-maximized');
                state.maximized = true;
                state.userManuallySetPosition = false;
                state.userManuallySetSize = false;
            }
            updateMinMaxButtonStates(appId);
            saveWindowState(appId);
        }

        function closeWindow(appId) {
            const appWindow = getById(`window-${appId}`);
            if (appWindow) {
                appWindow.style.display = 'none';
                const iframe = appWindow.querySelector('iframe');
                if (iframe) {
                    iframe.removeAttribute('src');
                }
            }
            if (osData.windowStates[appId]) {
                osData.windowStates[appId].hiddenByUser = true;
            }
            saveWindowState(appId);
        }


        function updateMinMaxButtonStates(appId) {
            const win = getById(`window-${appId}`);
            const minimizeBtn = getById(`minimize-btn-${appId}`);
            const maximizeBtn = getById(`maximize-btn-${appId}`);

            if (!win || !minimizeBtn || !maximizeBtn) return;

            const isMinimized = win.classList.contains('minimized');
            const isTrueMaximized = win.classList.contains('true-maximized');

            minimizeBtn.disabled = isMinimized;
            maximizeBtn.disabled = false;

            if (isMinimized) {
                maximizeBtn.textContent = '1';
                maximizeBtn.title = "Restore";
            } else if (isTrueMaximized) {
                maximizeBtn.textContent = '2';
                maximizeBtn.title = "Restore Down";
            } else {
                maximizeBtn.textContent = '1';
                maximizeBtn.title = "Maximize";
            }
        }

        function saveWindowState(appId) {
            const win = getById(`window-${appId}`);
            if (!win) return;

            let state = osData.windowStates[appId];
            if (!state) {
                osData.windowStates[appId] = {};
                state = osData.windowStates[appId];
            }

            state.minimized = win.classList.contains('minimized');
            state.maximized = win.classList.contains('true-maximized');
            state.zIndex = parseInt(win.style.zIndex) || highestZIndex;
            state.hiddenByUser = (win.style.display === 'none');

            if (!state.minimized && !state.maximized) {
                state.x = win.offsetLeft;
                state.y = win.offsetTop;
                state.width = win.offsetWidth;
                state.height = win.offsetHeight;
            }
            saveOsData();
        }


        function saveOsData() {
            try {
                localStorage.setItem(OS_STORAGE_KEY, JSON.stringify(osData));
            } catch (error) {
                console.error("Could not save OS data:", error);
                if (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                    showAlert("Could not save data: Storage limit exceeded. This might be due to a very large background image from file upload. Try a smaller file or use the URL option for large images.", "Storage Error");
                }
            }
        }

        function loadOsData() {
            const storedData = localStorage.getItem(OS_STORAGE_KEY);
            const defaultOsData = {
                windowStates: {},
                iconPositions: {},
                customBgImage: null,
                customBgColor: null,
                appApiKeys: { youtube: "", gemini: "", googleMaps: "" }
            };
            if (storedData) {
                try {
                    const parsedData = JSON.parse(storedData);
                    osData = { ...defaultOsData, ...parsedData };
                    osData.windowStates = { ...defaultOsData.windowStates, ...(parsedData.windowStates || {}) };
                    osData.iconPositions = { ...defaultOsData.iconPositions, ...(parsedData.iconPositions || {}) };
                    osData.appApiKeys = { ...defaultOsData.appApiKeys, ...(parsedData.appApiKeys || {}) };

                } catch (error) {
                    console.error("Error parsing stored OS data. Reverting to defaults.", error);
                    osData = JSON.parse(JSON.stringify(defaultOsData));
                }
            } else {
                 osData = JSON.parse(JSON.stringify(defaultOsData));
            }
            let maxZ = 10;
            for (const appId in osData.windowStates) {
                if (osData.windowStates[appId].zIndex) {
                    maxZ = Math.max(maxZ, osData.windowStates[appId].zIndex);
                }
            }
            highestZIndex = maxZ;
        }

        function applyCurrentBackgroundStyle() {
            if (osData.customBgColor) {
                document.body.style.backgroundImage = 'none';
                document.body.style.backgroundColor = osData.customBgColor;
            } else if (osData.customBgImage) {
                document.body.style.backgroundColor = '';
                document.body.style.backgroundImage = `url('${osData.customBgImage}')`;
            } else {
                document.body.style.backgroundColor = '#3A6EA5';
                document.body.style.backgroundImage = "url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png')";
            }
        }

        function populateColorSwatches() {
            DOM.bgColorSwatchesContainer.innerHTML = '';
            STANDARD_COLORS.forEach(color => {
                const swatch = document.createElement('div');
                swatch.style.width = '30px';
                swatch.style.height = '30px';
                swatch.style.backgroundColor = color.value;
                swatch.style.border = '1px solid #7F7F7F';
                swatch.style.cursor = 'pointer';
                swatch.title = color.name;
                swatch.dataset.colorValue = color.value;
                swatch.classList.add('color-swatch-item');
                DOM.bgColorSwatchesContainer.appendChild(swatch);
            });
        }

        function openModal(modalId) {
            const modal = getById(modalId);
            if (modal) modal.style.display = 'flex';
        }

        function closeModal(modalId) {
            const modal = getById(modalId);
            if (modal) modal.style.display = 'none';
        }

        function addEventListeners() {
            document.body.addEventListener('contextmenu', function(event) {
                if (event.target === document.body || event.target === DOM.desktop) {
                    event.preventDefault();
                    DOM.newBgImageInput.value = null;
                    DOM.bgImageUrlInput.value = '';
                    openModal('changeBgImageModal');
                }
            });

            DOM.uploadBgImageBtn.addEventListener('click', function() {
                const file = DOM.newBgImageInput.files[0];
                if (file) {
                    if (file.size > 5 * 1024 * 1024) {
                        showAlert("Image file is large (over 5MB). This might exceed browser storage limits when saved. Try a smaller file or use the URL option for large images.", "File Size Warning");
                    }
                    const reader = new FileReader();
                    reader.onloadend = function() {
                        osData.customBgImage = reader.result;
                        osData.customBgColor = null;
                        applyCurrentBackgroundStyle();
                        saveOsData();
                        closeModal('changeBgImageModal');
                    }
                    reader.onerror = function() { showAlert("Error reading image file.", "File Error"); }
                    reader.readAsDataURL(file);
                } else {
                    showAlert("Please select an image file first.");
                }
            });

            DOM.applyBgImageUrlBtn.addEventListener('click', function() {
                const imageUrl = DOM.bgImageUrlInput.value.trim();
                if (imageUrl) {
                    try {
                        new URL(imageUrl);
                        osData.customBgImage = imageUrl;
                        osData.customBgColor = null;
                        applyCurrentBackgroundStyle();
                        saveOsData();
                        closeModal('changeBgImageModal');
                    } catch (e) {
                        showAlert("Invalid image URL provided. Please enter a complete and valid URL (e.g., https://example.com/image.png).", "URL Error");
                    }
                } else {
                    showAlert("Please enter an image URL.");
                }
            });

            DOM.bgColorSwatchesContainer.addEventListener('click', function(event) {
                if (event.target.classList.contains('color-swatch-item')) {
                    const selectedColor = event.target.dataset.colorValue;
                    if (selectedColor) {
                        osData.customBgColor = selectedColor;
                        osData.customBgImage = null;
                        applyCurrentBackgroundStyle();
                        saveOsData();
                        closeModal('changeBgImageModal');
                    }
                }
            });

            DOM.modalCloseButtons.forEach(button => {
                button.addEventListener('click', (event) => {
                    const modalId = event.target.dataset.modalId || event.target.closest('.modal').id;
                    if (modalId) closeModal(modalId);
                });
            });

            window.addEventListener('resize', () => {
                appManifest.forEach(appConfig => {
                    const win = getById(`window-${appConfig.id}`);
                    if (win && win.style.display !== 'none' && (!osData.windowStates[appConfig.id] || !osData.windowStates[appConfig.id].minimized)) {
                         setWindowDefaults(appConfig.id, true, appConfig);
                    }
                });
                saveOsData();
            });
        }

        function handleIframeMessages(event) {
            const { type, service, appId } = event.data;
            if (type === 'requestApiKey' && appId && service) {
                const iframe = document.getElementById(`iframe-${appId}`);
                if (iframe && iframe.contentWindow) {
                    let keyToSend = osData.appApiKeys[service] || null;
                    if (service === 'gemini') {
                        keyToSend = osData.appApiKeys.gemini;
                    } else if (service === 'youtube') {
                        keyToSend = osData.appApiKeys.youtube;
                    } else if (service === 'googleMaps') {
                        keyToSend = osData.appApiKeys.googleMaps;\
                    }

                    if (keyToSend !== null) {
                         iframe.contentWindow.postMessage({ type: 'apiKeyResponse', service: service, key: keyToSend }, '*');
                         console.log(`OS: Sent '${service}' API key to app '${appId}'.`);
                    } else {
                         console.warn(`OS: API key for service '${service}' not available for app '${appId}'.`);
                    }
                }
            }
        }

        document.addEventListener('DOMContentLoaded', initOS);
    </script>
</body>
</html>