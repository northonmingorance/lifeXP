<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life XP</title>
    <style>
        body {
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #3A6EA5;
            background-image: url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png');
            background-size: cover;
            background-position: 0% 0%;
            background-repeat: no-repeat;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }

        .xp-window {
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            min-height: 30px;
            display: flex;
            flex-direction: column;
            position: absolute;
            overflow: hidden;
        }

        .xp-window.disable-selection,
        .xp-window.disable-selection * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #000;
            cursor: grab;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
            user-select: none;
        }
        .title-bar:active {
            cursor: grabbing;
        }

        .title-bar-text {
            margin-left: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .title-bar-controls button {
            background-color: #ECE9D8;
            border: 1px solid #000;
            width: 22px;
            height: 18px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-size: 12px;
            line-height: 16px;
            margin-left: 2px;
            box-shadow: 1px 1px 0px #FFF inset, -1px -1px 0px #808080 inset;
            padding: 0;
            text-align: center;
            cursor: default;
        }
        .title-bar-controls button:active:not(:disabled) {
            box-shadow: -1px -1px 0px #FFF inset, 1px 1px 0px #808080 inset;
        }
        .title-bar-controls button:disabled {
            color: #7F7F7F;
            cursor: default;
            opacity: 0.7;
        }

        .window-body {
            padding: 15px;
            flex-grow: 1;
            overflow-y: auto;
            opacity: 1;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.2s ease-out;
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
        }

        #xpMainWindow .window-body {
             padding: 15px;
             overflow-y: auto;
        }

        #playJockeyWindow .window-body {
            padding: 0;
            display: flex;
        }


        .xp-window.minimized .window-body {
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            opacity: 0 !important;
            overflow: hidden !important;
            border-top: none !important;
        }
        .xp-window.minimized {
            min-height: 28px !important;
            height: 28px !important;
            overflow: hidden;
        }

        .controls-bar {
            display: flex;
            margin-bottom: 15px;
            padding: 8px;
            border: 1px solid #ACA899;
            background-color: #F0F0F0;
        }

        .controls-bar.layout-single-row {
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
        }
        .controls-bar.layout-single-row > div {
             margin: 2px 5px;
             flex-shrink: 0;
        }

        .controls-bar.layout-multi-row {
            flex-direction: column;
            align-items: stretch;
        }
        .controls-bar.layout-multi-row > div {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            padding: 5px 0;
        }
        .controls-bar.layout-multi-row > div:last-child {
            margin-bottom: 0;
        }
        .controls-bar.layout-multi-row .controls-group {
             text-align: center;
        }

        .xp-button {
            background-color: #ECE9D8;
            border: 1px outset #7F7F7F;
            padding: 5px 12px;
            min-width: 75px;
            text-align: center;
            cursor: pointer;
            margin: 2px;
        }
        .xp-button:active {
            border-style: inset;
        }
        .xp-button:hover {
            border-color: #005CFE;
        }
        .xp-button-small {
            padding: 2px 5px;
            font-size: 10px;
            min-width: auto;
            margin: 0 2px;
        }


        .week-navigation {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .week-navigation button {
            margin: 0 3px;
        }

        .controls-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0 10px;
            text-align: center;
        }
        #currentWeekDisplay {
            font-weight: bold;
        }
        #weekCountDisplay {
            font-size: 0.9em;
            color: #333;
        }

        .global-actions {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            table-layout: fixed;
        }

        th, td {
            border: 1px solid #ACA899;
            padding: 8px;
            text-align: left;
            vertical-align: top;
            word-wrap: break-word;
        }

        th {
            background-color: #D4D0C8;
            text-align: center;
        }

        td.area-name-cell {
            font-weight: bold;
            width: 180px;
        }
        .area-stats {
            font-size: 0.9em;
            margin-top: 5px;
            color: #333;
        }
        .area-stats span { display: flex; }
        .xp-bar-container {
            width: 100%;
            height: 12px;
            background-color: #BDBDBD;
            border: 1px solid #7F7F7F;
            margin-top: 3px;
            position: relative;
            border-radius: 2px;
            overflow: hidden;
        }
        .xp-bar {
            height: 100%;
            background-color: #008000;
            transition: width 0.3s ease;
            border-radius: 1px;
        }
        .xp-bar-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            line-height: 12px;
            color: white;
            text-shadow: 1px 1px 0px black;
            font-weight: bold;
            z-index: 1;
        }

        .achievement-item {
            background-color: #FFF;
            border: 1px solid #DDD;
            padding: 4px;
            margin-bottom: 4px;
            font-size: 0.9em;
            border-radius: 3px;
            word-wrap: break-word;
            box-sizing: border-box;
            position: relative;
            padding-bottom: 22px;
        }
        .achievement-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin-top: 0px;
            border-radius: 2px;
        }
        .achievement-item-actions {
            position: absolute;
            bottom: 3px;
            right: 3px;
            display: flex;
            gap: 3px;
        }
        .achievement-add-btn-cell {
            display: block;
            width: 99.5%;
            box-sizing: border-box;
            margin-top: 5px;
        }


        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #ECE9D8;
            margin: auto;
            padding: 0;
            border: 1px solid #000;
            width: 80%;
            max-width: 500px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
            display: flex;
            flex-direction: column;
        }

        .modal-title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            border-bottom: 1px solid #000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .modal-title-bar .close-button {
            color: white;
            font-size: 16px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-weight: normal;
            background: #E04343;
            border: 1px outset white;
            width: 22px;
            height: 18px;
            text-align: center;
            line-height: 16px;
            padding: 0;
            cursor: pointer;
        }
        .modal-title-bar .close-button:hover,
        .modal-title-bar .close-button:focus {
            background: #FF6363;
            text-decoration: none;
        }
         .modal-title-bar .close-button:active {
            border-style: inset;
        }
        .modal-body {
            padding: 15px;
            overflow-y: auto;
            flex-grow: 1;
        }
        .modal-body p {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .modal-body label {
            display: block;
            margin-bottom: 5px;
            margin-top: 12px;
        }
        .modal-body input[type="text"],
        .modal-body input[type="number"],
        .modal-body textarea,
        .modal-body select {
            width: calc(100% - 12px);
            padding: 5px;
            margin-bottom: 10px;
            border: 1px solid #ACA899;
            box-sizing: border-box;
        }
        .modal-body input[type="file"] {
            margin-bottom: 5px;
        }
         .modal-body hr {
            border: 0;
            height: 1px;
            background: #ACA899;
            margin: 20px 0;
        }
        .modal-footer {
            padding: 10px 15px;
            text-align: right;
            background-color: #F0F0F0;
            border-top: 1px solid #ACA899;
            flex-shrink: 0;
        }

        @keyframes fadeIn {
            from {opacity: 0; transform: scale(0.9);}
            to {opacity: 1; transform: scale(1);}
        }

        .quest-item {
            padding: 8px;
            border: 1px solid #ACA899;
            margin-bottom: 8px;
            background-color: #FFF;
            border-radius: 3px;
            position: relative;
        }
        .quest-item label {
            margin-left: 8px;
        }
        .quest-item.completed {
            background-color: #DFF0D8;
            text-decoration: line-through;
            color: #508a50;
        }
        .quest-item.completed .quest-title {
             color: #006400;
        }
        .quest-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #0039A9;
        }
        .quest-details {
            font-size: 0.95em;
            margin-bottom: 3px;
        }
        .quest-progress {
            font-size: 0.85em;
            color: #555;
            margin-top: 3px;
            margin-bottom: 25px;
        }
        .quest-actions {
            position: absolute;
            bottom: 5px;
            right: 5px;
        }


        .area-name-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .delete-area-btn {
            padding: 1px 6px;
            min-width: auto;
            font-size: 10px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-weight: bold;
            margin-left: 10px;
            background-color: #E04343;
            color: white;
            border: 1px outset white;
            line-height: 1.2;
            cursor: pointer;
        }
        .delete-area-btn:hover {
            background-color: #FF6363;
        }
        .delete-area-btn:active {
            border-style: inset;
        }

        .resize-handle {
            width: 12px;
            height: 12px;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            z-index: 10;
            box-sizing: border-box;
            opacity: 0.6;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center center;
        }

        .resize-handle:hover {
            opacity: 1;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
        }

        .xp-window.true-maximized .resize-handle {
            display: none;
        }

        .color-swatch-item {
            box-sizing: border-box;
            transition: transform 0.1s ease-out;
        }
        .color-swatch-item:hover {
            outline: 2px solid #005CFE;
            outline-offset: 1px;
            transform: scale(1.1);
        }

        .desktop-icon {
            position: absolute;
            width: 90px;
            height: 100px;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 1px black;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 10px;
            box-sizing: border-box;
            z-index: 5;
        }
        .desktop-icon:active {
            cursor: grabbing;
        }
        .desktop-icon .icon-image {
            font-size: 48px;
            line-height: 1;
            margin-bottom: 8px;
        }
        .desktop-icon .icon-label {
            font-size: 12px;
            font-weight: normal;
            word-wrap: break-word;
            max-width: 100%;
        }

        /* PlayJockey Specific Styles */
        .playjockey-body-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background-color: #D4D0C8;
            padding: 5px;
            box-sizing: border-box;
        }

        .playjockey-input-bar {
            display: flex;
            margin-bottom: 5px;
            padding: 5px;
            background-color: #C0C0C0;
            border: 1px outset #FFFFFF;
            border-right-color: #808080;
            border-bottom-color: #808080;
            flex-shrink: 0;
        }

        #playJockeyLinkInput {
            flex-grow: 1;
            margin-right: 5px;
            border: 1px inset #7F7F7F;
            padding: 4px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #FFFFFF;
        }

        #playJockeyAddBtn {
            min-width: 60px;
            padding: 3px 8px;
            font-size: 11px;
        }

        .playjockey-player-area {
            flex-grow: 1;
            margin-bottom: 5px;
            border: 2px inset #808080;
            background-color: black;
            min-height: 150px;
            overflow: hidden;
        }

        #playJockeyPlayer {
            width: 100%;
            height: 100%;
        }

        .playjockey-tabs-bar {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            background-color: #C0C0C0;
            padding: 3px 3px 0 3px;
            border-bottom: 1px solid #808080;
            flex-shrink: 0;
            gap: 2px;
        }
        .playjockey-tab {
            padding: 6px 10px;
            border: 1px inset #FFFFFF;
            border-bottom: none;
            background-color: #D4D0C8;
            cursor: default;
            font-size: 10px;
            white-space: nowrap;
            border-top-left-radius: 3px;
            border-top-right-radius: 3px;
        }
        .playjockey-tab:hover {
            background-color: #E0E0E0;
        }
        .playjockey-tab.active {
            background-color: #F0F0F0;
            border-style: inset;
            border-bottom: 1px solid #F0F0F0;
            position: relative;
            z-index: 1;
            font-weight: bold;
        }
        .playjockey-add-tab-btn {
            padding: 6px 8px;
            margin-left: 0px;
            font-weight: bold;
        }


        .playjockey-controls-bar {
            display: flex;
            justify-content: center;
            padding: 5px 0px 5px 0px;
            flex-shrink: 0;
            gap: 5px;
            border-top: 1px solid #ACA899;
            background-color: #F0F0F0;
        }
        #playJockeyRandomBtn,
        #playJockeyAutoPlayBtn,
        #playJockeyRepeatBtn {
            min-width: 90px;
            padding: 3px 8px;
            font-size: 11px;
        }
        #playJockeyRandomBtn.random-on,
        #playJockeyAutoPlayBtn.autoplay-on,
        #playJockeyRepeatBtn.repeat-on {
            border-style: inset;
            font-weight: bold;
        }


        .playjockey-playlist-area {
            height: 100px;
            overflow-y: auto;
            border: 1px inset #7F7F7F;
            background-color: #FFFFFF;
            padding: 3px;
            flex-shrink: 0;
            border-top: none;
            position: relative;
            z-index: 0;
        }

        .playjockey-playlist-item {
            padding: 4px 6px;
            cursor: grab;
            border-bottom: 1px solid #ECE9D8;
            font-size: 10px;
            color: #000080;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            user-select: none;
        }
        .playjockey-playlist-item:hover {
            background-color: #000080;
            color: white;
        }
        .playjockey-playlist-item.playing {
            background-color: #005CFE;
            color: white;
            font-weight: bold;
        }
        .playjockey-playlist-item:last-child {
            border-bottom: none;
        }

        .playjockey-playlist-item.dragging {
            opacity: 0.5;
            background-color: #AED6F1;
        }
        .playjockey-playlist-item.drag-over-target-before {
            border-top: 2px dashed #005CFE;
        }
        .playjockey-playlist-item.drag-over-target-after {
            border-bottom: 2px dashed #005CFE;
        }


        .context-modal {
            display: none;
            position: fixed;
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            z-index: 2000;
            padding: 3px 0;
            min-width: 120px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
        }
        .context-modal-item {
            padding: 5px 12px;
            cursor: default;
            color: black;
        }
        .context-modal-item:hover {
            background-color: #005CFE;
            color: white;
        }

        /* Youtube Modal Specific Styles */
        #youtubeSearchResultsBody {
            max-height: 400px;
            overflow-y: auto;
        }

        .Youtube-result-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #ACA899;
            cursor: pointer;
            background-color: #FFFFFF;
        }
        .Youtube-result-item:hover {
            background-color: #E0E0E0;
        }
        .Youtube-result-item:last-child {
            border-bottom: none;
        }

        .Youtube-result-item img {
            width: 120px;
            height: 90px;
            margin-right: 10px;
            border: 1px solid #ACA899;
            object-fit: cover;
        }

        .Youtube-result-item-details {
            display: flex;
            flex-direction: column;
        }

        .Youtube-result-item-title {
            font-weight: bold;
            color: #0039A9;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .Youtube-result-item-channel {
            font-size: 10px;
            color: #555;
        }
        #youtubeSearchStatus {
            padding: 15px;
            font-size: 12px;
        }

    </style>
</head>
<body>

    <div class="desktop-icon" id="textEditorIcon" data-window-id="textEditorWindow">
        <div class="icon-image">üìÑ</div>
        <div class="icon-label">Jotter</div>
    </div>
    <div class="desktop-icon" id="trackerIcon" data-window-id="xpMainWindow">
        <div class="icon-image">üìÖ</div>
        <div class="icon-label">Habit Tracker</div>
    </div>
    <div class="desktop-icon" id="playJockeyIcon" data-window-id="playJockeyWindow">
        <div class="icon-image">‚ñ∂Ô∏è</div>
        <div class="icon-label">PlayJockey</div>
    </div>

    <div class="xp-window" id="xpMainWindow">
        <div class="title-bar" id="xpMainWindowTitleBar">
            <span class="title-bar-text">Habit Tracker</span>
            <div class="title-bar-controls">
                <button id="xpMainWindowMinimizeBtn" title="Minimize">0</button>
                <button id="xpMainWindowMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="xpMainWindowCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body">
            <div class="controls-bar" id="controlsBar">
                <div class="week-navigation">
                    <button id="prevWeekBtn" class="xp-button">< Prev Week</button>
                    <button id="thisWeekBtn" class="xp-button">This Week</button>
                    <button id="nextWeekBtn" class="xp-button">Next Week ></button>
                </div>
                <div class="controls-group">
                    <span id="currentWeekDisplay">Week X</span>
                    <span id="weekCountDisplay">Year Week: XX</span>
                </div>
                <div class="global-actions">
                    <button id="toggleViewBtn" class="xp-button">Day View</button>
                    <button id="showQuestsBtn" class="xp-button">Weekly Quests</button>
                    <button id="addAreaBtn" class="xp-button">New Area</button>
                </div>
            </div>
            <table id="gridTable">
                <thead>
                    <tr id="weekdayHeaders">
                        <th>Area</th>
                    </tr>
                </thead>
                <tbody id="gridBody">
                </tbody>
            </table>
        </div>
        <div class="resize-handle" id="xpMainWindowResizeHandle"></div>
    </div>

    <div class="xp-window" id="textEditorWindow">
        <div class="title-bar" id="textEditorWindowTitleBar">
            <span class="title-bar-text">Jotter</span>
            <div class="title-bar-controls">
                <button id="textEditorMinimizeBtn" title="Minimize">0</button>
                <button id="textEditorMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="textEditorCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="textEditorWindowBody">
            <iframe id="textEditorFrame" style="width: 100%; height: 100%; border: none;"></iframe>
        </div>
        <div class="resize-handle" id="textEditorResizeHandle"></div>
    </div>

    <div class="xp-window" id="playJockeyWindow">
        <div class="title-bar" id="playJockeyTitleBar">
            <span class="title-bar-text">PlayJockey</span>
            <div class="title-bar-controls">
                <button id="playJockeyMinimizeBtn" title="Minimize">0</button>
                <button id="playJockeyMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="playJockeyCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="playJockeyWindowBody">
            <div class="playjockey-body-container">
                <div class="playjockey-input-bar">
                    <input type="text" id="playJockeyLinkInput" placeholder="Paste YouTube Link or Search Query">
                    <button id="playJockeyAddBtn" class="xp-button">Add</button>
                </div>
                <div class="playjockey-player-area">
                    <div id="playJockeyPlayer"></div>
                </div>
                 <div class="playjockey-tabs-bar" id="playJockeyTabsBar">
                    </div>
                <div class="playjockey-playlist-area" id="playJockeyPlaylist">
                    </div>
                <div class="playjockey-controls-bar">
                    <button id="playJockeyRandomBtn" class="xp-button">Random: Off</button>
                    <button id="playJockeyAutoPlayBtn" class="xp-button">Auto Play: On</button>
                    <button id="playJockeyRepeatBtn" class="xp-button">Repeat: Off</button>
                </div>
            </div>
        </div>
        <div class="resize-handle" id="playJockeyResizeHandle"></div>
    </div>

    <div id="newAreaModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span id="newAreaModalTitle">Create New Area</span>
                <span class="close-button" data-modal-id="newAreaModal">r</span>
            </div>
            <div class="modal-body">
                <label for="newAreaName">Area Name:</label>
                <input type="text" id="newAreaName" placeholder="e.g., Fitness, Learning, Work">
            </div>
            <div class="modal-footer">
                <button id="saveNewAreaBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="newAreaModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="addEditAchievementModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span id="addEditAchievementModalTitle">Add Achievement</span>
                <span class="close-button" data-modal-id="addEditAchievementModal">r</span>
            </div>
            <div class="modal-body">
                <input type="hidden" id="achievementAreaName">
                <input type="hidden" id="achievementDayIndex">
                <input type="hidden" id="editingAchievementKey">
                <input type="hidden" id="editingAchievementId">
                <label>Type:</label>
                <input type="radio" name="achievementType" value="text" id="typeText" checked> Text
                <input type="radio" name="achievementType" value="image" id="typeImage"> Image
                <br><br>
                <div id="textInputDiv">
                    <label for="achievementText">Description:</label>
                    <textarea id="achievementText" rows="3"></textarea>
                </div>
                <div id="imageInputDiv" style="display:none;">
                    <label for="achievementImage">Upload Image:</label>
                    <input type="file" id="achievementImage" accept="image/*">
                    <p><small>Current image will be kept if no new image is selected during edit.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveAchievementBtn" class="xp-button">Save Achievement</button>
                <button class="xp-button" data-modal-id="addEditAchievementModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="questsModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Weekly Quests</span>
                <span class="close-button" data-modal-id="questsModal">r</span>
            </div>
            <div class="modal-body" id="questsList">
                </div>
            <div class="modal-footer">
                <button id="addQuestBtn" class="xp-button">Create New Quest</button>
                <button class="xp-button" data-modal-id="questsModal">Close</button>
            </div>
        </div>
    </div>
    <div id="confirmRemoveAreaModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Deletion</span>
                <span class="close-button" data-modal-id="confirmRemoveAreaModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemoveAreaMessage">Are you sure?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmRemoveBtn" class="xp-button">Confirm</button>
                <button class="xp-button" data-modal-id="confirmRemoveAreaModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmDeleteAchievementModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Achievement Deletion</span>
                <span class="close-button" data-modal-id="confirmDeleteAchievementModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this achievement? This will deduct its XP.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmDeleteAchievementBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmDeleteAchievementModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="createQuestModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Create New Quest</span>
                <span class="close-button" data-modal-id="createQuestModal">r</span>
            </div>
            <div class="modal-body">
                <label for="newQuestAreaName">Area:</label>
                <select id="newQuestAreaName"></select>
                <label for="newQuestDescription">Description:</label>
                <textarea id="newQuestDescription" rows="2" placeholder="e.g., Read 2 chapters"></textarea>
                <label for="newQuestTargetXP">Target XP to Earn in Area for Quest:</label>
                <input type="number" id="newQuestTargetXP" min="1" value="30">
                <label for="newQuestRewardXP">Quest Reward XP:</label>
                <input type="number" id="newQuestRewardXP" min="1" value="50">
            </div>
            <div class="modal-footer">
                <button id="saveNewQuestBtn" class="xp-button">Save Quest</button>
                <button class="xp-button" data-modal-id="createQuestModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmRefreshQuestModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Quest Refresh</span>
                <span class="close-button" data-modal-id="confirmRefreshQuestModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to refresh this quest? Current progress on this quest will be lost and a new quest will be generated.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmRefreshQuestBtn" class="xp-button">Refresh Quest</button>
                <button class="xp-button" data-modal-id="confirmRefreshQuestModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="changeBgImageModal" class="modal">
        <div class="modal-content" style="max-width: 550px;"> <div class="modal-title-bar">
                <span>Change Background</span>
                <span class="close-button" data-modal-id="changeBgImageModal">r</span>
            </div>
            <div class="modal-body">
                <p>Choose a background type for the application:</p>
                <div>
                    <label for="newBgImageInput">1. Upload image file:</label>
                    <input type="file" id="newBgImageInput" accept="image/*">
                     <p><small>Max 5MB recommended for file uploads due to browser storage limits.</small></p>
                    <button id="uploadBgImageBtn" class="xp-button" style="margin-top: 5px;">Upload File & Apply</button>
                </div>
                <hr>
                <div>
                    <label for="bgImageUrlInput">2. Enter image URL:</label>
                    <input type="text" id="bgImageUrlInput" placeholder="https://example.com/image.png">
                    <p><small>Using a URL is recommended for very large images from the web.</small></p>
                    <button id="applyBgImageUrlBtn" class="xp-button" style="margin-top: 5px;">Apply URL</button>
                </div>
                <hr>
                <div>
                    <label>3. Pick a solid color:</label>
                    <div id="bgColorSwatchesContainer" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; justify-content: center;">
                          </div>
                     <p style="margin-top: 8px;"><small>Click a color swatch to apply it immediately.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="xp-button" data-modal-id="changeBgImageModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="playJockeyContextMenu" class="context-modal">
        <div class="context-modal-item" id="pjContextRename">Rename Track</div>
        <div class="context-modal-item" id="pjContextRemove">Remove Track</div>
    </div>
    <div id="playJockeyTabContextMenu" class="context-modal">
        <div class="context-modal-item" id="pjTabContextRename">Rename Playlist</div>
        <div class="context-modal-item" id="pjTabContextRemove">Remove Playlist</div>
    </div>

    <div id="renamePlaylistModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Rename Playlist</span>
                <span class="close-button" data-modal-id="renamePlaylistModal">r</span>
            </div>
            <div class="modal-body">
                <label for="playlistNewNameInput">New playlist name:</label>
                <input type="text" id="playlistNewNameInput" placeholder="Enter playlist name">
            </div>
            <div class="modal-footer">
                <button id="saveRenamedPlaylistBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="renamePlaylistModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="confirmRemovePlaylistModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Playlist Deletion</span>
                <span class="close-button" data-modal-id="confirmRemovePlaylistModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemovePlaylistMessage">Are you sure you want to remove this playlist?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmFinalPlaylistRemoveBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmRemovePlaylistModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="youtubeSearchModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title-bar">
                <span>Youtube Results</span>
                <span class="close-button" data-modal-id="youtubeSearchModal">r</span>
            </div>
            <div class="modal-body" id="youtubeSearchResultsBody">
                <p id="youtubeSearchStatus" style="text-align: center; display: none;"></p>
            </div>
            <div class="modal-footer">
                <button class="xp-button" data-modal-id="youtubeSearchModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="renameTrackModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Rename Track</span>
                <span class="close-button" data-modal-id="renameTrackModal">r</span>
            </div>
            <div class="modal-body">
                <label for="trackNewNameInput">New track name:</label>
                <input type="text" id="trackNewNameInput" placeholder="Enter track name">
                <label for="trackNewArtistInput" style="margin-top:10px;">New artist name (optional):</label>
                <input type="text" id="trackNewArtistInput" placeholder="Enter artist name">
            </div>
            <div class="modal-footer">
                <button id="saveRenamedTrackBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="renameTrackModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="confirmRemoveTrackModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Track Deletion</span>
                <span class="close-button" data-modal-id="confirmRemoveTrackModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemoveTrackMessage">Are you sure you want to remove this track from the playlist?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmFinalTrackRemoveBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmRemoveTrackModal">Cancel</button>
            </div>
        </div>
    </div>

<script src="https://www.youtube.com/iframe_api"></script>

<script>
    "use strict";

    const WEEKDAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    const XP_PER_REGULAR_ACHIEVEMENT = 10;
    const XP_PER_QUEST_COMPLETED_BASE = 50;
    const STORAGE_KEY = 'lifeXpData_v1.10.0'; // Consider versioning if schema changes significantly
    const YOUTUBE_API_KEY = "AIzaSyCmfQymtVEL3b_YEi7FlhpdNX5MkGsrNDM"; // <-- REPLACE WITH YOUR YOUTUBE API KEY
    const MAX_WEEKLY_QUESTS = 5;
    const ICON_GRID_SIZE = 25;

    let minTrackerAppWidth;
    const MIN_TRACKER_APP_HEIGHT = 250;
    const MIN_TEXTEDITOR_WIDTH = 450;
    const MIN_TEXTEDITOR_HEIGHT = 300;
    const MIN_PLAYJOCKEY_WIDTH = 480;
    const MIN_PLAYJOCKEY_HEIGHT = 425;


    const STANDARD_COLORS = [
        { name: 'Black', value: '#000000' }, { name: 'Silver', value: '#C0C0C0' },
        { name: 'Gray', value: '#808080' }, { name: 'White', value: '#FFFFFF' },
        { name: 'Maroon', value: '#800000' }, { name: 'Red', value: '#FF0000' },
        { name: 'Purple', value: '#800080' }, { name: 'Fuchsia', value: '#FF00FF' },
        { name: 'Green', value: '#008000' }, { name: 'Lime', value: '#00FF00' },
        { name: 'Olive', value: '#808000' }, { name: 'Yellow', value: '#FFFF00' },
        { name: 'Navy', value: '#000080' }, { name: 'Blue', value: '#0000FF' },
        { name: 'Teal', value: '#008080' }, { name: 'Aqua', value: '#00FFFF' },
        { name: 'Orange', value: '#FFA500' }, { name: 'Brown', value: '#A52A2A' },
        { name: 'Pink', value: '#FFC0CB' }, { name: 'Gold', value: '#FFD700' },
        { name: 'Dark Green', value: '#006400' }, { name: 'Light Blue', value: '#ADD8E6' },
        { name: 'Indigo', value: '#4B0082' }, { name: 'Violet', value: '#EE82EE' },
        { name: 'Coral', value: '#FF7F50' }, { name: 'Sky Blue', value: '#87CEEB' }
    ];

    const MODAL_IDS = {
        NEW_AREA: 'newAreaModal',
        ADD_EDIT_ACHIEVEMENT: 'addEditAchievementModal',
        QUESTS: 'questsModal',
        CONFIRM_REMOVE_AREA: 'confirmRemoveAreaModal',
        CONFIRM_DELETE_ACHIEVEMENT: 'confirmDeleteAchievementModal',
        CREATE_QUEST: 'createQuestModal',
        CONFIRM_REFRESH_QUEST: 'confirmRefreshQuestModal',
        CHANGE_BG_IMAGE: 'changeBgImageModal',
        RENAME_PLAYLIST: 'renamePlaylistModal',
        CONFIRM_REMOVE_PLAYLIST: 'confirmRemovePlaylistModal',
        Youtube: 'youtubeSearchModal',
        RENAME_TRACK: 'renameTrackModal',
        CONFIRM_REMOVE_TRACK: 'confirmRemoveTrackModal'
    };

    const getById = (id) => document.getElementById(id);

    function decodeHtmlEntities(text) {
        if (typeof text !== 'string') {
            return text;
        }
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }

    const DOM = {
        xpMainWindow: getById('xpMainWindow'),
        xpMainWindowTitleBar: getById('xpMainWindowTitleBar'),
        xpMainWindowResizeHandle: getById('xpMainWindowResizeHandle'),
        xpMainWindowMinimizeBtn: getById('xpMainWindowMinimizeBtn'),
        xpMainWindowMaximizeBtn: getById('xpMainWindowMaximizeBtn'),
        xpMainWindowCloseBtn: getById('xpMainWindowCloseBtn'),
        weekdayHeaders: getById('weekdayHeaders'),
        gridBody: getById('gridBody'),
        addAreaBtn: getById('addAreaBtn'),
        prevWeekBtn: getById('prevWeekBtn'),
        nextWeekBtn: getById('nextWeekBtn'),
        thisWeekBtn: getById('thisWeekBtn'),
        toggleViewBtn: getById('toggleViewBtn'),
        currentWeekDisplay: getById('currentWeekDisplay'),
        weekCountDisplay: getById('weekCountDisplay'),
        showQuestsBtn: getById('showQuestsBtn'),
        controlsBar: getById('controlsBar'),

        textEditorWindow: getById('textEditorWindow'),
        textEditorWindowTitleBar: getById('textEditorWindowTitleBar'),
        textEditorWindowBody: getById('textEditorWindowBody'),
        textEditorFrame: getById('textEditorFrame'),
        textEditorResizeHandle: getById('textEditorResizeHandle'),
        textEditorMinimizeBtn: getById('textEditorMinimizeBtn'),
        textEditorMaximizeBtn: getById('textEditorMaximizeBtn'),
        textEditorCloseBtn: getById('textEditorCloseBtn'),

        playJockeyWindow: getById('playJockeyWindow'),
        playJockeyTitleBar: getById('playJockeyTitleBar'),
        playJockeyWindowBody: getById('playJockeyWindowBody'),
        playJockeyResizeHandle: getById('playJockeyResizeHandle'),
        playJockeyMinimizeBtn: getById('playJockeyMinimizeBtn'),
        playJockeyMaximizeBtn: getById('playJockeyMaximizeBtn'),
        playJockeyCloseBtn: getById('playJockeyCloseBtn'),
        playJockeyLinkInput: getById('playJockeyLinkInput'),
        playJockeyAddBtn: getById('playJockeyAddBtn'),
        playJockeyPlayer: getById('playJockeyPlayer'),
        playJockeyTabsBar: getById('playJockeyTabsBar'),
        playJockeyPlaylist: getById('playJockeyPlaylist'),
        playJockeyContextMenu: getById('playJockeyContextMenu'),
        pjContextRenameBtn: getById('pjContextRename'),
        pjContextRemoveBtn: getById('pjContextRemove'),
        playJockeyTabContextMenu: getById('playJockeyTabContextMenu'),
        pjTabContextRenameBtn: getById('pjTabContextRename'),
        pjTabContextRemoveBtn: getById('pjTabContextRemove'),
        playJockeyRandomBtn: getById('playJockeyRandomBtn'),
        playJockeyAutoPlayBtn: getById('playJockeyAutoPlayBtn'),
        playJockeyRepeatBtn: getById('playJockeyRepeatBtn'),


        textEditorIcon: getById('textEditorIcon'),
        trackerIcon: getById('trackerIcon'),
        playJockeyIcon: getById('playJockeyIcon'),

        newAreaModal: getById(MODAL_IDS.NEW_AREA),
        newAreaNameInput: getById('newAreaName'),
        saveNewAreaBtn: getById('saveNewAreaBtn'),
        addEditAchievementModal: getById(MODAL_IDS.ADD_EDIT_ACHIEVEMENT),
        addEditAchievementModalTitle: getById('addEditAchievementModalTitle'),
        achievementAreaNameInput: getById('achievementAreaName'),
        achievementDayIndexInput: getById('achievementDayIndex'),
        editingAchievementKeyInput: getById('editingAchievementKey'),
        editingAchievementIdInput: getById('editingAchievementId'),
        achievementTypeRadios: document.getElementsByName('achievementType'),
        textInputDiv: getById('textInputDiv'),
        imageInputDiv: getById('imageInputDiv'),
        achievementTextInput: getById('achievementText'),
        achievementImageInput: getById('achievementImage'),
        saveAchievementBtn: getById('saveAchievementBtn'),
        questsModal: getById(MODAL_IDS.QUESTS),
        questsList: getById('questsList'),
        addQuestBtn: getById('addQuestBtn'),
        createQuestModal: getById(MODAL_IDS.CREATE_QUEST),
        newQuestAreaNameSelect: getById('newQuestAreaName'),
        newQuestDescriptionInput: getById('newQuestDescription'),
        newQuestTargetXPInput: getById('newQuestTargetXP'),
        newQuestRewardXPInput: getById('newQuestRewardXP'),
        saveNewQuestBtn: getById('saveNewQuestBtn'),
        confirmRefreshQuestModal: getById(MODAL_IDS.CONFIRM_REFRESH_QUEST),
        confirmRefreshQuestBtn: getById('confirmRefreshQuestBtn'),
        confirmRemoveAreaModal: getById(MODAL_IDS.CONFIRM_REMOVE_AREA),
        confirmRemoveAreaMessage: getById('confirmRemoveAreaMessage'),
        confirmRemoveBtn: getById('confirmRemoveBtn'),
        confirmDeleteAchievementModal: getById(MODAL_IDS.CONFIRM_DELETE_ACHIEVEMENT),
        confirmDeleteAchievementBtn: getById('confirmDeleteAchievementBtn'),
        changeBgImageModal: getById(MODAL_IDS.CHANGE_BG_IMAGE),
        newBgImageInput: getById('newBgImageInput'),
        uploadBgImageBtn: getById('uploadBgImageBtn'),
        bgImageUrlInput: getById('bgImageUrlInput'),
        applyBgImageUrlBtn: getById('applyBgImageUrlBtn'),
        bgColorSwatchesContainer: getById('bgColorSwatchesContainer'),

        renamePlaylistModal: getById(MODAL_IDS.RENAME_PLAYLIST),
        playlistNewNameInput: getById('playlistNewNameInput'),
        saveRenamedPlaylistBtn: getById('saveRenamedPlaylistBtn'),
        confirmRemovePlaylistModal: getById(MODAL_IDS.CONFIRM_REMOVE_PLAYLIST),
        confirmRemovePlaylistMessage: getById('confirmRemovePlaylistMessage'),
        confirmFinalPlaylistRemoveBtn: getById('confirmFinalPlaylistRemoveBtn'),

        youtubeSearchModal: getById(MODAL_IDS.Youtube),
        youtubeSearchResultsBody: getById('youtubeSearchResultsBody'),
        youtubeSearchStatus: getById('youtubeSearchStatus'),

        renameTrackModal: getById(MODAL_IDS.RENAME_TRACK),
        trackNewNameInput: getById('trackNewNameInput'),
        trackNewArtistInput: getById('trackNewArtistInput'),
        saveRenamedTrackBtn: getById('saveRenamedTrackBtn'),
        confirmRemoveTrackModal: getById(MODAL_IDS.CONFIRM_REMOVE_TRACK),
        confirmRemoveTrackMessage: getById('confirmRemoveTrackMessage'),
        confirmFinalTrackRemoveBtn: getById('confirmFinalTrackRemoveBtn'),

        modalCloseButtons: null
    };
    DOM.modalCloseButtons = document.querySelectorAll('.modal .close-button, .modal .xp-button[data-modal-id]');

    let defaultAppData; // Defined in loadData/init context

    let appData = { // This will be properly initialized by loadData
        areas: [],
        achievements: {},
        quests: {},
        currentWeekStartDate: null,
        viewMode: 'week',
        selectedDayIndex: 0,
        windowStates: {},
        iconPositions: {},
        customBgImage: null,
        customBgColor: null,
        playJockeyPlaylists: [],
        playJockeyCurrentPlaylistId: null,
        playJockeyCurrentVideo: null,
        playJockeyAutoPlayEnabled: true,
        playJockeyRandomEnabled: false,
        playJockeyRepeatState: "off",
        playJockeyRandomHistory: []
    };

    let lastNormalStates = {};
    let highestZIndex = 9;

    let activeDragWindow = null;
    let activeResizeWindow = null;
    let dragOffsetX, dragOffsetY;
    let resizeInitialX, resizeInitialY, resizeInitialWidth, resizeInitialHeight;

    let activeDragIcon = null;
    let iconDragOffsetX, iconDragOffsetY;

    let pjDraggedItem = null;

    let ytPlayerInstance = null;
    let isYouTubeApiReady = false;
    let pendingVideoToLoad = null;


    function parseYYYYMMDDToLocalDate(dateString) {
        const [year, month, day] = dateString.split('-').map(Number);
        return new Date(year, month - 1, day);
    }

    function getDayOfYear(date) {
        const startOfYear = new Date(date.getFullYear(), 0, 0);
        const diff = date - startOfYear;
        const oneDay = 1000 * 60 * 60 * 24;
        return Math.floor(diff / oneDay);
    }

    function applyCurrentBackgroundStyle() {
        if (appData.customBgColor) {
            document.body.style.backgroundImage = 'none';
            document.body.style.backgroundColor = appData.customBgColor;
        } else if (appData.customBgImage) {
            document.body.style.backgroundColor = ''; // Clear solid color
            document.body.style.backgroundImage = `url('${appData.customBgImage}')`;
        } else {
            // Default background
            document.body.style.backgroundColor = '#3A6EA5';
            document.body.style.backgroundImage = "url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png')";
        }
    }

    function init() {
        loadData(); // Initializes appData and defaultAppData
        applyCurrentBackgroundStyle();
        populateColorSwatches();
        initDesktopIcons();

        if (appData.viewMode === 'week') {
            minTrackerAppWidth = 905;
        } else {
            minTrackerAppWidth = 375;
        }
        if (appData.viewMode !== 'week' && appData.viewMode !== 'day') {
             console.warn("Invalid viewMode loaded, defaulting to week.");
             appData.viewMode = 'week';
             minTrackerAppWidth = 905;
        }

        if (!appData.currentWeekStartDate) {
            appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        }
        if (appData.viewMode === 'day' && (appData.selectedDayIndex === undefined || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) ) {
             appData.selectedDayIndex = 0;
        }

        initWindowInteractions('xpMainWindow');
        restoreWindowState('xpMainWindow'); // This will now correctly handle hiddenByUser

        DOM.textEditorFrame.srcdoc = getTextEditorHTMLContent();
        initWindowInteractions('textEditorWindow');
        restoreWindowState('textEditorWindow'); // This will now correctly handle hiddenByUser

        initWindowInteractions('playJockeyWindow');
        restoreWindowState('playJockeyWindow'); // This will now correctly handle hiddenByUser

        // Update button states after restoring, as restoreWindowState calls updateMinMaxButtonStates
        updateMinMaxButtonStates('xpMainWindow');
        updateMinMaxButtonStates('textEditorWindow');
        updateMinMaxButtonStates('playJockeyWindow');


        renderPlayJockeyTabs();
        renderPlayJockeyPlaylist();
        updatePlayJockeyAutoPlayButtonState();
        updatePlayJockeyRandomButtonState();
        updatePlayJockeyRepeatButtonState();


        if (appData.playJockeyCurrentVideo && (isYouTubeApiReady || typeof YT !== 'undefined')) {
            const currentPlaylist = getCurrentPlayJockeyPlaylist();
            if (currentPlaylist && currentPlaylist.videos.some(v => v.id === appData.playJockeyCurrentVideo.id)) {
                 playYouTubeVideoById(appData.playJockeyCurrentVideo.videoId, appData.playJockeyAutoPlayEnabled);
            } else {
                appData.playJockeyCurrentVideo = null; // Video no longer in playlist
            }
        } else if (appData.playJockeyCurrentVideo) { // API not ready, video queued
            const currentPlaylist = getCurrentPlayJockeyPlaylist();
             if (currentPlaylist && currentPlaylist.videos.some(v => v.id === appData.playJockeyCurrentVideo.id)) {
                pendingVideoToLoad = { videoId: appData.playJockeyCurrentVideo.videoId, autoplayIntent: appData.playJockeyAutoPlayEnabled };
            } else {
                appData.playJockeyCurrentVideo = null;
            }
        }

        let maxLoadedWindowZ = highestZIndex; // highestZIndex starts at 9
        ['xpMainWindow', 'textEditorWindow', 'playJockeyWindow'].forEach(windowId => {
            if (appData.windowStates[windowId] && appData.windowStates[windowId].zIndex) {
                maxLoadedWindowZ = Math.max(maxLoadedWindowZ, parseInt(appData.windowStates[windowId].zIndex));
            }
        });
        highestZIndex = maxLoadedWindowZ;


        addEventListeners();
        initPlayJockeyContextMenu();
        initPlayJockeyTabContextMenu();


        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        handleAppWindowResize(); // Initial check

        const trackerWindowObserver = new ResizeObserver(handleAppWindowResize);
        trackerWindowObserver.observe(DOM.xpMainWindow);

        saveData(); // Save potentially normalized states from restoreWindowState
    }

    function initDesktopIcons() {
        const icons = [DOM.textEditorIcon, DOM.trackerIcon, DOM.playJockeyIcon];
        const iconData = [
            { id: 'trackerIcon', defaultX: 0, defaultY: 0, element: DOM.trackerIcon },
            { id: 'textEditorIcon', defaultX: 0, defaultY: 100, element: DOM.textEditorIcon },
            { id: 'playJockeyIcon', defaultX: 0, defaultY: 200, element: DOM.playJockeyIcon }
        ];

        iconData.forEach(data => {
            const iconElement = data.element;
            if (!iconElement) return;

            const iconId = iconElement.id;
            if (appData.iconPositions && appData.iconPositions[iconId]) {
                iconElement.style.left = appData.iconPositions[iconId].x + 'px';
                iconElement.style.top = appData.iconPositions[iconId].y + 'px';
            } else {
                const { x: finalX, y: finalY } = findNonCollidingPosition(iconElement, data.defaultX, data.defaultY);

                iconElement.style.left = finalX + 'px';
                iconElement.style.top = finalY + 'px';

                if (!appData.iconPositions) appData.iconPositions = {};
                appData.iconPositions[iconId] = { x: finalX, y: finalY };
            }

            iconElement.addEventListener('mousedown', handleIconMouseDown);
            iconElement.addEventListener('dblclick', handleIconDoubleClick);
        });
        // saveData(); // Called at the end of init
    }


    function handleIconMouseDown(e) {
        if (e.button !== 0 || activeDragWindow || activeResizeWindow) return;

        activeDragIcon = e.currentTarget;
        const windowId = activeDragIcon.dataset.windowId;
        const windowEl = getById(windowId);
        if(windowEl && windowEl.style.display !== 'none' && !windowEl.classList.contains('minimized')) {
             bringToFront(windowEl);
        }

        iconDragOffsetX = e.clientX - activeDragIcon.offsetLeft;
        iconDragOffsetY = e.clientY - activeDragIcon.offsetTop;

        activeDragIcon.style.cursor = 'grabbing';
        activeDragIcon.style.zIndex = '6'; // Higher than other icons, lower than windows

        document.addEventListener('mousemove', handleIconMouseMove);
        document.addEventListener('mouseup', handleIconMouseUp);
        e.preventDefault();
    }

    function handleIconMouseMove(e) {
        if (!activeDragIcon) return;
        let newX = e.clientX - iconDragOffsetX;
        let newY = e.clientY - iconDragOffsetY;

        const bodyRect = document.body.getBoundingClientRect();
        const iconWidth = activeDragIcon.offsetWidth || 90;
        const iconHeight = activeDragIcon.offsetHeight || 100;

        newX = Math.max(0, Math.min(newX, bodyRect.width - iconWidth));
        newY = Math.max(0, Math.min(newY, bodyRect.height - iconHeight));

        activeDragIcon.style.left = newX + 'px';
        activeDragIcon.style.top = newY + 'px';
    }

    function findNonCollidingPosition(draggedIcon, initialX, initialY) {
        let currentX = initialX;
        let currentY = initialY;
        let attempt = 0;
        const maxAttempts = 100; // Increased attempts
        const iconWidth = draggedIcon.offsetWidth || 90;
        const iconHeight = draggedIcon.offsetHeight || 100;

        const checkCollisionAt = (x, y, currentDraggedIcon) => {
            const iconsToCompare = [DOM.textEditorIcon, DOM.trackerIcon, DOM.playJockeyIcon].filter(
                icon => icon && icon !== currentDraggedIcon && icon.style.left && icon.style.top // Ensure other icons are placed
            );

            for (const otherIcon of iconsToCompare) {
                const otherLeft = parseInt(otherIcon.style.left, 10);
                const otherTop = parseInt(otherIcon.style.top, 10);
                const otherWidth = otherIcon.offsetWidth || 90;
                const otherHeight = otherIcon.offsetHeight || 100;

                // Standard collision detection
                if (x < otherLeft + otherWidth &&
                    x + iconWidth > otherLeft &&
                    y < otherTop + otherHeight &&
                    y + iconHeight > otherTop) {
                    return true; // Collision detected
                }
            }
            return false; // No collision
        };
        
        // Initial snapped position check
        let snappedX = Math.round(initialX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        let snappedY = Math.round(initialY / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        snappedX = Math.max(0, Math.min(snappedX, document.body.clientWidth - iconWidth));
        snappedY = Math.max(0, Math.min(snappedY, document.body.clientHeight - iconHeight));


        if (!checkCollisionAt(snappedX, snappedY, draggedIcon)) {
            return { x: snappedX, y: snappedY };
        }

        // Spiral search if initial position collides
        let layer = 1;
        while (attempt < maxAttempts) {
            const positionsToTry = [];
            // Top and bottom rows of the current layer
            for (let i = -layer; i <= layer; i++) {
                positionsToTry.push({ x: snappedX + i * ICON_GRID_SIZE, y: snappedY - layer * ICON_GRID_SIZE }); // Top
                if (layer !== 0) positionsToTry.push({ x: snappedX + i * ICON_GRID_SIZE, y: snappedY + layer * ICON_GRID_SIZE }); // Bottom
            }
            // Left and right columns of the current layer (excluding corners already covered)
            for (let i = -layer + 1; i < layer; i++) {
                positionsToTry.push({ x: snappedX - layer * ICON_GRID_SIZE, y: snappedY + i * ICON_GRID_SIZE }); // Left
                if (layer !== 0) positionsToTry.push({ x: snappedX + layer * ICON_GRID_SIZE, y: snappedY + i * ICON_GRID_SIZE }); // Right
            }

            for (const pos of positionsToTry) {
                attempt++;
                if (attempt >= maxAttempts) break;

                let testX = pos.x;
                let testY = pos.y;

                // Ensure within bounds and snap
                testX = Math.max(0, Math.min(testX, document.body.clientWidth - iconWidth));
                testY = Math.max(0, Math.min(testY, document.body.clientHeight - iconHeight));
                testX = Math.round(testX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
                testY = Math.round(testY / ICON_GRID_SIZE) * ICON_GRID_SIZE;


                if (!checkCollisionAt(testX, testY, draggedIcon)) {
                    return { x: testX, y: testY };
                }
            }
            if (attempt >= maxAttempts) break;
            layer++;
            // Safety break if layer becomes excessively large
            if (layer * ICON_GRID_SIZE > Math.max(document.body.clientWidth, document.body.clientHeight) && attempt > 20) {
                 console.warn("Collision search boundary too large for icon placement. Layer:", layer); break;
            }
        }

        console.warn("Could not find a non-colliding position for icon " + draggedIcon.id + " after " + attempt + " attempts. Using original snapped position which might collide.");
        return { x: snappedX, y: snappedY }; // Fallback to original snapped position
    }


    function handleIconMouseUp() {
        if (!activeDragIcon) return;

        activeDragIcon.style.zIndex = '5'; // Reset z-index

        let finalX = activeDragIcon.offsetLeft;
        let finalY = activeDragIcon.offsetTop;

        // Snap to grid
        let snappedX = Math.round(finalX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        let snappedY = Math.round(finalY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

        const iconWidth = activeDragIcon.offsetWidth || 90;
        const iconHeight = activeDragIcon.offsetHeight || 100;
        // Ensure snapped position is within viewport bounds
        snappedX = Math.max(0, Math.min(snappedX, document.body.clientWidth - iconWidth));
        snappedY = Math.max(0, Math.min(snappedY, document.body.clientHeight - iconHeight));
        // Re-snap after clamping to ensure it's on the grid
        snappedX = Math.round(snappedX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        snappedY = Math.round(snappedY / ICON_GRID_SIZE) * ICON_GRID_SIZE;


        const { x: finalSnappedX, y: finalSnappedY } = findNonCollidingPosition(activeDragIcon, snappedX, snappedY);

        activeDragIcon.style.left = finalSnappedX + 'px';
        activeDragIcon.style.top = finalSnappedY + 'px';

        const iconId = activeDragIcon.id;
        if (!appData.iconPositions) appData.iconPositions = {};
        appData.iconPositions[iconId] = { x: finalSnappedX, y: finalSnappedY };
        saveData();

        activeDragIcon.style.cursor = 'grab';
        activeDragIcon = null;
        document.removeEventListener('mousemove', handleIconMouseMove);
        document.removeEventListener('mouseup', handleIconMouseUp);
    }

    function handleIconDoubleClick(e) {
        const iconElement = e.currentTarget;
        const windowId = iconElement.dataset.windowId;
        const windowElement = getById(windowId);

        if (!windowElement) return;

        let state = appData.windowStates[windowId];
        // Ensure state exists and is fully initialized (restoreWindowState should handle this on load)
        if (!state) {
            console.warn(`State for window ${windowId} was missing on double click. Attempting to restore/initialize.`);
            restoreWindowState(windowId); // Try to initialize it fully
            state = appData.windowStates[windowId]; // Re-fetch
            if(!state) {
                console.error(`Failed to initialize state for ${windowId} on double click.`);
                return;
            }
        }


        if (state.hiddenByUser || windowElement.style.display === 'none') {
            state.hiddenByUser = false;
            state.minimized = false; // When reopening a closed window, it should not be minimized
            
            windowElement.style.display = 'flex'; // Make visible before restore if it was truly 'none'
            windowElement.classList.remove('minimized');

            // Restore all visual aspects (dimensions, position) based on the now updated state.
            // restoreWindowState will use state.hiddenByUser = false.
            // If dimensions were null, it will call setWindowDefaults.
            restoreWindowState(windowId); 

            if (windowId === 'playJockeyWindow') {
                if (appData.playJockeyCurrentVideo && !ytPlayerInstance && isYouTubeApiReady) {
                    playYouTubeVideoById(appData.playJockeyCurrentVideo.videoId, false);
                } else if (pendingVideoToLoad && isYouTubeApiReady) {
                    playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
                    pendingVideoToLoad = null;
                }
            }
        } else if (state.minimized || windowElement.classList.contains('minimized')) {
            // Window is visible but minimized, so "maximize" it (handles restore to normal or full screen).
            maximizeWindow(windowId); 
        }
        
        bringToFront(windowElement);
        saveWindowState(windowId); // Save new state (e.g., hiddenByUser: false)
    }


    function getTextEditorHTMLContent() {
        return `
<html lang="en">
<head>
    <title>Jotter</title>
    <style>
        html, body { 
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
        }
        body {
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #ECE9D8;
            color: #000000;
            display: flex;
            flex-direction: column;
        }
        [contenteditable]:focus { outline: none; }

        .jotter-menu-bar {
            background-color: #ECE9D8;
            padding: 2px 3px;
            border-bottom: 1px solid #ACA899;
            display: flex;
            flex-shrink: 0; 
            user-select: none;
            color: #000000;
        }
        .jotter-menu-item {
            padding: 3px 8px;
            cursor: default;
            position: relative;
            color: inherit;
        }
        .jotter-menu-item:hover {
            background-color: #005CFE;
            color: white;
        }
        .jotter-dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            z-index: 100;
            min-width: 150px; 
            padding: 2px 0;
            color: #000000;
        }
        .jotter-dropdown-item {
            padding: 4px 12px 4px 25px;
            cursor: default;
            white-space: nowrap;
            position: relative;
            color: inherit;
            display: flex; 
            align-items: center; 
        }
        .jotter-dropdown-item:hover:not(.disabled) {
            background-color: #005CFE;
            color: white;
        }
        .jotter-dropdown-item.disabled {
            color: #7F7F7F !important;
            background-color: #ECE9D8 !important;
            cursor: default;
        }
        .jotter-menu-item:focus-within .jotter-dropdown-content,
        .jotter-menu-item.open .jotter-dropdown-content {
            display: block;
        }
        .jotter-menu-item .underline {
            text-decoration: underline;
        }

        #editorArea {
            border: 1px solid #7F7F7F;
            padding: 5px;
            background-color: white;
            overflow-y: auto;
            font-family: 'Lucida Console', Monaco, monospace;
            font-size: 14px; 
            line-height: 1.4;
            color: #000000;
            white-space: pre-wrap; 
            word-wrap: break-word;
            box-sizing: border-box;
            margin: 5px; 
            flex-grow: 1; /* Let editor area take remaining space */
        }

        .font-size-control-container {
            display: flex;
            align-items: center;
            padding: 0px 5px 0px 15px !important;
        }
        .font-size-control-container span {
            margin-right: 8px;
        }
        .font-size-btn {
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 10px;
            border: 1px outset #7F7F7F;
            background-color: #ECE9D8;
            width: 20px;
            height: 20px;
            line-height: 18px; 
            text-align: center;
            padding: 0;
            cursor: default;
            color: black;
        }
        .font-size-btn:active {
            border-style: inset;
        }
        .font-size-input {
            width: 30px;
            height: 18px;
            border: 1px solid #7F7F7F;
            text-align: center;
            margin: 0 3px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            padding: 1px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="jotter-menu-bar" id="jotterMenuBarInFrame">
        <div class="jotter-menu-item" tabindex="0">
            <span class="underline">F</span>ile
            <div class="jotter-dropdown-content">
                <div class="jotter-dropdown-item" id="fileSaveInFrame">Save</div>
            </div>
        </div>
        <div class="jotter-menu-item" tabindex="0">
            <span class="underline">V</span>iew
            <div class="jotter-dropdown-content">
                <div class="jotter-dropdown-item font-size-control-container" id="fontSizeControlItemInFrame">
                    <span>Font Size:</span>
                    <button class="font-size-btn" id="fontDecrementBtnInFrame">-</button>
                    <input type="number" class="font-size-input" id="fontSizeInputInFrame" value="14" min="8" max="72">
                    <button class="font-size-btn" id="fontIncrementBtnInFrame">+</button>
                </div>
            </div>
        </div>
    </div>

    <div id="editorArea" contenteditable="true"></div>

    <script>
        const editorArea = document.getElementById('editorArea');
        const jotterMenuBar = document.getElementById('jotterMenuBarInFrame'); 
        const bodyElement = document.body; 
        let activeMenu = null;

        const fontDecrementBtn = document.getElementById('fontDecrementBtnInFrame');
        const fontIncrementBtn = document.getElementById('fontIncrementBtnInFrame');
        const fontSizeInput = document.getElementById('fontSizeInputInFrame');
        
        function adjustEditorHeight() {
            // Now that editorArea has flex-grow: 1, this might not be strictly necessary
            // if the parent (.window-body of the main page) correctly sizes the iframe.
            // However, keeping it for internal consistency within the iframe or if direct iframe resizing happens.
            const menuBarHeight = jotterMenuBar.offsetHeight;
            const bodyHeight = bodyElement.clientHeight; // Use clientHeight for available space
            const editorMarginTop = parseInt(window.getComputedStyle(editorArea).marginTop) || 0;
            const editorMarginBottom = parseInt(window.getComputedStyle(editorArea).marginBottom) || 0;
            
            let newEditorHeight = bodyHeight - menuBarHeight - editorMarginTop - editorMarginBottom;
            newEditorHeight = Math.max(0, newEditorHeight); 
            // editorArea.style.height = newEditorHeight + 'px'; // Only set if not using flex-grow
        }

        jotterMenuBar.querySelectorAll('.jotter-menu-bar > .jotter-menu-item').forEach(menuItem => {
            menuItem.addEventListener('click', (event) => {
                event.stopPropagation();
                if (event.target.closest('.font-size-control-container')) {
                    if(!menuItem.classList.contains('open')) {
                         if (activeMenu && activeMenu !== menuItem) activeMenu.classList.remove('open');
                         menuItem.classList.add('open');
                         activeMenu = menuItem;
                    }
                    return;
                }

                if (activeMenu && activeMenu !== menuItem) {
                    activeMenu.classList.remove('open');
                }
                menuItem.classList.toggle('open');
                activeMenu = menuItem.classList.contains('open') ? menuItem : null;
            });

            menuItem.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' || event.key === ' ') {
                    event.preventDefault();
                    if (event.target === menuItem || menuItem.contains(event.target) && !event.target.closest('.jotter-dropdown-content .jotter-menu-item')) {
                        menuItem.click();
                    }
                }
            });
        });
        
        window.addEventListener('click', (event) => {
            if (activeMenu && !activeMenu.contains(event.target) && !event.target.closest('.font-size-control-container')) {
                activeMenu.classList.remove('open');
                activeMenu = null;
            }
        });

        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && activeMenu) {
                activeMenu.classList.remove('open');
                activeMenu.focus(); 
                activeMenu = null;
            }
        });

        const fileSaveButton = document.getElementById('fileSaveInFrame');
        fileSaveButton.addEventListener('click', (event) => {
             event.stopPropagation();
            performSave();
        });

        function performSave() {
            let filename = prompt("Filename:", "jotter_content.html");
            if (filename) {
                let htmlContent = \`<!DOCTYPE html>
<html>
<head>
    <title>Saved Content</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: 'Lucida Console', Monaco, monospace; font-size: \${editorArea.style.fontSize || '14px'}; margin: 20px; white-space: pre-wrap; word-wrap: break-word; }
    </style>
</head>
<body>
    \${editorArea.innerHTML}
</body>
</html>\`;
                let blob = new Blob([htmlContent], { type: "text/html" });
                let url = URL.createObjectURL(blob);
                let downloadLink = document.createElement("a");
                downloadLink.setAttribute("href", url);
                downloadLink.setAttribute("download", filename);
                downloadLink.click();
                URL.revokeObjectURL(url);
            }
            if (activeMenu) {
                 activeMenu.classList.remove('open');
                 activeMenu = null;
            }
        }

        editorArea.addEventListener('keydown', function(e) {
            if (e.ctrlKey && (e.key === 's' || e.key === 'S')) {
                e.preventDefault();
                performSave();
            }
        });
        // Also listen on window for Ctrl+S in case editor doesn't have focus but menu was interacted with
        window.addEventListener('keydown', function(e) { 
            if (e.ctrlKey && (e.key === 's' || e.key === 'S') && !e.target.closest('#editorArea')) {
                 // Only trigger if focus is not in editor, to avoid double-trigger
                e.preventDefault();
                performSave();
            }
        });

        function applyFontSize(size) {
            const newSize = Math.max(8, Math.min(72, parseInt(size))); 
            if (!isNaN(newSize)) {
                editorArea.style.fontSize = newSize + 'px';
                fontSizeInput.value = newSize;
            }
        }

        fontDecrementBtn.addEventListener('click', (event) => {
            event.stopPropagation(); 
            let currentSize = parseInt(fontSizeInput.value) || 14;
            applyFontSize(currentSize - 1);
        });

        fontIncrementBtn.addEventListener('click', (event) => {
            event.stopPropagation(); 
            let currentSize = parseInt(fontSizeInput.value) || 14;
            applyFontSize(currentSize + 1);
        });

        fontSizeInput.addEventListener('change', () => {
            applyFontSize(fontSizeInput.value);
        });
        fontSizeInput.addEventListener('click', (event) => {
            event.stopPropagation(); 
        });
         fontSizeInput.addEventListener('input', () => { 
            let val = parseInt(fontSizeInput.value);
            if(!isNaN(val) && val >=8 && val <=72){
                 editorArea.style.fontSize = val + 'px';
            }
        });

        applyFontSize(fontSizeInput.value);
        editorArea.focus();

        // adjustEditorHeight(); // Initial call
        // Using ResizeObserver on the iframe's body can be problematic for cross-origin or if the iframe itself is resized.
        // The parent page's ResizeObserver on the #textEditorWindow element is more reliable for overall window size changes.
        // window.addEventListener('resize', adjustEditorHeight); // Fallback if needed
    <\/script>
</body>
</html>`;
    }


    function populateColorSwatches() {
        STANDARD_COLORS.forEach(color => {
            const swatch = document.createElement('div');
            swatch.style.width = '30px';
            swatch.style.height = '30px';
            swatch.style.backgroundColor = color.value;
            swatch.style.border = '1px solid #7F7F7F';
            swatch.style.cursor = 'pointer';
            swatch.title = color.name;
            swatch.dataset.colorValue = color.value;
            swatch.classList.add('color-swatch-item');
            DOM.bgColorSwatchesContainer.appendChild(swatch);
        });
    }

    function bringToFront(windowElement) {
        if (!windowElement) return;
        highestZIndex++;
        windowElement.style.zIndex = highestZIndex;
        const windowId = windowElement.id;
        // Ensure state object exists
        if (!appData.windowStates[windowId]) appData.windowStates[windowId] = {};
        appData.windowStates[windowId].zIndex = highestZIndex;
        // No need to call saveData() here, will be called by the action triggering bringToFront
    }


    function initWindowInteractions(windowId) {
        const windowElement = getById(windowId);
        let titleBarElement;
        let resizeHandleElement;

        if (windowId === 'xpMainWindow') {
            titleBarElement = DOM.xpMainWindowTitleBar;
            resizeHandleElement = DOM.xpMainWindowResizeHandle;
        } else if (windowId === 'textEditorWindow') {
            titleBarElement = DOM.textEditorWindowTitleBar;
            resizeHandleElement = DOM.textEditorResizeHandle;
        } else if (windowId === 'playJockeyWindow') {
            titleBarElement = DOM.playJockeyTitleBar;
            resizeHandleElement = DOM.playJockeyResizeHandle;
        }


        if (!windowElement || !titleBarElement) {
            console.error("Window or TitleBar element not found for ID:", windowId);
            return;
        }

        windowElement.addEventListener('mousedown', (e) => {
             if (e.target.closest('.desktop-icon') || e.target.closest('.context-modal')) return;

            // Check if the click is on the window itself, title bar (not buttons), or window body (not interactive elements)
            if (e.target === windowElement ||
                (titleBarElement.contains(e.target) && !e.target.closest('button')) ||
                (windowElement.querySelector('.window-body')?.contains(e.target) && !e.target.closest('button, input, select, textarea, .resize-handle, .achievement-item, .xp-button, iframe, #playJockeyPlayer, .playjockey-playlist-item, .playjockey-tab'))) {
                 bringToFront(windowElement);
            }
        }, true); // Use capture phase to bring to front before other actions

        titleBarElement.addEventListener('mousedown', (e) => {
            if (e.target.closest('button') || windowElement.classList.contains('true-maximized') || activeDragIcon) return;
            activeDragWindow = windowElement;
            dragOffsetX = e.clientX - activeDragWindow.offsetLeft;
            dragOffsetY = e.clientY - activeDragWindow.offsetTop;
            activeDragWindow.classList.add('disable-selection'); // Prevent text selection during drag
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDragOrResize);
            bringToFront(windowElement); // Bring to front on title bar mousedown as well
        });

        if (resizeHandleElement) {
            resizeHandleElement.addEventListener('mousedown', (e) => {
                if (windowElement.classList.contains('true-maximized') || activeDragIcon) return;
                activeResizeWindow = windowElement;
                activeResizeWindow.classList.add('disable-selection');
                resizeInitialX = e.clientX;
                resizeInitialY = e.clientY;
                resizeInitialWidth = activeResizeWindow.offsetWidth;
                resizeInitialHeight = activeResizeWindow.offsetHeight;

                if (windowId === 'textEditorWindow' && DOM.textEditorFrame) {
                    DOM.textEditorFrame.style.pointerEvents = 'none';
                }
                document.addEventListener('mousemove', doResize);
                document.addEventListener('mouseup', stopDragOrResize);
                bringToFront(windowElement);
            });
        }
    }

    function doDrag(e) {
        if (!activeDragWindow) return;
        activeDragWindow.style.left = (e.clientX - dragOffsetX) + 'px';
        activeDragWindow.style.top = (e.clientY - dragOffsetY) + 'px';
        if (appData.windowStates[activeDragWindow.id]) {
            appData.windowStates[activeDragWindow.id].userManuallySet = true;
        }
    }

    function doResize(e) {
        if (!activeResizeWindow) return;
        const windowId = activeResizeWindow.id;
        let currentMinWidth, currentMinHeight;

        if (windowId === 'xpMainWindow') {
            currentMinWidth = minTrackerAppWidth;
            currentMinHeight = MIN_TRACKER_APP_HEIGHT;
        } else if (windowId === 'textEditorWindow') {
            currentMinWidth = MIN_TEXTEDITOR_WIDTH;
            currentMinHeight = MIN_TEXTEDITOR_HEIGHT;
        } else if (windowId === 'playJockeyWindow') {
            currentMinWidth = MIN_PLAYJOCKEY_WIDTH;
            currentMinHeight = MIN_PLAYJOCKEY_HEIGHT;
        } else {
            return; // Should not happen
        }


        let newWidth = resizeInitialWidth + (e.clientX - resizeInitialX);
        let newHeight = resizeInitialHeight + (e.clientY - resizeInitialY);
        activeResizeWindow.style.width = Math.max(currentMinWidth, newWidth) + 'px';
        activeResizeWindow.style.height = Math.max(currentMinHeight, newHeight) + 'px';

        if (appData.windowStates[windowId]) {
            appData.windowStates[windowId].userManuallySet = true;
        }
        if (windowId === 'xpMainWindow') {
            handleAppWindowResize(); // For specific layout changes in tracker
        }
    }

    function stopDragOrResize() {
        let windowToSaveState = null;
        if (activeDragWindow) {
            activeDragWindow.classList.remove('disable-selection');
            windowToSaveState = activeDragWindow.id;
        }
        if (activeResizeWindow) {
            activeResizeWindow.classList.remove('disable-selection');
            if (activeResizeWindow.id === 'textEditorWindow' && DOM.textEditorFrame) {
                DOM.textEditorFrame.style.pointerEvents = 'auto';
            }
            windowToSaveState = activeResizeWindow.id;
        }

        if (windowToSaveState) {
            saveWindowState(windowToSaveState);
        }

        activeDragWindow = null;
        activeResizeWindow = null;
        document.removeEventListener('mousemove', doDrag);
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', stopDragOrResize);
    }


    function setWindowDefaults(windowId, isBrowserResize = false) {
        const appWindow = getById(windowId);
        // Guard: if window doesn't exist, or is minimized (defaults shouldn't apply to minimized state visually)
        if (!appWindow || appWindow.classList.contains('minimized')) return;

        // If window is maximized and this isn't a browser resize, it should stay maximized.
        if (appWindow.classList.contains('true-maximized') && !isBrowserResize) {
            appWindow.style.width = '100vw';
            appWindow.style.height = '100vh';
            appWindow.style.top = '0px';
            appWindow.style.left = '0px';
            return;
        }

        const state = appData.windowStates[windowId]; // Assumed to exist due to restoreWindowState logic
        if (!state) {
            console.error(`State missing for ${windowId} in setWindowDefaults`);
            return;
        }

        const hasValidSavedSize = state.width && state.width > 0 && state.height && state.height > 0;
        const hasValidSavedPosition = state.x != null && state.y != null;

        let currentMinWidth, currentMinHeight, defaultWidth, defaultHeight, defaultOffsetX, defaultOffsetY;

        if (windowId === 'xpMainWindow') {
            currentMinWidth = minTrackerAppWidth; currentMinHeight = MIN_TRACKER_APP_HEIGHT;
            defaultWidth = 905; defaultHeight = 705;
            defaultOffsetX = 0; defaultOffsetY = 0; // Centered
        } else if (windowId === 'textEditorWindow') {
            currentMinWidth = MIN_TEXTEDITOR_WIDTH; currentMinHeight = MIN_TEXTEDITOR_HEIGHT;
            defaultWidth = 450; defaultHeight = 705;
            defaultOffsetX = 50; defaultOffsetY = 50;
        } else if (windowId === 'playJockeyWindow') {
            currentMinWidth = MIN_PLAYJOCKEY_WIDTH; currentMinHeight = MIN_PLAYJOCKEY_HEIGHT;
            defaultWidth = 480; defaultHeight = 705;
            defaultOffsetX = 100; defaultOffsetY = 100;
        } else {
            return; // Unknown window ID
        }

        // Apply default dimensions and position ONLY if not user-set or if it's a browser resize forcing re-evaluation
        if (isBrowserResize || !state.userManuallySet || !hasValidSavedSize || !hasValidSavedPosition) {
            let newWidth = defaultWidth;
            let newHeight = defaultHeight;

            newWidth = Math.max(currentMinWidth, newWidth);
            newHeight = Math.max(currentMinHeight, newHeight);

            let newLeft = (defaultOffsetX === 0 && window.innerWidth > newWidth) ? (window.innerWidth - newWidth) / 2 : defaultOffsetX;
            let newTop = (defaultOffsetY === 0 && window.innerHeight > newHeight) ? (window.innerHeight - newHeight) / 2 : defaultOffsetY;
            
            newTop = Math.max(10, Math.min(newTop, window.innerHeight - newHeight - 10));
            newLeft = Math.max(10, Math.min(newLeft, window.innerWidth - newWidth - 10));
            if (window.innerHeight <= newHeight + 20) newTop = 10;
            if (window.innerWidth <= newWidth + 20) newLeft = 10;

            appWindow.style.width = newWidth + 'px';
            appWindow.style.height = newHeight + 'px';
            appWindow.style.left = newLeft + 'px';
            appWindow.style.top = newTop + 'px';

            // Update the state object directly as these are now the applied "default" values
            state.width = newWidth;
            state.height = newHeight;
            state.x = newLeft;
            state.y = newTop;
            state.userManuallySet = false; // These are defaults, not user-dragged/resized
        }
        // If userManuallySet and valid dimensions/position exist, restoreWindowState already applied them.
        // No saveWindowState(windowId) here; this function just applies styles.
    }


    function handleAppWindowResize() {
        if (DOM.xpMainWindow.classList.contains('minimized') || DOM.xpMainWindow.style.display === 'none') return;
        checkControlsBarLayout();
        checkToggleDayView(); // If this function has complex logic, ensure it's needed
    }

    function checkControlsBarLayout() {
        const controlsBar = DOM.controlsBar;
        if (!controlsBar || !controlsBar.clientWidth) return; // Ensure controlsBar is visible and has width

        const children = [
            controlsBar.querySelector('.week-navigation'),
            controlsBar.querySelector('.controls-group'),
            controlsBar.querySelector('.global-actions')
        ].filter(el => el);

        if (children.length === 0) return;

        const originalClasses = controlsBar.className; // Preserve original classes
        controlsBar.className = 'controls-bar layout-single-row'; // Temporarily apply for measurement

        let totalChildrenWidth = 0;
        children.forEach(child => {
            const childStyle = getComputedStyle(child);
            totalChildrenWidth += child.scrollWidth + parseFloat(childStyle.marginLeft) + parseFloat(childStyle.marginRight);
        });

        controlsBar.className = originalClasses; // Restore original classes

        const controlsBarClientWidth = controlsBar.clientWidth - (parseFloat(getComputedStyle(controlsBar).paddingLeft) + parseFloat(getComputedStyle(controlsBar).paddingRight));

        if (totalChildrenWidth > controlsBarClientWidth && controlsBarClientWidth > 0) {
            controlsBar.classList.add('layout-multi-row');
            controlsBar.classList.remove('layout-single-row');
        } else {
            controlsBar.classList.add('layout-single-row');
            controlsBar.classList.remove('layout-multi-row');
        }
    }


    function checkToggleDayView() { /* Placeholder if specific logic is needed */ }


    function addEventListeners() {
        document.body.addEventListener('contextmenu', function(event) {
            if (event.target === document.body) { // Only if clicking directly on the body/desktop
                event.preventDefault();
                DOM.newBgImageInput.value = null; // Clear previous file selection
                DOM.bgImageUrlInput.value = '';
                openModal(MODAL_IDS.CHANGE_BG_IMAGE);
            }
        });

        DOM.uploadBgImageBtn.addEventListener('click', function() {
            const file = DOM.newBgImageInput.files[0];
            if (file) {
                if (file.size > 5 * 1024 * 1024) { // 5MB warning
                    alert("Image file is large (over 5MB). This might exceed browser storage limits when saved. Consider using a smaller file or a URL.");
                }
                const reader = new FileReader();
                reader.onloadend = function() {
                    document.body.style.backgroundColor = ''; // Clear solid color
                    document.body.style.backgroundImage = `url('${reader.result}')`;
                    appData.customBgImage = reader.result;
                    appData.customBgColor = null;
                    saveData();
                    closeModal(MODAL_IDS.CHANGE_BG_IMAGE);
                }
                reader.onerror = function() {
                    alert("Error reading image file.");
                }
                reader.readAsDataURL(file);
            } else {
                alert("Please select an image file first.");
            }
        });

        DOM.applyBgImageUrlBtn.addEventListener('click', function() {
            const imageUrl = DOM.bgImageUrlInput.value.trim();
            if (imageUrl) {
                try {
                    new URL(imageUrl); // Basic URL validation
                    document.body.style.backgroundColor = ''; // Clear solid color
                    document.body.style.backgroundImage = `url('${imageUrl}')`;
                    appData.customBgImage = imageUrl;
                    appData.customBgColor = null;
                    saveData();
                    closeModal(MODAL_IDS.CHANGE_BG_IMAGE);
                } catch (e) {
                    alert("Invalid image URL provided. Please enter a complete and valid URL (e.g., https://example.com/image.png).");
                }
            } else {
                alert("Please enter an image URL.");
            }
        });

        DOM.bgColorSwatchesContainer.addEventListener('click', function(event) {
            if (event.target.classList.contains('color-swatch-item')) {
                const selectedColor = event.target.dataset.colorValue;
                if (selectedColor) {
                    document.body.style.backgroundImage = 'none'; // Clear image
                    document.body.style.backgroundColor = selectedColor;

                    appData.customBgColor = selectedColor;
                    appData.customBgImage = null;
                    saveData();
                    closeModal(MODAL_IDS.CHANGE_BG_IMAGE);
                }
            }
        });


        DOM.gridBody.addEventListener('click', function(event) {
            const target = event.target;
            if (target.classList.contains('delete-area-btn')) {
                const areaName = target.dataset.areaName;
                if (areaName) promptRemoveArea(areaName);
            } else if (target.classList.contains('edit-ach-btn')) {
                const achKey = target.dataset.achKey;
                const achId = target.dataset.achId;
                openAddEditAchievementModal(null, null, achKey, achId);
            } else if (target.classList.contains('remove-ach-btn')) {
                const achKey = target.dataset.achKey;
                const achId = target.dataset.achId;
                promptRemoveAchievement(achKey, achId);
            } else if (target.classList.contains('achievement-add-btn-cell')) {
                const areaName = target.dataset.areaName;
                const dayIndex = parseInt(target.dataset.dayIndex);
                openAddEditAchievementModal(areaName, dayIndex);
            }
        });

        DOM.addAreaBtn.addEventListener('click', () => openModal(MODAL_IDS.NEW_AREA));
        DOM.saveNewAreaBtn.addEventListener('click', saveNewArea);
        DOM.newAreaNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveNewArea();
        });

        DOM.saveAchievementBtn.addEventListener('click', saveOrUpdateAchievement);
        DOM.achievementTypeRadios.forEach(radio => {
            radio.addEventListener('change', toggleAchievementInputType);
        });

        DOM.prevWeekBtn.addEventListener('click', () => {
            if (appData.viewMode === 'week') navigateWeek(-7);
            else navigateDay(-1);
        });
        DOM.nextWeekBtn.addEventListener('click', () => {
            if (appData.viewMode === 'week') navigateWeek(7);
            else navigateDay(1);
        });
        DOM.thisWeekBtn.addEventListener('click', goToThisWeek);
        DOM.toggleViewBtn.addEventListener('click', toggleViewMode);

        DOM.showQuestsBtn.addEventListener('click', showQuests);
        DOM.addQuestBtn.addEventListener('click', openCreateQuestModal);
        DOM.saveNewQuestBtn.addEventListener('click', saveNewQuest);

        DOM.questsList.addEventListener('click', function(event) {
            if (event.target.classList.contains('refresh-quest-btn')) {
                const questId = event.target.dataset.questId;
                promptRefreshQuest(questId);
            }
        });
        DOM.confirmRefreshQuestBtn.addEventListener('click', confirmAndRefreshQuest);

        // Window Controls
        DOM.xpMainWindowMinimizeBtn.addEventListener('click', () => minimizeWindow('xpMainWindow'));
        DOM.xpMainWindowMaximizeBtn.addEventListener('click', () => maximizeWindow('xpMainWindow'));
        DOM.xpMainWindowCloseBtn.addEventListener('click', () => {
            const win = DOM.xpMainWindow;
            win.style.display = 'none';
            if(appData.windowStates.xpMainWindow) appData.windowStates.xpMainWindow.hiddenByUser = true;
            saveWindowState('xpMainWindow');
        });

        DOM.textEditorMinimizeBtn.addEventListener('click', () => minimizeWindow('textEditorWindow'));
        DOM.textEditorMaximizeBtn.addEventListener('click', () => maximizeWindow('textEditorWindow'));
        DOM.textEditorCloseBtn.addEventListener('click', () => {
            const win = DOM.textEditorWindow;
            win.style.display = 'none';
            if(appData.windowStates.textEditorWindow) appData.windowStates.textEditorWindow.hiddenByUser = true;
            saveWindowState('textEditorWindow');
        });

        DOM.playJockeyMinimizeBtn.addEventListener('click', () => minimizeWindow('playJockeyWindow'));
        DOM.playJockeyMaximizeBtn.addEventListener('click', () => maximizeWindow('playJockeyWindow'));
        DOM.playJockeyCloseBtn.addEventListener('click', () => {
            const win = DOM.playJockeyWindow;
            win.style.display = 'none';
            if(appData.windowStates.playJockeyWindow) appData.windowStates.playJockeyWindow.hiddenByUser = true;
            
            if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                ytPlayerInstance.stopVideo(); // Stop video when closing
            }
            // appData.playJockeyCurrentVideo = null; // Optionally clear current video
            saveWindowState('playJockeyWindow');
            // saveData(); // saveWindowState calls saveData
        });

        DOM.playJockeyAddBtn.addEventListener('click', handlePlayJockeyInput);
        DOM.playJockeyLinkInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handlePlayJockeyInput();
        });

        DOM.playJockeyPlaylist.addEventListener('dragstart', handlePjDragStart);
        DOM.playJockeyPlaylist.addEventListener('dragend', handlePjDragEnd);
        DOM.playJockeyPlaylist.addEventListener('dragover', handlePjDragOver);
        DOM.playJockeyPlaylist.addEventListener('dragleave', handlePjDragLeave);
        DOM.playJockeyPlaylist.addEventListener('drop', handlePjDrop);
        DOM.playJockeyPlaylist.addEventListener('contextmenu', showPjContextMenu);

        DOM.playJockeyRandomBtn.addEventListener('click', togglePlayJockeyRandom);
        DOM.playJockeyAutoPlayBtn.addEventListener('click', togglePlayJockeyAutoPlay);
        DOM.playJockeyRepeatBtn.addEventListener('click', cyclePlayJockeyRepeat);

        DOM.modalCloseButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const modalId = event.target.dataset.modalId || event.target.closest('.modal').id;
                if (modalId) closeModal(modalId);
            });
        });

        DOM.confirmRemoveBtn.addEventListener('click', function() {
            const areaNameToRemove = this.dataset.areaNameToRemove;
            if (areaNameToRemove) {
                removeArea(areaNameToRemove);
                closeModal(MODAL_IDS.CONFIRM_REMOVE_AREA);
                delete this.dataset.areaNameToRemove; // Clean up
            }
        });

        DOM.confirmDeleteAchievementBtn.addEventListener('click', function() {
            const key = this.dataset.achievementKey;
            const id = this.dataset.achievementId;
            if (key && id) {
                confirmRemoveAchievement(key, id);
                closeModal(MODAL_IDS.CONFIRM_DELETE_ACHIEVEMENT);
            }
        });

        DOM.saveRenamedPlaylistBtn.addEventListener('click', saveRenamedPlaylist);
        DOM.playlistNewNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveRenamedPlaylist();
        });
        DOM.confirmFinalPlaylistRemoveBtn.addEventListener('click', executePlaylistDeletion);

        DOM.saveRenamedTrackBtn.addEventListener('click', saveRenamedTrack);
        DOM.trackNewNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') DOM.saveRenamedTrackBtn.click();});
        DOM.trackNewArtistInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') DOM.saveRenamedTrackBtn.click();});
        DOM.confirmFinalTrackRemoveBtn.addEventListener('click', executeTrackDeletion);

        window.addEventListener('resize', () => {
            // Call setWindowDefaults for each window that might need to adjust
            // It will only adjust if not user-set, or if isBrowserResize is true (which it is here implicitly)
            setWindowDefaults('xpMainWindow', true);
            setWindowDefaults('textEditorWindow', true);
            setWindowDefaults('playJockeyWindow', true);
            // After defaults are applied, the state object's dimensions are updated by setWindowDefaults.
            // We should then save this potentially new default state.
            saveData();
        });

        document.addEventListener('click', (e) => { // Hide context menus on outside click
            if (DOM.playJockeyContextMenu.style.display === 'block' && !DOM.playJockeyContextMenu.contains(e.target) && !e.target.closest('.playjockey-playlist-item')) {
                hidePjContextMenu();
            }
            if (DOM.playJockeyTabContextMenu.style.display === 'block' && !DOM.playJockeyTabContextMenu.contains(e.target) && !e.target.closest('.playjockey-tab')) {
                hidePjTabContextMenu();
            }
        });
    }

    function minimizeWindow(windowId) {
        const appWindow = getById(windowId);
        if (!appWindow || appWindow.classList.contains('minimized')) return;

        const state = appData.windowStates[windowId]; // Assumed to exist
        if (!state) { console.error(`State missing for ${windowId} in minimizeWindow`); return; }

        state.minimized = true;

        if (appWindow.classList.contains('true-maximized')) {
            state.wasMaximizedBeforeMinimize = true;
            // Restore pre-maximized dimensions into state from lastNormalStates
            if (lastNormalStates[windowId]) {
                state.width = parseInt(lastNormalStates[windowId].width);
                state.height = parseInt(lastNormalStates[windowId].height);
                state.x = parseInt(lastNormalStates[windowId].left);
                state.y = parseInt(lastNormalStates[windowId].top);
            } else {
                // Fallback if lastNormalState is somehow missing, use app defaults
                // This requires knowing the default normal sizes.
                // For simplicity, this case should ideally not be hit if lastNormalStates is managed well.
                console.warn(`lastNormalStates missing for ${windowId} during minimize from maximized.`);
            }
        } else {
            state.wasMaximizedBeforeMinimize = false;
            // Save current normal dimensions into state
            state.width = appWindow.offsetWidth;
            state.height = appWindow.offsetHeight;
            state.x = appWindow.offsetLeft;
            state.y = appWindow.offsetTop;
        }
        appWindow.classList.remove('true-maximized');
        appWindow.classList.add('minimized');

        updateMinMaxButtonStates(windowId);
        saveWindowState(windowId);
    }

    function maximizeWindow(windowId) {
        const appWindow = getById(windowId);
        if (!appWindow) return;

        const state = appData.windowStates[windowId];
        if (!state) { console.error(`State missing for ${windowId} in maximizeWindow`); return; }

        const isMinimized = appWindow.classList.contains('minimized');
        let currentLastNormal = lastNormalStates[windowId] || {};

        if (isMinimized) { // Restore from minimized
            appWindow.classList.remove('minimized');
            state.minimized = false;
            const wasMaximized = state.wasMaximizedBeforeMinimize;
            delete state.wasMaximizedBeforeMinimize; // Clear flag

            if (wasMaximized) { // Restore to maximized state
                appWindow.style.width = '100vw';
                appWindow.style.height = '100vh';
                appWindow.style.top = '0px';
                appWindow.style.left = '0px';
                appWindow.classList.add('true-maximized');
                state.maximized = true;
                // state.width/height/x/y should already hold the pre-maximized (normal) dimensions from when it was minimized
            } else { // Restore to normal state (dimensions are in state.width/height/x/y)
                let minW, minH;
                if (windowId === 'xpMainWindow') { minW = minTrackerAppWidth; minH = MIN_TRACKER_APP_HEIGHT;}
                else if (windowId === 'textEditorWindow') { minW = MIN_TEXTEDITOR_WIDTH; minH = MIN_TEXTEDITOR_HEIGHT;}
                else if (windowId === 'playJockeyWindow') { minW = MIN_PLAYJOCKEY_WIDTH; minH = MIN_PLAYJOCKEY_HEIGHT;}

                appWindow.style.width = Math.max(minW, state.width || parseInt(currentLastNormal.width) || 0) + 'px';
                appWindow.style.height = Math.max(minH, state.height || parseInt(currentLastNormal.height) || 0) + 'px';
                appWindow.style.left = (state.x || parseInt(currentLastNormal.left) || 0) + 'px';
                appWindow.style.top = (state.y || parseInt(currentLastNormal.top) || 0) + 'px';
                state.maximized = false;
            }
        } else if (appWindow.classList.contains('true-maximized')) { // Restore down from maximized
            if (currentLastNormal.width && currentLastNormal.height) {
                appWindow.style.width = currentLastNormal.width;
                appWindow.style.height = currentLastNormal.height;
                appWindow.style.top = currentLastNormal.top;
                appWindow.style.left = currentLastNormal.left;
                // Update state with these normal dimensions
                state.width = parseInt(currentLastNormal.width);
                state.height = parseInt(currentLastNormal.height);
                state.x = parseInt(currentLastNormal.left);
                state.y = parseInt(currentLastNormal.top);
            } else {
                // Fallback if lastNormalState is missing, apply app defaults for normal state
                setWindowDefaults(windowId, false); // This will set state.width/height/x/y
            }
            appWindow.classList.remove('true-maximized');
            state.maximized = false;
            state.userManuallySet = true; // Restoring to a specific size implies manual control over that size
        } else { // Maximize from normal
            lastNormalStates[windowId] = { // Save current normal state
                width: appWindow.style.width || (appWindow.offsetWidth + 'px'),
                height: appWindow.style.height || (appWindow.offsetHeight + 'px'),
                top: appWindow.style.top || (appWindow.offsetTop + 'px'),
                left: appWindow.style.left || (appWindow.offsetLeft + 'px')
            };
            // state.width/height/x/y already hold these normal dimensions, no change needed to them here.

            appWindow.style.width = '100vw';
            appWindow.style.height = '100vh';
            appWindow.style.top = '0px';
            appWindow.style.left = '0px';
            appWindow.classList.add('true-maximized');
            state.maximized = true;
            state.userManuallySet = false; // Maximized is not a user-dragged size
        }

        updateMinMaxButtonStates(windowId);
        saveWindowState(windowId);
        if (windowId === 'xpMainWindow' && !isMinimized) handleAppWindowResize(); // if unminimized or toggled max state
    }


    function updateMinMaxButtonStates(windowId) {
        const win = getById(windowId);
        let minimizeBtn, maximizeBtn;

        if (windowId === 'xpMainWindow') {
            minimizeBtn = DOM.xpMainWindowMinimizeBtn;
            maximizeBtn = DOM.xpMainWindowMaximizeBtn;
        } else if (windowId === 'textEditorWindow') {
            minimizeBtn = DOM.textEditorMinimizeBtn;
            maximizeBtn = DOM.textEditorMaximizeBtn;
        } else if (windowId === 'playJockeyWindow') {
            minimizeBtn = DOM.playJockeyMinimizeBtn;
            maximizeBtn = DOM.playJockeyMaximizeBtn;
        }

        if (!win || !minimizeBtn || !maximizeBtn) return;

        const isMinimized = win.classList.contains('minimized');
        const isTrueMaximized = win.classList.contains('true-maximized');

        minimizeBtn.disabled = isMinimized; // Cannot minimize if already minimized
        maximizeBtn.disabled = false; // Maximize/Restore button is always enabled unless window is hidden

        if (isMinimized) {
            maximizeBtn.textContent = '1'; // Symbol for Restore
            maximizeBtn.title = "Restore";
        } else if (isTrueMaximized) {
            maximizeBtn.textContent = '2'; // Symbol for Restore Down
            maximizeBtn.title = "Restore Down";
        } else {
            maximizeBtn.textContent = '1'; // Symbol for Maximize
            maximizeBtn.title = "Maximize";
        }
    }

    function updateViewControls() {
        if (appData.viewMode === 'week') {
            DOM.toggleViewBtn.textContent = 'Day View';
            DOM.prevWeekBtn.textContent = '< Prev Week';
            DOM.nextWeekBtn.textContent = 'Next Week >';
            DOM.thisWeekBtn.textContent = 'This Week';
        } else { // Day view
            DOM.toggleViewBtn.textContent = 'Week View';
            DOM.prevWeekBtn.textContent = '< Prev Day';
            DOM.nextWeekBtn.textContent = 'Next Day >';
            DOM.thisWeekBtn.textContent = 'Today';
        }
    }

    function saveWindowState(windowId) {
        const win = getById(windowId);
        if (!win) return;

        let state = appData.windowStates[windowId];
        if (!state) {
            console.warn(`Window state for ${windowId} was missing during saveWindowState. Re-initializing.`);
            // This path should ideally not be hit if restoreWindowState initializes correctly.
            // For safety, attempt to create a basic state.
            appData.windowStates[windowId] = {};
            state = appData.windowStates[windowId];
            // Populate with current DOM state as best guess, though hiddenByUser might be wrong if called unexpectedly
            state.hiddenByUser = (win.style.display === 'none');
            state.minimized = win.classList.contains('minimized');
            state.maximized = win.classList.contains('true-maximized');
            state.userManuallySet = false; // Default if creating new
             // state.x,y,w,h will be captured below if applicable
        }

        // These flags are updated based on the window's current classes
        state.minimized = win.classList.contains('minimized');
        state.maximized = win.classList.contains('true-maximized');
        state.zIndex = parseInt(win.style.zIndex) || highestZIndex; // Use current highestZ if parsing fails or zIndex is 0

        // state.hiddenByUser is managed by open/close actions directly modifying appData.windowStates[windowId].hiddenByUser.
        // This function saves whatever value is ALREADY in state.hiddenByUser. It does NOT re-derive it from win.style.display.

        // Save dimensions:
        // If the window is in a "normal" state (neither minimized nor maximized),
        // its current offsetLeft/Top/Width/Height are the ones to save.
        if (!state.minimized && !state.maximized) {
            state.x = win.offsetLeft;
            state.y = win.offsetTop;
            state.width = win.offsetWidth;
            state.height = win.offsetHeight;
            // state.userManuallySet is true if user dragged/resized, false if set by defaults.
            // Drag/Resize handlers set userManuallySet = true.
            // setWindowDefaults sets userManuallySet = false.
        }
        // If state.minimized is true, state.x/y/width/height should already hold the pre-minimized values.
        // These are set by the minimizeWindow function before it calls saveWindowState.
        // If state.maximized is true, state.x/y/width/height should already hold the pre-maximized (normal) values.
        // These are set by the maximizeWindow function (when restoring down or from lastNormalState)
        // or preserved (if maximizing from normal) before it calls saveWindowState.

        saveData();
    }


    function restoreWindowState(windowId) {
        const win = getById(windowId);
        if (!win) {
            console.error(`Window element ${windowId} not found for restore.`);
            return;
        }

        let state = appData.windowStates[windowId];
        const defaultStateTemplate = (defaultAppData.windowStates && defaultAppData.windowStates[windowId]) || {
            x: null, y: null, width: null, height: null,
            maximized: false, minimized: false, zIndex: highestZIndex + 1, userManuallySet: false,
            hiddenByUser: (windowId === 'playJockeyWindow') // Default fallback
        };

        if (!state) {
            appData.windowStates[windowId] = { ...defaultStateTemplate };
            state = appData.windowStates[windowId];
        } else {
            state = {
                ...defaultStateTemplate, // Apply defaults first for any missing properties
                ...state,                 // Loaded state overrides defaults
                // Ensure boolean flags and zIndex are valid after merge
                minimized: state.minimized === undefined ? defaultStateTemplate.minimized : state.minimized,
                maximized: state.maximized === undefined ? defaultStateTemplate.maximized : state.maximized,
                hiddenByUser: state.hiddenByUser === undefined ? defaultStateTemplate.hiddenByUser : state.hiddenByUser,
                userManuallySet: state.userManuallySet === undefined ? defaultStateTemplate.userManuallySet : state.userManuallySet,
                zIndex: parseInt(state.zIndex) || defaultStateTemplate.zIndex
            };
            appData.windowStates[windowId] = state; // Assign back the merged state
        }


        // 1. Set visibility FIRST, based on the loaded or initialized state.hiddenByUser.
        if (state.hiddenByUser) {
            win.style.display = 'none';
        } else {
            win.style.display = 'flex';
        }

        // 2. Apply Z-Index from state or assign a new one.
        let loadedZ = state.zIndex; // Already parsed or defaulted
        if (loadedZ <= 5 && windowId !== 'desktop-icon') loadedZ = highestZIndex + 1;
        win.style.zIndex = loadedZ;
        state.zIndex = loadedZ;
        highestZIndex = Math.max(highestZIndex, loadedZ);


        // 3. Apply minimized/maximized state or normal dimensions.
        if (state.minimized) {
            win.classList.add('minimized');
            win.classList.remove('true-maximized');
            // Normal dimensions are already in state.x/y/width/height from when it was minimized.
        } else if (state.maximized) {
            win.classList.add('true-maximized');
            win.classList.remove('minimized');
            win.style.width = '100vw';
            win.style.height = '100vh';
            win.style.top = '0px';
            win.style.left = '0px';

            let minW, minH, defaultNormalWidth, defaultNormalHeight, defaultX, defaultY;
            if (windowId === 'xpMainWindow') { defaultNormalWidth = 905; defaultNormalHeight = 705; minW = minTrackerAppWidth; minH = MIN_TRACKER_APP_HEIGHT; defaultX = (window.innerWidth - defaultNormalWidth)/2; defaultY = 20;}
            else if (windowId === 'textEditorWindow') { defaultNormalWidth = 450; defaultNormalHeight = 705; minW = MIN_TEXTEDITOR_WIDTH; minH = MIN_TEXTEDITOR_HEIGHT; defaultX = 50; defaultY = 50;}
            else if (windowId === 'playJockeyWindow') { defaultNormalWidth = 480; defaultNormalHeight = 705; minW = MIN_PLAYJOCKEY_WIDTH; minH = MIN_PLAYJOCKEY_HEIGHT; defaultX = 100; defaultY = 100;}

            lastNormalStates[windowId] = { // Populate lastNormalStates using normal dims from state or defaults
                width: (state.width ? Math.max(minW, state.width) : defaultNormalWidth) + 'px',
                height: (state.height ? Math.max(minH, state.height) : defaultNormalHeight) + 'px',
                top: (state.y != null ? state.y : defaultY) + 'px',
                left: (state.x != null ? state.x : defaultX) + 'px'
            };
        } else { // Normal window state (not minimized, not maximized)
            win.classList.remove('minimized');
            win.classList.remove('true-maximized');

            if (state.userManuallySet && state.width != null && state.height != null && state.x != null && state.y != null) {
                let currentMinWidth, currentMinHeight;
                if (windowId === 'xpMainWindow') { currentMinWidth = minTrackerAppWidth; currentMinHeight = MIN_TRACKER_APP_HEIGHT; }
                else if (windowId === 'textEditorWindow') { currentMinWidth = MIN_TEXTEDITOR_WIDTH; currentMinHeight = MIN_TEXTEDITOR_HEIGHT; }
                else if (windowId === 'playJockeyWindow') { currentMinWidth = MIN_PLAYJOCKEY_WIDTH; currentMinHeight = MIN_PLAYJOCKEY_HEIGHT; }
                else { currentMinWidth = 100; currentMinHeight = 100; }

                win.style.left = state.x + 'px';
                win.style.top = state.y + 'px';
                win.style.width = Math.max(currentMinWidth, state.width) + 'px';
                win.style.height = Math.max(currentMinHeight, state.height) + 'px';
            } else {
                // Needs defaults. Only apply if currently visible (not hiddenByUser).
                if (!state.hiddenByUser) {
                    setWindowDefaults(windowId, false); // This updates state.width/height/x/y & userManuallySet
                }
                // If hidden and needs defaults, dimensions will be set when first unhidden if still null.
            }
        }
        updateMinMaxButtonStates(windowId);
    }


    function saveData() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(appData));
        } catch (error) {
            console.error("Error saving data to localStorage:", error);
            if (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                alert("Could not save data: Storage limit exceeded. This might be due to a very large background image from file upload. Try a smaller file or use the URL option for large images.");
            }
        }
    }

    function loadData() {
        const storedData = localStorage.getItem(STORAGE_KEY);
        const defaultPlaylistId = 'playlist_default_0';

        // Define defaultAppData here so it's in scope for init and restoreWindowState
        defaultAppData = {
            viewMode: 'week',
            selectedDayIndex: 0,
            windowStates: {
                xpMainWindow: { x: null, y: null, width: null, height: null, maximized: false, minimized: false, zIndex: 11, userManuallySet: false, hiddenByUser: false },
                textEditorWindow: { x: null, y: null, width: null, height: null, maximized: false, minimized: false, zIndex: 10, userManuallySet: false, hiddenByUser: false },
                playJockeyWindow: { x: null, y: null, width: null, height: null, maximized: false, minimized: false, zIndex: 9, userManuallySet: false, hiddenByUser: true }
            },
            iconPositions: {
                trackerIcon: { x: 0, y: 0 },
                textEditorIcon: { x: 0, y: 100 },
                playJockeyIcon: { x: 0, y: 200 }
            },
            areas: [],
            achievements: {},
            quests: {},
            currentWeekStartDate: null, // Will be set in init if null
            customBgImage: null,
            customBgColor: null,
            playJockeyPlaylists: [{id: defaultPlaylistId, name: "Playlist", videos: []}],
            playJockeyCurrentPlaylistId: defaultPlaylistId,
            playJockeyCurrentVideo: null,
            playJockeyAutoPlayEnabled: true,
            playJockeyRandomEnabled: false,
            playJockeyRepeatState: "off",
            playJockeyRandomHistory: []
        };

        if (storedData) {
            try {
                const loadedData = JSON.parse(storedData);
                // Merge loadedData with defaultAppData to ensure all keys exist
                appData = {
                    ...defaultAppData, // Start with defaults
                    ...loadedData,     // Override with loaded data
                    windowStates: { // Deep merge for windowStates
                        xpMainWindow: { ...defaultAppData.windowStates.xpMainWindow, ...(loadedData.windowStates ? loadedData.windowStates.xpMainWindow : {}) },
                        textEditorWindow: { ...defaultAppData.windowStates.textEditorWindow, ...(loadedData.windowStates ? loadedData.windowStates.textEditorWindow : {}) },
                        playJockeyWindow: { ...defaultAppData.windowStates.playJockeyWindow, ...(loadedData.windowStates ? loadedData.windowStates.playJockeyWindow : {}) }
                    },
                    iconPositions: { ...defaultAppData.iconPositions, ...(loadedData.iconPositions || {}) },
                    playJockeyPlaylists: (loadedData.playJockeyPlaylists && loadedData.playJockeyPlaylists.length > 0)
                        ? loadedData.playJockeyPlaylists.map(pl => ({
                            ...pl, // Spread playlist properties
                            videos: (pl.videos || []).map(video => ({ // Ensure videos array exists
                                ...video, // Spread video properties
                                title: video.title ? decodeHtmlEntities(video.title) : (video.originalUrl ? decodeHtmlEntities(video.originalUrl) : "Unknown Title"),
                                artist: video.artist ? decodeHtmlEntities(video.artist) : ""
                            }))
                          }))
                        : [{id: defaultPlaylistId, name: "Playlist", videos: []}], // Default if playlists are missing/empty
                    playJockeyCurrentPlaylistId: loadedData.playJockeyCurrentPlaylistId || defaultPlaylistId,
                    playJockeyCurrentVideo: loadedData.playJockeyCurrentVideo ? {
                        ...(loadedData.playJockeyCurrentVideo),
                        title: loadedData.playJockeyCurrentVideo.title ? decodeHtmlEntities(loadedData.playJockeyCurrentVideo.title) : "Unknown Title",
                        artist: loadedData.playJockeyCurrentVideo.artist ? decodeHtmlEntities(loadedData.playJockeyCurrentVideo.artist) : ""
                    } : null,
                    // Ensure boolean/specific values have fallbacks if malformed in storage
                    playJockeyAutoPlayEnabled: typeof loadedData.playJockeyAutoPlayEnabled === 'boolean' ? loadedData.playJockeyAutoPlayEnabled : defaultAppData.playJockeyAutoPlayEnabled,
                    playJockeyRandomEnabled: typeof loadedData.playJockeyRandomEnabled === 'boolean' ? loadedData.playJockeyRandomEnabled : defaultAppData.playJockeyRandomEnabled,
                    playJockeyRepeatState: ["off", "playlist", "song"].includes(loadedData.playJockeyRepeatState) ? loadedData.playJockeyRepeatState : defaultAppData.playJockeyRepeatState,
                    playJockeyRandomHistory: Array.isArray(loadedData.playJockeyRandomHistory) ? loadedData.playJockeyRandomHistory : []
                };
                
                // Ensure current playlist ID is valid
                if (!appData.playJockeyPlaylists.find(pl => pl.id === appData.playJockeyCurrentPlaylistId)) {
                    appData.playJockeyCurrentPlaylistId = appData.playJockeyPlaylists[0]?.id || defaultPlaylistId;
                     if (appData.playJockeyPlaylists.length === 0) { // Should be caught by ternary above, but extra safety
                        appData.playJockeyPlaylists = [{id: defaultPlaylistId, name: "Playlist", videos: []}];
                        appData.playJockeyCurrentPlaylistId = defaultPlaylistId;
                    }
                }
                // Ensure core arrays/objects exist
                appData.areas = appData.areas || [];
                appData.achievements = appData.achievements || {};
                appData.quests = appData.quests || {};
                // Validate selectedDayIndex and viewMode
                if (typeof appData.selectedDayIndex !== 'number' || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) {
                    appData.selectedDayIndex = defaultAppData.selectedDayIndex;
                }
                 if (appData.viewMode !== 'week' && appData.viewMode !== 'day') {
                    appData.viewMode = defaultAppData.viewMode;
                }

            } catch (error) {
                console.error("Error parsing stored data, reverting to defaults:", error);
                appData = JSON.parse(JSON.stringify(defaultAppData)); // Deep copy defaults
            }
        } else {
             appData = JSON.parse(JSON.stringify(defaultAppData)); // Deep copy defaults if no stored data
        }
    }

    function getMonday(d) {
        d = new Date(d);
        const currentDay = d.getDay(); // Sunday = 0, Monday = 1, ...
        const diffToMondayVal = d.getDate() - currentDay + (currentDay === 0 ? -6 : 1); // Adjust for Sunday
        const mondayDate = new Date(d.getFullYear(), d.getMonth(), diffToMondayVal);
        return mondayDate;
    }

    function getWeekNumber(d) { // d is a Date object
        d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7)); // Thursday of that week
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7); // Calculate week number
    }

    function getCurrentWeekId() {
        if (!appData.currentWeekStartDate) {
            // This should ideally be set by init() if null after loadData()
            appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        }
        const startDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        return `${startDate.getFullYear()}-W${String(getWeekNumber(startDate)).padStart(2, '0')}`;
    }

    function navigateWeek(offsetInDays) {
        const currentMon = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        currentMon.setDate(currentMon.getDate() + offsetInDays);
        appData.currentWeekStartDate = getMonday(currentMon).toISOString().split('T')[0];
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        saveData();
    }

    function navigateDay(offset) {
        appData.selectedDayIndex += offset;
        let weekChanged = false;
        let currentMonDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);

        if (appData.selectedDayIndex < 0) { // Moved to previous week
            currentMonDate.setDate(currentMonDate.getDate() - 7);
            appData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            appData.selectedDayIndex = 6; // Last day of the new current week
            weekChanged = true;
        } else if (appData.selectedDayIndex > 6) { // Moved to next week
            currentMonDate.setDate(currentMonDate.getDate() + 7);
            appData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            appData.selectedDayIndex = 0; // First day of the new current week
            weekChanged = true;
        }

        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        if (weekChanged) {
            generateQuestsForCurrentWeekIfNeeded();
        }
        saveData();
    }

    function goToThisWeek() {
        appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        if(appData.viewMode === 'day') {
            const today = new Date();
            let currentDayOfWeek = today.getDay(); // Sunday = 0
            appData.selectedDayIndex = (currentDayOfWeek === 0) ? 6 : currentDayOfWeek - 1; // Mon = 0 .. Sun = 6
        }
        updateViewControls(); // Reflect potential mode change if "Today" also means "This Week" context
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded(); // Quests are weekly
        saveData();
    }

    function toggleViewMode() {
        const appWindow = DOM.xpMainWindow;
        const state = appData.windowStates.xpMainWindow; // Assumed to exist

        const wasMaximized = appWindow.classList.contains('true-maximized');
        const wasMinimized = appWindow.classList.contains('minimized');

        if (appData.viewMode === 'week') {
            appData.viewMode = 'day';
            minTrackerAppWidth = 375;
            const today = new Date();
            const currentWeekMondayObj = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
            // Check if "today" is within the currently displayed week
            const checkDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const weekStartCheck = new Date(currentWeekMondayObj.getFullYear(), currentWeekMondayObj.getMonth(), currentWeekMondayObj.getDate());
            const weekEndCheck = new Date(weekStartCheck);
            weekEndCheck.setDate(weekStartCheck.getDate() + 6);

            if (checkDate >= weekStartCheck && checkDate <= weekEndCheck) { // If today is in current week
                let currentDayOfWeek = today.getDay(); // Sunday = 0
                appData.selectedDayIndex = (currentDayOfWeek === 0) ? 6 : currentDayOfWeek - 1; // Mon=0..Sun=6
            } else { // If not, default to the first day of the current week
                 if (appData.selectedDayIndex === undefined || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) {
                    appData.selectedDayIndex = 0;
                }
            }
        } else { // Switching from day to week
            appData.viewMode = 'week';
            minTrackerAppWidth = 905;
            // selectedDayIndex is not directly used in week view display but kept in appData
        }

        // Adjust window width if it's now smaller than the new min width, and not maximized/minimized
        if (!wasMaximized && !wasMinimized) {
            let currentWidth = appWindow.offsetWidth;
            if (currentWidth < minTrackerAppWidth) {
                appWindow.style.width = minTrackerAppWidth + 'px';
                if(state) {
                    state.width = minTrackerAppWidth; // Update state
                    state.userManuallySet = false; // No longer user-set if forced to minWidth
                }
            } else if (state && !state.userManuallySet) { // If it was default sized, re-evaluate
                 setWindowDefaults('xpMainWindow', false); // Let defaults re-evaluate size potentially
            }
        }


        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        saveData(); // Save new viewMode and potentially selectedDayIndex
    }

    function updateDateDisplay() {
        const currentMonday = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        if (appData.viewMode === 'week') {
            const weekEndDate = new Date(currentMonday);
            weekEndDate.setDate(currentMonday.getDate() + 6);
            const options = { month: 'short', day: 'numeric' };
            DOM.currentWeekDisplay.textContent = `${currentMonday.toLocaleDateString(undefined, options)} - ${weekEndDate.toLocaleDateString(undefined, options)}`;
            DOM.weekCountDisplay.textContent = `Year Week: ${getWeekNumber(currentMonday)}`;
        } else { // Day view
            const selectedDate = new Date(currentMonday);
             const currentDayIndex = (typeof appData.selectedDayIndex === 'number' && appData.selectedDayIndex >= 0 && appData.selectedDayIndex <=6) ? appData.selectedDayIndex : 0;
             selectedDate.setDate(currentMonday.getDate() + currentDayIndex);
            
            const dayDisplayOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            DOM.currentWeekDisplay.textContent = selectedDate.toLocaleDateString(undefined, dayDisplayOptions);
            DOM.weekCountDisplay.textContent = `Year Day: ${getDayOfYear(selectedDate)}`;
        }
    }

    function renderWeekdayHeaders() {
        DOM.weekdayHeaders.innerHTML = '<th>Area</th>'; // Reset headers
        if (appData.viewMode === 'week') {
            WEEKDAYS.forEach(day => {
                const th = document.createElement('th');
                th.textContent = day;
                DOM.weekdayHeaders.appendChild(th);
            });
        } else { // Day view
            const th = document.createElement('th');
            const dayDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
            const currentDayIndex = (typeof appData.selectedDayIndex === 'number' && appData.selectedDayIndex >= 0 && appData.selectedDayIndex <=6) ? appData.selectedDayIndex : 0;
            dayDate.setDate(dayDate.getDate() + currentDayIndex); // Get the specific day
            th.textContent = `${WEEKDAYS[currentDayIndex]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;
            DOM.weekdayHeaders.appendChild(th);
        }
    }

    function renderGrid() {
        DOM.gridBody.innerHTML = ''; // Clear existing grid
        appData.areas.forEach(area => {
            const tr = document.createElement('tr');
            tr.dataset.areaName = area.name;

            const nameTd = document.createElement('td');
            nameTd.className = 'area-name-cell';
            // XP Bar details
            const currentXP = area.xp;
            const xpToNext = xpForNextLevel(area.level);
            const percentage = xpToNext > 0 ? Math.min((currentXP / xpToNext) * 100, 100) : (currentXP > 0 ? 100 : 0);

            nameTd.innerHTML = `
                <div class="area-name-wrapper">
                    <span>${decodeHtmlEntities(area.name)}</span>
                    <button class="xp-button delete-area-btn" data-area-name="${area.name}" title="Delete ${area.name}">X</button>
                </div>
                <div class="area-stats">
                    <span>Level: <span class="area-level">${area.level}</span></span>
                    <div class="xp-bar-container">
                        <div class="xp-bar" style="width: ${percentage}%;"></div>
                        <div class="xp-bar-text"><span class="area-xp">${currentXP}</span> / ${xpToNext} XP</div>
                    </div>
                </div>`;
            tr.appendChild(nameTd);

            const renderCellContent = (td, areaName, dayIdx) => {
                const achievementsKey = `${appData.currentWeekStartDate}_${areaName}_${dayIdx}`;
                const cellAchievements = appData.achievements[achievementsKey] || [];

                cellAchievements.forEach(ach => {
                    const achDiv = document.createElement('div');
                    achDiv.className = 'achievement-item';
                    achDiv.dataset.achId = ach.id;
                    achDiv.dataset.achKey = achievementsKey;

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'achievement-content';
                    if (ach.type === 'text') {
                        contentDiv.textContent = decodeHtmlEntities(ach.content);
                    } else if (ach.type === 'image') {
                        const img = document.createElement('img');
                        img.src = ach.content; // Assuming content is a valid image URL or data URL
                        img.alt = "Achievement Image";
                        contentDiv.appendChild(img);
                    }
                    achDiv.appendChild(contentDiv);

                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'achievement-item-actions';
                    actionsDiv.innerHTML = `
                        <button class="xp-button xp-button-small edit-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Edit">Edit</button>
                        <button class="xp-button xp-button-small remove-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Delete">Del</button>
                    `;
                    achDiv.appendChild(actionsDiv);
                    achDiv.title = `XP: ${ach.xp} | Added: ${new Date(ach.timestamp).toLocaleString()}`;
                    td.appendChild(achDiv);
                });

                const addAchBtn = document.createElement('button');
                addAchBtn.className = 'xp-button achievement-add-btn-cell';
                addAchBtn.textContent = '+';
                addAchBtn.dataset.areaName = areaName;
                addAchBtn.dataset.dayIndex = dayIdx;

                const dayDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
                dayDate.setDate(dayDate.getDate() + dayIdx);
                addAchBtn.title = `Add achievement to ${decodeHtmlEntities(areaName)} on ${WEEKDAYS[dayIdx]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;

                td.appendChild(addAchBtn);
            };

            if (appData.viewMode === 'week') {
                WEEKDAYS.forEach((day, dayIndex) => {
                    const td = document.createElement('td');
                    td.dataset.areaName = area.name;
                    td.dataset.dayIndex = dayIndex;
                    renderCellContent(td, area.name, dayIndex);
                    tr.appendChild(td);
                });
            } else { // Day view
                const dayIndex = (typeof appData.selectedDayIndex === 'number' && appData.selectedDayIndex >= 0 && appData.selectedDayIndex <=6) ? appData.selectedDayIndex : 0;
                const td = document.createElement('td');
                td.dataset.areaName = area.name;
                td.dataset.dayIndex = dayIndex; // Store the actual day index
                renderCellContent(td, area.name, dayIndex);
                tr.appendChild(td);
            }
            DOM.gridBody.appendChild(tr);
        });
    }


    function getXpPercentage(area) {
        const required = xpForNextLevel(area.level);
        return required > 0 ? Math.min((area.xp / required) * 100, 100) : (area.xp > 0 ? 100 : 0);
    }

    function saveNewArea() {
        const name = DOM.newAreaNameInput.value.trim();
        if (!name) {
            alert("Area name cannot be empty.");
            return;
        }
        if (appData.areas.find(a => a.name.toLowerCase() === name.toLowerCase())) {
            alert("Area with this name already exists.");
            return;
        }

        appData.areas.push({ name: name, level: 1, xp: 0 }); // Store name as entered (plain text)
        DOM.newAreaNameInput.value = '';
        closeModal(MODAL_IDS.NEW_AREA);
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded(true); // Force regeneration if new area might affect quest pool
        saveData();
    }

    function promptRemoveArea(areaName) {
        DOM.confirmRemoveAreaMessage.textContent = `Are you sure you want to remove the area "${decodeHtmlEntities(areaName)}"? This action cannot be undone and will delete all associated achievements and quests.`;
        DOM.confirmRemoveBtn.dataset.areaNameToRemove = areaName; // Store plain name
        openModal(MODAL_IDS.CONFIRM_REMOVE_AREA);
    }

    function removeArea(areaName) { // areaName is plain text
        appData.areas = appData.areas.filter(area => area.name !== areaName);

        // Remove achievements associated with this area
        const achievementKeysToDelete = [];
        for (const key in appData.achievements) {
            if (appData.achievements.hasOwnProperty(key)) {
                const parts = key.split('_'); // Format: YYYY-MM-DD_AreaName_DayIndex
                // Reconstruct area name from key parts (can contain underscores)
                const keyAreaName = parts.slice(1, parts.length -1).join('_');
                if (keyAreaName === areaName) {
                    achievementKeysToDelete.push(key);
                }
            }
        }
        achievementKeysToDelete.forEach(key => delete appData.achievements[key]);

        // Remove quests associated with this area
        for (const weekId in appData.quests) {
            if (appData.quests.hasOwnProperty(weekId)) {
                appData.quests[weekId] = appData.quests[weekId].filter(quest => quest.areaName !== areaName);
            }
        }

        generateQuestsForCurrentWeekIfNeeded(true); // Regenerate if pool changed
        updateDateDisplay(); // In case view depends on area data (not directly, but good practice)
        renderWeekdayHeaders();
        renderGrid();
        saveData();
    }

    function openAddEditAchievementModal(areaName, dayIndex, achievementKeyToEdit = null, achievementIdToEdit = null) {
        DOM.achievementImageInput.value = null; // Clear file input
        DOM.achievementTextInput.value = '';
        DOM.editingAchievementKeyInput.value = '';
        DOM.editingAchievementIdInput.value = '';

        if (achievementKeyToEdit && achievementIdToEdit) { // Editing existing achievement
            const achievementsInCell = appData.achievements[achievementKeyToEdit];
            const achievementToEdit = achievementsInCell ? achievementsInCell.find(ach => ach.id === achievementIdToEdit) : null;

            if (!achievementToEdit) {
                alert("Error: Could not find achievement to edit.");
                return;
            }

            const keyParts = achievementKeyToEdit.split('_');
            const currentAreaName = keyParts.slice(1, keyParts.length -1).join('_'); // Reconstruct area name
            const currentDayIndex = parseInt(keyParts[keyParts.length -1]);

            DOM.achievementAreaNameInput.value = currentAreaName; // Plain text area name
            DOM.achievementDayIndexInput.value = currentDayIndex;
            DOM.editingAchievementKeyInput.value = achievementKeyToEdit;
            DOM.editingAchievementIdInput.value = achievementIdToEdit;

            DOM.addEditAchievementModalTitle.textContent = "Edit Achievement";
            DOM.saveAchievementBtn.textContent = "Update Achievement";

            if (achievementToEdit.type === 'text') {
                DOM.achievementTypeRadios[0].checked = true;
                DOM.achievementTextInput.value = decodeHtmlEntities(achievementToEdit.content); // Decode for editing
            } else if (achievementToEdit.type === 'image') {
                DOM.achievementTypeRadios[1].checked = true;
                // Image content (URL/base64) is not HTML encoded
            }
        } else { // Adding new achievement
            DOM.achievementAreaNameInput.value = areaName; // Plain text area name
            DOM.achievementDayIndexInput.value = dayIndex;
            DOM.addEditAchievementModalTitle.textContent = "Add Achievement";
            DOM.saveAchievementBtn.textContent = "Save Achievement";
            DOM.achievementTypeRadios[0].checked = true; // Default to text
        }
        toggleAchievementInputType(); // Show/hide text/image input fields
        openModal(MODAL_IDS.ADD_EDIT_ACHIEVEMENT);
        if(DOM.achievementTypeRadios[0].checked) DOM.achievementTextInput.focus();
    }


    function toggleAchievementInputType() {
        if (DOM.achievementTypeRadios[0].checked) { // Text type
            DOM.textInputDiv.style.display = 'block';
            DOM.imageInputDiv.style.display = 'none';
        } else { // Image type
            DOM.textInputDiv.style.display = 'none';
            DOM.imageInputDiv.style.display = 'block';
        }
    }

    function saveOrUpdateAchievement() {
        const areaName = DOM.achievementAreaNameInput.value; // Plain text
        const dayIndex = parseInt(DOM.achievementDayIndexInput.value);
        const type = document.querySelector('input[name="achievementType"]:checked').value;
        const editingKey = DOM.editingAchievementKeyInput.value;
        const editingId = DOM.editingAchievementIdInput.value;

        const isEditing = editingKey && editingId;
        let achievement;

        const achievementsKey = isEditing ? editingKey : `${appData.currentWeekStartDate}_${areaName}_${dayIndex}`;
        if (!appData.achievements[achievementsKey] && !isEditing) { // Ensure array exists for new achievements
            appData.achievements[achievementsKey] = [];
        }

        let achievementList = appData.achievements[achievementsKey] || []; // Get the list (or empty if somehow still null)

        if (isEditing) {
            achievement = achievementList.find(ach => ach.id === editingId);
            if (!achievement) {
                alert("Error: Could not find achievement to update.");
                return;
            }
        } else { // New achievement
            achievement = {
                id: Date.now() + '-' + Math.random().toString(36).substring(2, 9), // Unique ID
                timestamp: new Date().toISOString(),
                xp: XP_PER_REGULAR_ACHIEVEMENT // Standard XP for new achievement
            };
        }

        achievement.type = type;

        const processSave = (contentToSave) => {
            // Content for text is stored as plain text. For images, it's URL/base64.
            achievement.content = contentToSave; 
            if (isEditing) {
                // XP is generally not re-added on edit unless content/type changes significantly (not implemented here)
            } else { // New achievement
                achievementList.push(achievement);
                addXpToArea(areaName, achievement.xp);
                updateQuestProgress(areaName, achievement.xp); // Update quests with XP gained
            }

            closeModal(MODAL_IDS.ADD_EDIT_ACHIEVEMENT);
            renderGrid();
            saveData();
        };

        if (type === 'text') {
            const textContent = DOM.achievementTextInput.value.trim(); // Input value is plain text
            if (!textContent) {
                alert("Achievement description cannot be empty.");
                return;
            }
            processSave(textContent); // Save plain text
        } else if (type === 'image') {
            const file = DOM.achievementImageInput.files[0];
            if (file) { // New image uploaded
                if (file.size > 2 * 1024 * 1024) { // 2MB limit
                    alert("Image file is too large. Please choose an image under 2MB.");
                    return;
                }
                const reader = new FileReader();
                reader.onloadend = function() {
                    processSave(reader.result); // Save base64 string
                }
                reader.onerror = function() { alert("Error reading image file."); }
                reader.readAsDataURL(file);
            } else if (isEditing && achievement.type === 'image' && achievement.content) {
                // Editing, but no new image selected, keep existing image
                processSave(achievement.content);
            } else if (!isEditing || (isEditing && achievement.type !== 'image')) {
                // New image achievement or type changed to image, but no file selected
                alert("Please select an image file for an image type achievement.");
                return;
            }
        }
    }

    function promptRemoveAchievement(achievementKey, achievementId) {
        DOM.confirmDeleteAchievementBtn.dataset.achievementKey = achievementKey;
        DOM.confirmDeleteAchievementBtn.dataset.achievementId = achievementId;
        openModal(MODAL_IDS.CONFIRM_DELETE_ACHIEVEMENT);
    }

    function confirmRemoveAchievement(achievementKey, achievementId) {
        if (!appData.achievements[achievementKey]) return;

        const achIndex = appData.achievements[achievementKey].findIndex(ach => ach.id === achievementId);
        if (achIndex === -1) return; // Achievement not found

        const achievementToRemove = appData.achievements[achievementKey][achIndex];
        const xpToRemove = achievementToRemove.xp;

        const keyParts = achievementKey.split('_');
        const areaName = keyParts.slice(1, keyParts.length -1).join('_'); // Reconstruct area name

        appData.achievements[achievementKey].splice(achIndex, 1); // Remove from list
        if (appData.achievements[achievementKey].length === 0) { // Clean up empty list
            delete appData.achievements[achievementKey];
        }

        subtractXpFromArea(areaName, xpToRemove); // Deduct XP
        updateQuestProgress(areaName, -xpToRemove); // Update quest progress (negative gain)

        renderGrid();
        saveData();
    }


    function xpForNextLevel(currentLevel) {
        if (currentLevel <= 0) return 50; // Level 0 or less, first level up is 50 XP
        return Math.floor(50 * Math.pow(currentLevel, 1.5));
    }

    function addXpToArea(areaName, xpAmount) { // areaName is plain text
        const area = appData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp += xpAmount;
            let leveledUp = false;
            let requiredForNext = xpForNextLevel(area.level);

            while (area.xp >= requiredForNext && requiredForNext > 0) { // Loop for multiple level-ups
                area.xp -= requiredForNext;
                area.level++;
                leveledUp = true;
                requiredForNext = xpForNextLevel(area.level); // Get XP for the new current level
            }

            if (leveledUp) {
                alert(`${decodeHtmlEntities(area.name)} leveled up to Level ${area.level}!`);
                generateQuestsForCurrentWeekIfNeeded(true); // Potentially refresh quests if level changes
            }
        }
    }

    function subtractXpFromArea(areaName, xpAmount) { // areaName is plain text
        const area = appData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp -= xpAmount;
            let deLeveled = false;
            // Handle de-leveling if XP drops below zero for the current level
            while (area.xp < 0) {
                if (area.level > 1) { // Cannot de-level below 1
                    area.level--;
                    deLeveled = true;
                    // Add the XP requirement of the *new lower* level to the negative XP
                    area.xp += xpForNextLevel(area.level); 
                } else {
                    area.xp = 0; // Cannot go below 0 XP at level 1
                    break;
                }
            }
            if (deLeveled) {
                generateQuestsForCurrentWeekIfNeeded(true); // Potentially refresh quests
            }
        }
    }


    function generateQuestsForCurrentWeekIfNeeded(forceRegenerate = false) {
        const weekId = getCurrentWeekId();

        if (!appData.quests) appData.quests = {};
        if (!appData.quests[weekId] || forceRegenerate) { // If no quests for week or forcing
            appData.quests[weekId] = []; // Initialize/clear quests for the week
        }

        if (appData.areas.length < 1 && !forceRegenerate) { // No areas, no auto-generated quests
            if(appData.quests[weekId].length === 0) return; // No existing manual quests either
        }
        
        // Only generate if list is empty and not forced (initial generation) or if forced.
        if (forceRegenerate || appData.quests[weekId].length === 0) {
            if (forceRegenerate) appData.quests[weekId] = []; // Ensure empty if forcing

            const questsToPotentiallyGenerate = Math.min(MAX_WEEKLY_QUESTS, appData.areas.length, 3); // Max 3 auto-generated
            let generatedCount = 0;

            // Filter out areas that already have a quest this week to avoid duplicates if not forceRegenerating all
            const availableAreasForNewQuests = [...appData.areas].filter(area =>
                !appData.quests[weekId].some(q => q.areaName === area.name)
            );
             // If all areas have quests but we are short of MAX and forceRegenerate is false, don't add more of same.
            // If forceRegenerate is true, this filter is less important as list is cleared.

            // Shuffle available areas to pick from
            let shuffledAreas = [...(availableAreasForNewQuests.length > 0 ? availableAreasForNewQuests : appData.areas)];
            for (let i = shuffledAreas.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledAreas[i], shuffledAreas[j]] = [shuffledAreas[j], shuffledAreas[i]];
            }


            for (let i = 0; i < questsToPotentiallyGenerate && appData.quests[weekId].length < MAX_WEEKLY_QUESTS; i++) {
                if (shuffledAreas.length === 0) break; // No more areas to pick from

                const selectedArea = shuffledAreas.pop(); // Pick one from shuffled list
                if (!selectedArea) continue;
                // Skip if this area already got a quest in this generation pass (relevant if shuffledAreas can have duplicates somehow or logic changes)
                if(appData.quests[weekId].some(q => q.areaName === selectedArea.name)) continue;


                const targetXPEarned = 20 + (selectedArea.level * 10); // Scale with area level
                const rewardXP = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5); // Scale reward

                appData.quests[weekId].push({
                    id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}_${i}`,
                    areaName: selectedArea.name, // Plain name
                    description: `Earn ${targetXPEarned} XP in "${decodeHtmlEntities(selectedArea.name)}" this week.`,
                    targetXPEarned: targetXPEarned,
                    currentXPEarned: 0,
                    rewardXP: rewardXP,
                    completed: false
                });
                generatedCount++;
            }
        }
        // saveData(); // Called by functions that trigger this (e.g., init, navigateWeek)
    }

    function updateQuestProgress(areaName, xpGained) { // areaName is plain
        const weekId = getCurrentWeekId();
        if (!appData.quests || !appData.quests[weekId]) return;

        let questCompletedThisUpdate = false;
        appData.quests[weekId].forEach(quest => {
            if (quest.areaName === areaName && !quest.completed) {
                quest.currentXPEarned += xpGained;
                if (quest.currentXPEarned < 0) quest.currentXPEarned = 0; // XP shouldn't go negative

                if (quest.currentXPEarned >= quest.targetXPEarned) {
                    quest.completed = true;
                    quest.currentXPEarned = quest.targetXPEarned; // Cap at target
                    addXpToArea(quest.areaName, quest.rewardXP); // Grant reward XP
                    alert(`Quest Completed: ${decodeHtmlEntities(quest.description)}\n+${quest.rewardXP} XP to ${decodeHtmlEntities(quest.areaName)}!`);
                    questCompletedThisUpdate = true;
                }
            }
        });

        if (questCompletedThisUpdate) {
            renderGrid(); // Re-render grid to show XP/level changes from quest reward
            // showQuests(); // If quest modal is open, refresh it (optional, or handle on modal open)
            saveData();
        }
    }

    function showQuests() {
        const weekId = getCurrentWeekId();
        DOM.questsList.innerHTML = ''; // Clear previous list

        generateQuestsForCurrentWeekIfNeeded(); // Ensure quests are generated/loaded for the current week

        const currentQuests = appData.quests[weekId] || [];

        if (currentQuests.length === 0) {
            DOM.questsList.innerHTML = `<p>No quests available for this week.${appData.areas.length === 0 ? ' Add some areas first to generate quests!' : ' You can create new quests manually.'}</p>`;
        } else {
            currentQuests.forEach(quest => {
                const questDiv = document.createElement('div');
                questDiv.className = 'quest-item';
                if (quest.completed) {
                    questDiv.classList.add('completed');
                }

                const title = document.createElement('div');
                title.className = 'quest-title';
                title.textContent = `Quest for: ${decodeHtmlEntities(quest.areaName)}`;

                const details = document.createElement('div');
                details.className = 'quest-details';
                details.textContent = decodeHtmlEntities(quest.description);

                const progress = document.createElement('div');
                progress.className = 'quest-progress';
                progress.textContent = `Progress: ${Math.min(quest.currentXPEarned, quest.targetXPEarned)} / ${quest.targetXPEarned} XP. Reward: ${quest.rewardXP} XP.`;

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'quest-actions';
                if (!quest.completed) {
                    const refreshBtn = document.createElement('button');
                    refreshBtn.className = 'xp-button xp-button-small refresh-quest-btn';
                    refreshBtn.dataset.questId = quest.id;
                    refreshBtn.textContent = 'Refresh';
                    actionsDiv.appendChild(refreshBtn);
                }

                questDiv.appendChild(title);
                questDiv.appendChild(details);
                questDiv.appendChild(progress);
                questDiv.appendChild(actionsDiv);
                DOM.questsList.appendChild(questDiv);
            });
        }
        DOM.addQuestBtn.disabled = currentQuests.length >= MAX_WEEKLY_QUESTS;
        openModal(MODAL_IDS.QUESTS);
    }

    function openCreateQuestModal() {
        const weekId = getCurrentWeekId();
        if (appData.quests[weekId] && appData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Maximum of ${MAX_WEEKLY_QUESTS} quests per week reached.`);
            return;
        }
        if (appData.areas.length === 0) {
            alert("Please create at least one Area before adding quests.");
            return;
        }

        DOM.newQuestAreaNameSelect.innerHTML = ''; // Clear previous options
        appData.areas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.name; // Store plain name
            option.textContent = decodeHtmlEntities(area.name); // Display decoded
            DOM.newQuestAreaNameSelect.appendChild(option);
        });
        DOM.newQuestDescriptionInput.value = '';
        DOM.newQuestTargetXPInput.value = 30;
        DOM.newQuestRewardXPInput.value = 50;
        openModal(MODAL_IDS.CREATE_QUEST);
    }

    function saveNewQuest() {
        const weekId = getCurrentWeekId();
        // Ensure quests for the week are initialized
        if (!appData.quests[weekId]) appData.quests[weekId] = [];

        if (appData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Cannot add new quest: Maximum of ${MAX_WEEKLY_QUESTS} quests reached for this week.`);
            return;
        }

        const areaName = DOM.newQuestAreaNameSelect.value; // Plain name
        const description = DOM.newQuestDescriptionInput.value.trim(); // Plain text
        const targetXP = parseInt(DOM.newQuestTargetXPInput.value);
        const rewardXP = parseInt(DOM.newQuestRewardXPInput.value);

        if (!areaName) { alert("Please select an area."); return; }
        if (!description) { alert("Please enter a description."); return; }
        if (isNaN(targetXP) || targetXP <= 0) { alert("Target XP must be a positive number."); return; }
        if (isNaN(rewardXP) || rewardXP <= 0) { alert("Reward XP must be a positive number."); return; }

        const newQuest = {
            id: `quest_${weekId}_${areaName.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName: areaName, // Store plain name
            description: description, // Store plain description
            targetXPEarned: targetXP,
            currentXPEarned: 0,
            rewardXP: rewardXP,
            completed: false
        };

        appData.quests[weekId].push(newQuest);

        closeModal(MODAL_IDS.CREATE_QUEST);
        showQuests(); // Refresh quest list in modal
        saveData();
    }

    function promptRefreshQuest(questId) {
        DOM.confirmRefreshQuestBtn.dataset.questIdToRefresh = questId;
        openModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
    }

    function generateSingleRandomQuest(weekId, questToReplace = null) {
        if (appData.areas.length === 0) return null;

        let potentialAreas = [...appData.areas];
        // Try to pick a different area than the one being replaced, if possible
        if (questToReplace && potentialAreas.length > 1) {
            const filteredAreas = potentialAreas.filter(a => a.name !== questToReplace.areaName);
            if (filteredAreas.length > 0) {
                potentialAreas = filteredAreas;
            }
            // If only one area exists, or filtering results in no areas, it will pick from all original areas.
        }
        
        if(potentialAreas.length === 0) potentialAreas = [...appData.areas]; // Fallback if filtering left no options

        const randomAreaIndex = Math.floor(Math.random() * potentialAreas.length);
        const selectedArea = potentialAreas[randomAreaIndex];

        const baseTarget = 20 + (selectedArea.level * 10); // Base on level
        // Add some randomness to target XP
        const targetXPEarned = Math.max(10, Math.round(baseTarget + (Math.random() * baseTarget * 0.3) - (baseTarget * 0.15)) ); 
        const baseReward = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5);
        const rewardXP = Math.max(10, Math.round(baseReward + (Math.random() * baseReward * 0.2) - (baseReward * 0.1)));

        return {
            id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName: selectedArea.name, // Plain name
            description: `Earn ${targetXPEarned} XP in "${decodeHtmlEntities(selectedArea.name)}" this week. (Refreshed)`,
            targetXPEarned: targetXPEarned,
            currentXPEarned: 0,
            rewardXP: rewardXP,
            completed: false
        };
    }

    function confirmAndRefreshQuest() {
        const questIdToRefresh = DOM.confirmRefreshQuestBtn.dataset.questIdToRefresh;
        const weekId = getCurrentWeekId();

        if (!questIdToRefresh || !appData.quests[weekId]) {
            closeModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
            return;
        }

        const questIndex = appData.quests[weekId].findIndex(q => q.id === questIdToRefresh);
        if (questIndex === -1) {
            closeModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
            return; // Quest not found
        }

        const oldQuest = appData.quests[weekId][questIndex];
        // Remove the old quest
        appData.quests[weekId].splice(questIndex, 1);

        // Generate a new random quest
        const newQuest = generateSingleRandomQuest(weekId, oldQuest); 
        if (newQuest) {
            appData.quests[weekId].push(newQuest);
        } else if (appData.areas.length > 0) { // Only alert if areas exist but quest gen failed
            alert("Could not generate a new quest. Try again or create one manually.");
        }
        
        closeModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
        showQuests(); // Refresh quest list
        saveData();
    }

    // --- PlayJockey Functions ---

    function getCurrentPlayJockeyPlaylist() {
        if (!appData.playJockeyCurrentPlaylistId || !appData.playJockeyPlaylists) {
            if (appData.playJockeyPlaylists && appData.playJockeyPlaylists.length > 0) {
                appData.playJockeyCurrentPlaylistId = appData.playJockeyPlaylists[0].id; // Default to first if current is invalid
            } else { // No playlists exist at all
                return null;
            }
        }
        return appData.playJockeyPlaylists.find(p => p.id === appData.playJockeyCurrentPlaylistId);
    }


    function onYouTubeIframeAPIReady() {
        isYouTubeApiReady = true;
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        const currentVideoInPlaylist = currentPlaylist?.videos.find(v => v.id === appData.playJockeyCurrentVideo?.id);

        if (pendingVideoToLoad && currentVideoInPlaylist) { // If a video was queued
            playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
            pendingVideoToLoad = null;
        } else if (appData.playJockeyCurrentVideo && currentVideoInPlaylist && !ytPlayerInstance && DOM.playJockeyWindow.style.display !== 'none' && !DOM.playJockeyWindow.classList.contains('minimized')) {
            // If window is open, API ready, and a video should be playing
            playYouTubeVideoById(appData.playJockeyCurrentVideo.videoId, appData.playJockeyAutoPlayEnabled);
        }
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        // Regex to capture video ID from various YouTube URL formats
        const regex = /(?:youtube\.com\/(?:[^\/\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }

    function isValidYouTubeUrl(url) {
        if (!url) return false;
        const regex = /^(https?:\/\/)?(www\.)?(youtube\.com\/(watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})([&?].*)?$/;
        return regex.test(url);
    }

    async function handlePlayJockeyInput() {
        const input = DOM.playJockeyLinkInput.value.trim();
        if (!input) {
            alert("Please enter a YouTube link or search query.");
            return;
        }

        const apiKeyMissing = (YOUTUBE_API_KEY === "YOUR_YOUTUBE_API_KEY" || !YOUTUBE_API_KEY);

        if (isValidYouTubeUrl(input)) {
            addYouTubeLinkToPlayJockey(input);
        } else { // Treat as search query
            if (apiKeyMissing) {
                alert("YouTube API Key is not configured. Video search is disabled. You can only add direct YouTube video links.");
                return;
            }
            searchYouTubeVideos(input);
        }
    }

    async function searchYouTubeVideos(query) {
        // API Key check done in handlePlayJockeyInput

        DOM.youtubeSearchResultsBody.innerHTML = ''; // Clear previous results
        DOM.youtubeSearchStatus.textContent = 'Searching...';
        DOM.youtubeSearchStatus.style.display = 'block';
        openModal(MODAL_IDS.Youtube);

        const maxResults = 10;
        const apiUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&key=${YOUTUBE_API_KEY}&maxResults=${maxResults}`;

        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                const errorData = await response.json();
                console.error('YouTube API Error:', errorData);
                let errorMessage = `Error searching videos: ${response.statusText}`;
                if (errorData.error && errorData.error.message) {
                    errorMessage += ` - ${errorData.error.message}`;
                }
                DOM.youtubeSearchStatus.textContent = errorMessage;
                return;
            }
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                DOM.youtubeSearchStatus.style.display = 'none'; // Hide status on success
                renderYouTubeSearchResults(data.items);
            } else {
                DOM.youtubeSearchStatus.textContent = 'No videos found for your search query.';
            }
        } catch (error) {
            console.error('Error fetching Youtube results:', error);
            DOM.youtubeSearchStatus.textContent = 'Failed to search videos. Check console for details.';
        }
    }

    function renderYouTubeSearchResults(items) {
        DOM.youtubeSearchResultsBody.innerHTML = ''; // Clear again just in case

        items.forEach(item => {
            const videoId = item.id.videoId;
            const title = decodeHtmlEntities(item.snippet.title); // Already decoded
            const channelTitle = decodeHtmlEntities(item.snippet.channelTitle); // Already decoded
            const thumbnailUrl = item.snippet.thumbnails.default.url;

            const resultDiv = document.createElement('div');
            resultDiv.className = 'Youtube-result-item';
            resultDiv.dataset.videoId = videoId;
            // No need for rawTitle/Artist if passing decoded versions directly

            const img = document.createElement('img');
            img.src = thumbnailUrl;
            img.alt = title; // Use decoded title for alt text

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'Youtube-result-item-details';

            const titleDiv = document.createElement('div');
            titleDiv.className = 'Youtube-result-item-title';
            titleDiv.textContent = title;
            titleDiv.title = title; // Tooltip with full title


            const channelDiv = document.createElement('div');
            channelDiv.className = 'Youtube-result-item-channel';
            channelDiv.textContent = channelTitle;
            channelDiv.title = channelTitle;


            detailsDiv.appendChild(titleDiv);
            detailsDiv.appendChild(channelDiv);
            resultDiv.appendChild(img);
            resultDiv.appendChild(detailsDiv);

            resultDiv.addEventListener('click', () => {
                addVideoFromSearchResult(videoId, title, channelTitle); // Pass decoded title/artist
                closeModal(MODAL_IDS.Youtube);
            });
            DOM.youtubeSearchResultsBody.appendChild(resultDiv);
        });
    }

    function addVideoFromSearchResult(videoId, title, artist) { // title and artist are pre-decoded
        let currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist) { // No playlist exists, create one
            addNewPlayJockeyPlaylist(); // This sets the new playlist as current
            currentPlaylist = getCurrentPlayJockeyPlaylist();
            if (!currentPlaylist) { // Should not happen if addNewPlayJockeyPlaylist works
                alert("Error: Could not create or find a playlist.");
                return;
            }
        }

        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            DOM.playJockeyLinkInput.value = ''; // Clear input
            return;
        }

        const videoEntry = {
            id: 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7),
            originalUrl: `https://www.youtube.com/watch?v=${videoId}`, // Generic URL
            videoId: videoId,
            title: title, // Store decoded
            artist: artist.replace(/\s-\sTopic$/, '').trim() // Store decoded & cleaned artist
        };

        currentPlaylist.videos.push(videoEntry);
        renderPlayJockeyPlaylist();
        DOM.playJockeyLinkInput.value = ''; // Clear input

        // If no video is playing or it's the first video, start playing it
        if (!ytPlayerInstance || !appData.playJockeyCurrentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true); // Autoplay, manual add
        }
        saveData();
    }


    function addYouTubeLinkToPlayJockey(link) {
        if (!link) {
            alert("Please enter a YouTube link.");
            return;
        }
        const videoId = extractYouTubeVideoId(link);
        if (!videoId) {
            alert("Invalid YouTube link. Please ensure it's a valid YouTube video URL.");
            return;
        }

        let currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist) { // No playlist, create one
            addNewPlayJockeyPlaylist();
            currentPlaylist = getCurrentPlayJockeyPlaylist();
             if (!currentPlaylist) {
                console.error("Failed to create/get playlist after attempting to add a link.");
                return;
            }
        }

        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            DOM.playJockeyLinkInput.value = '';
            return;
        }

        const tempId = 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7);
        const videoEntry = {
            id: tempId,
            originalUrl: link, // Store original link
            videoId: videoId,
            title: "Loading title...", // Placeholder, will be updated
            artist: "" // Placeholder
        };

        currentPlaylist.videos.push(videoEntry);
        renderPlayJockeyPlaylist(); // Show with "Loading title..." initially
        DOM.playJockeyLinkInput.value = '';

        fetchYouTubeTitle(videoEntry, currentPlaylist.id); // Fetch actual title/artist

        if (!ytPlayerInstance || !appData.playJockeyCurrentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true); // Autoplay, manual add
        }
        saveData();
    }


    async function fetchYouTubeTitle(videoEntryToUpdate, playlistId) {
        // videoEntryToUpdate contains placeholders for title/artist
        try {
            // Using a more direct approach if oEmbed is problematic or for simplicity
            // Note: This requires the YouTube Data API v3 if you need more details than oEmbed provides.
            // For just title/author, oEmbed *should* work if endpoint is correct.
            // The provided URL "https://noembed.com/embed?url=https://www.youtube.com/watch?v=${videoEntryToUpdate.videoId}" needs to be a valid oEmbed endpoint.
            // A common public one is like: `https://www.youtube.com/oembed?url=http%3A//youtube.com/watch%3Fv%3D${videoEntryToUpdate.videoId}&format=json`
            // Or use the Google API Client Library if available and API key is set up for Data API.

            // Simplified: If API Key is available, use it for a quick fetch (less ideal than proper oEmbed or client lib)
            let newTitle = "Unknown Title"; // Default
            let newArtist = "";
            
            if (YOUTUBE_API_KEY && YOUTUBE_API_KEY !== "YOUR_YOUTUBE_API_KEY") {
                 const apiUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoEntryToUpdate.videoId}&key=${YOUTUBE_API_KEY}`;
                 const response = await fetch(apiUrl);
                 if (response.ok) {
                     const data = await response.json();
                     if (data.items && data.items.length > 0) {
                         newTitle = decodeHtmlEntities(data.items[0].snippet.title);
                         newArtist = decodeHtmlEntities(data.items[0].snippet.channelTitle).replace(/\s-\sTopic$/, '').trim();
                     } else {
                         console.warn(`No video data found via API for ${videoEntryToUpdate.videoId}`);
                         newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl); // Fallback to URL
                     }
                 } else {
                     console.warn(`Failed to fetch title/author via API for ${videoEntryToUpdate.videoId}. Status: ${response.status}`);
                     newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl); // Fallback to URL
                 }
            } else {
                // Fallback if no API key or if above fetch fails - try to use a generic oEmbed (might be CORS restricted)
                try {
                    const oEmbedUrl = `https://www.youtube.com/oembed?url=http%3A//youtube.com/watch%3Fv%3D${videoEntryToUpdate.videoId}&format=json`;
                    const oEmbedResponse = await fetch(oEmbedUrl, { mode: 'cors' }); // CORS might block this in browser
                    if (oEmbedResponse.ok) {
                        const oEmbedData = await oEmbedResponse.json();
                        newTitle = decodeHtmlEntities(oEmbedData.title);
                        newArtist = decodeHtmlEntities(oEmbedData.author_name).replace(/\s-\sTopic$/, '').trim();
                    } else {
                         newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl); // Fallback
                    }
                } catch (oEmbedError) {
                    console.warn(`oEmbed fetch failed for ${videoEntryToUpdate.videoId}:`, oEmbedError);
                    newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl); // Final fallback
                }
            }


            const targetPlaylist = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const itemInPlaylist = targetPlaylist.videos.find(item => item.id === videoEntryToUpdate.id);
                if (itemInPlaylist) {
                    itemInPlaylist.title = newTitle; // Store decoded
                    itemInPlaylist.artist = newArtist; // Store decoded
                    if (appData.playJockeyCurrentPlaylistId === playlistId) { // If it's the active playlist
                        renderPlayJockeyPlaylist(); // Re-render to show updated title/artist
                    }
                    // Update current video details if this is the one playing
                    if(appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === itemInPlaylist.id) {
                        appData.playJockeyCurrentVideo.title = newTitle;
                        appData.playJockeyCurrentVideo.artist = newArtist;
                    }
                    saveData();
                }
            }
        } catch (error) {
            console.error(`Error in fetchYouTubeTitle for ${videoEntryToUpdate.videoId}:`, error);
             // Fallback: ensure title isn't "Loading title..."
             const targetPlaylist = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const itemInPlaylist = targetPlaylist.videos.find(item => item.id === videoEntryToUpdate.id);
                if (itemInPlaylist && (itemInPlaylist.title === "Loading title..." || !itemInPlaylist.title.trim())) {
                    itemInPlaylist.title = decodeHtmlEntities(itemInPlaylist.originalUrl); // Use decoded URL as fallback
                    if (appData.playJockeyCurrentPlaylistId === playlistId) renderPlayJockeyPlaylist();
                    saveData();
                }
            }
        }
    }


    function renderPlayJockeyTabs() {
        DOM.playJockeyTabsBar.innerHTML = ''; // Clear existing tabs
        appData.playJockeyPlaylists.forEach(playlist => {
            const tab = document.createElement('div');
            tab.className = 'playjockey-tab';
            const displayName = decodeHtmlEntities(playlist.name); // Decode for display
            tab.textContent = displayName;
            tab.title = displayName;
            tab.dataset.playlistId = playlist.id;
            if (playlist.id === appData.playJockeyCurrentPlaylistId) {
                tab.classList.add('active');
            }
            tab.addEventListener('click', () => switchPlayJockeyPlaylist(playlist.id));
            tab.addEventListener('contextmenu', (e) => showPjTabContextMenu(e, playlist.id));
            DOM.playJockeyTabsBar.appendChild(tab);
        });

        const addTabBtn = document.createElement('button');
        addTabBtn.className = 'playjockey-tab playjockey-add-tab-btn xp-button xp-button-small';
        addTabBtn.textContent = '+';
        addTabBtn.title = "New Playlist";
        addTabBtn.addEventListener('click', addNewPlayJockeyPlaylist);
        DOM.playJockeyTabsBar.appendChild(addTabBtn);
    }

    function addNewPlayJockeyPlaylist() {
        let newPlaylistName = "Playlist";
        let counter = 1; // Start counter for unique name
        const existingNames = appData.playJockeyPlaylists.map(p => p.name.toLowerCase());

        // Ensure unique name
        let potentialName = newPlaylistName.toLowerCase();
        while (existingNames.includes(potentialName)) {
            potentialName = `${newPlaylistName} ${counter}`.toLowerCase();
            counter++;
        }
        if (counter > 1) newPlaylistName = `${newPlaylistName} ${counter-1}`;


        const newPlaylistId = 'playlist_' + Date.now() + '_' + Math.random().toString(36).substring(2,9);
        appData.playJockeyPlaylists.push({
            id: newPlaylistId,
            name: newPlaylistName, // Store plain text name
            videos: []
        });
        switchPlayJockeyPlaylist(newPlaylistId); // Switch to the new playlist
        // saveData() is called by switchPlayJockeyPlaylist if ID changes
    }

    function switchPlayJockeyPlaylist(playlistId) {
        if (appData.playJockeyCurrentPlaylistId === playlistId) return; // No change

        appData.playJockeyCurrentPlaylistId = playlistId;
        appData.playJockeyCurrentVideo = null; // Reset current video when switching playlists
        appData.playJockeyRandomHistory = []; // Reset random history for the new playlist

        if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
            ytPlayerInstance.stopVideo(); // Stop any video playing from old playlist
        }
        // Optionally destroy and recreate player if issues occur, or just clear its content
        // DOM.playJockeyPlayer.innerHTML = ''; // Clears the player display area

        renderPlayJockeyTabs(); // Highlight the new active tab
        renderPlayJockeyPlaylist(); // Display videos of the new playlist
        saveData();
    }


    function renderPlayJockeyPlaylist() {
        DOM.playJockeyPlaylist.innerHTML = ''; // Clear existing items
        const currentPlaylist = getCurrentPlayJockeyPlaylist();

        if (!currentPlaylist || currentPlaylist.videos.length === 0) {
            const emptyMsg = document.createElement('div');
            emptyMsg.textContent = "Playlist is empty. Add some YouTube links or search!";
            emptyMsg.style.padding = "10px";
            emptyMsg.style.textAlign = "center";
            emptyMsg.style.color = "#555";
            DOM.playJockeyPlaylist.appendChild(emptyMsg);
            updatePlayingClassInPlaylist(null); // Ensure no "playing" class if empty
            return;
        }

        currentPlaylist.videos.forEach(video => {
            const item = document.createElement('div');
            item.className = 'playjockey-playlist-item';

            let cleanTitle = decodeHtmlEntities(video.title);
            let cleanArtist = decodeHtmlEntities(video.artist);

            // Truncate for display if too long
            let displayTitle = cleanTitle;
            if (cleanTitle === "Loading title..." || cleanTitle === video.originalUrl || !cleanTitle.trim()) {
                const decodedOriginalUrl = decodeHtmlEntities(video.originalUrl);
                displayTitle = decodedOriginalUrl.length > 40 ? decodedOriginalUrl.substring(0, 37) + '...' : decodedOriginalUrl;
            } else {
                 displayTitle = cleanTitle.length > 40 ? cleanTitle.substring(0, 37) + '...' : cleanTitle;
            }

            let itemText = displayTitle;
            let itemTooltip = (cleanTitle !== "Loading title..." && cleanTitle.trim()) ? cleanTitle : decodeHtmlEntities(video.originalUrl);

            if (cleanArtist && cleanArtist.trim() !== "") {
                const artistShort = cleanArtist.length > 20 ? cleanArtist.substring(0, 17) + '...' : cleanArtist;
                itemText = `${displayTitle} - ${artistShort}`;
                itemTooltip = `${itemTooltip} by ${cleanArtist}`;
            }

            item.textContent = itemText;
            item.title = itemTooltip;

            item.dataset.videoId = video.videoId;
            item.dataset.playlistItemId = video.id; // Use internal unique ID
            item.draggable = true;

            if (appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === video.id) {
                item.classList.add('playing');
            }
            item.addEventListener('click', (event) => {
                if (event.target.closest('.context-modal')) return; // Ignore if click is on context menu
                if (item.classList.contains('dragging')) return; // Ignore clicks while dragging

                const clickedItem = event.currentTarget;
                if (clickedItem && clickedItem.dataset.videoId) {
                    playYouTubeVideoById(clickedItem.dataset.videoId, true, true); // Autoplay, manual click
                }
            });
            DOM.playJockeyPlaylist.appendChild(item);
        });
    }

    function playYouTubeVideoById(videoId, autoplayIntent = true, isManualPlay = false) {
        if (!videoId) { console.warn("playYouTubeVideoById called with no videoId"); return; }

        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist) { console.warn("No current playlist to play from"); return; }

        const videoToPlay = currentPlaylist.videos.find(v => v.videoId === videoId);
        if (!videoToPlay) {
            console.warn(`Video with ID ${videoId} not found in current playlist.`);
            appData.playJockeyCurrentVideo = null;
            updatePlayingClassInPlaylist(null);
            if(ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') ytPlayerInstance.stopVideo();
            return;
        }

        // Random history management for manual plays
        if ( isManualPlay && videoToPlay && appData.playJockeyRandomEnabled &&
             appData.playJockeyAutoPlayEnabled && appData.playJockeyRepeatState === "off" &&
             currentPlaylist.videos.length > 0 ) {
            // If all unique videos played, clear history except current, or just add current
            const uniqueVideoIdsInPlaylist = new Set(currentPlaylist.videos.map(v => v.id));
            if (new Set(appData.playJockeyRandomHistory).size >= uniqueVideoIdsInPlaylist.size) {
                 appData.playJockeyRandomHistory = [videoToPlay.id];
            } else if (!appData.playJockeyRandomHistory.includes(videoToPlay.id)) {
                 appData.playJockeyRandomHistory.push(videoToPlay.id);
            }
        }


        appData.playJockeyCurrentVideo = { ...videoToPlay }; // Store a copy
        updatePlayingClassInPlaylist(videoToPlay.id);
        saveData(); // Save current video state

        if (!isYouTubeApiReady) {
            pendingVideoToLoad = { videoId, autoplayIntent };
            console.log("YouTube API not ready, video load queued:", videoId);
            if (typeof YT !== 'undefined' && YT.Player) { onYouTubeIframeAPIReady(); } // Try to init if API seems loaded
            return;
        }

        if (ytPlayerInstance && typeof ytPlayerInstance.loadVideoById === 'function') {
            ytPlayerInstance.loadVideoById({ 'videoId': videoId });
            if (autoplayIntent && typeof ytPlayerInstance.playVideo === 'function') {
                 ytPlayerInstance.playVideo();
            }
        } else { // Create new player instance
            if (DOM.playJockeyPlayer.firstChild && DOM.playJockeyPlayer.firstChild.tagName === 'IFRAME') {
                 DOM.playJockeyPlayer.innerHTML = ''; // Clear old iframe if any
            }
            ytPlayerInstance = new YT.Player('playJockeyPlayer', {
                height: '100%',
                width: '100%',
                videoId: videoId,
                playerVars: {
                    'autoplay': autoplayIntent ? 1 : 0,
                    'controls': 1, 'enablejsapi': 1, 'origin': window.location.origin,
                    'modestbranding': 1, 'rel': 0
                },
                events: {
                    'onReady': (event) => { if (autoplayIntent) event.target.playVideo(); },
                    'onStateChange': onPlayerStateChange
                }
            });
        }
    }

    function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.ENDED && appData.playJockeyAutoPlayEnabled) {
            playNextPjVideo();
        }
    }

    function playNextPjVideo() {
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!ytPlayerInstance || !appData.playJockeyCurrentVideo || !currentPlaylist || currentPlaylist.videos.length === 0) {
            return; // Conditions not met to play next
        }

        let nextVideoItem = null;
        const currentVideoUniqueId = appData.playJockeyCurrentVideo.id; // Use internal unique ID
        const activePlaylistVideos = currentPlaylist.videos;


        if (appData.playJockeyRepeatState === "song") {
            nextVideoItem = activePlaylistVideos.find(item => item.id === currentVideoUniqueId);
        } else if (appData.playJockeyRandomEnabled) {
            if (activePlaylistVideos.length === 0) return;

            if (activePlaylistVideos.length === 1) { // Only one song
                if (appData.playJockeyRepeatState === "off") { // If repeat off and only one song
                    // If already played (in history) and not repeating, don't play again
                    if (appData.playJockeyRandomHistory.includes(currentVideoUniqueId)) return; 
                    nextVideoItem = activePlaylistVideos[0];
                } else { // Repeat playlist or song (effectively same for one song)
                    nextVideoItem = activePlaylistVideos[0];
                }
            } else { // Multiple songs, random enabled
                let eligibleVideos = activePlaylistVideos.filter(
                    video => !appData.playJockeyRandomHistory.includes(video.id) || video.id === currentVideoUniqueId // Allow current to be re-picked if only one eligible and repeat song
                );
                
                // If current video is the only one in eligible and repeat song is on, it's fine
                if (eligibleVideos.length === 1 && eligibleVideos[0].id === currentVideoUniqueId && appData.playJockeyRepeatState === "song") {
                    // Will be picked below
                } else { // filter out current video unless it's the only one left and repeat is not off
                     eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId || appData.playJockeyRepeatState !== "off");
                     eligibleVideos = eligibleVideos.filter(video => !appData.playJockeyRandomHistory.includes(video.id));
                }


                if (eligibleVideos.length === 0) { // All unique videos played
                    if (appData.playJockeyRepeatState === "playlist") {
                        appData.playJockeyRandomHistory = [currentVideoUniqueId]; // Start new cycle, current is "played"
                        eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                        if (eligibleVideos.length === 0 ) { // If current was the only one, pick any other (or itself if only 1 video total)
                             eligibleVideos = [...activePlaylistVideos]; // Full list again
                             if(activePlaylistVideos.length === 1) nextVideoItem = activePlaylistVideos[0];
                        }
                    } else { // Repeat is off, all played, so stop
                        appData.playJockeyRandomHistory = []; // Clear for next manual play
                        return;
                    }
                }
                if (eligibleVideos.length > 0 && !nextVideoItem) { // If nextVideoItem not set by single video logic
                    const randomIndex = Math.floor(Math.random() * eligibleVideos.length);
                    nextVideoItem = eligibleVideos[randomIndex];
                }
            }

            if (nextVideoItem) { // Add to history if not already there
                if (!appData.playJockeyRandomHistory.includes(nextVideoItem.id)) {
                     appData.playJockeyRandomHistory.push(nextVideoItem.id);
                }
                 // Prune history if repeating playlist and history gets too long (e.g., longer than playlist size - 1)
                if (appData.playJockeyRepeatState === "playlist") {
                    const maxHistorySize = Math.max(0, activePlaylistVideos.length -1); // Keep history for non-repeating elements
                    while (appData.playJockeyRandomHistory.length > maxHistorySize && maxHistorySize > 0 && appData.playJockeyRandomHistory.length >= activePlaylistVideos.length) { // Safety for >=
                        appData.playJockeyRandomHistory.shift(); // Remove oldest
                    }
                }
            }

        } else { // Sequential play
            const currentIndex = activePlaylistVideos.findIndex(item => item.id === currentVideoUniqueId);
            if (currentIndex === -1) return; // Current video not found (should not happen)

            let nextIndex = currentIndex + 1;
            if (nextIndex >= activePlaylistVideos.length) { // Reached end of playlist
                if (appData.playJockeyRepeatState === "playlist") {
                    nextIndex = 0; // Loop back to start
                } else { // Repeat off, end of playlist
                    return;
                }
            }
            if (activePlaylistVideos[nextIndex]) {
                nextVideoItem = activePlaylistVideos[nextIndex];
            }
        }

        if (nextVideoItem && nextVideoItem.videoId) {
            playYouTubeVideoById(nextVideoItem.videoId, true, false); // Autoplay, not a direct manual click
        }
    }

    function updatePlayingClassInPlaylist(playingItemId) { // playingItemId is internal unique ID
        const items = DOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item');
        items.forEach(item => {
            if (item.dataset.playlistItemId === playingItemId) {
                item.classList.add('playing');
            } else {
                item.classList.remove('playing');
            }
        });
    }


    function initPlayJockeyContextMenu() {
        DOM.pjContextRenameBtn.addEventListener('click', handlePjContextRename);
        DOM.pjContextRemoveBtn.addEventListener('click', handlePjContextRemove);
    }
    function initPlayJockeyTabContextMenu() {
        DOM.pjTabContextRenameBtn.addEventListener('click', openRenamePlaylistModalFromContextMenu);
        DOM.pjTabContextRemoveBtn.addEventListener('click', openConfirmRemovePlaylistModalFromContextMenu);
    }


    function showPjContextMenu(e) {
        e.preventDefault();
        hidePjContextMenu(); // Hide any existing menus
        hidePjTabContextMenu();

        const clickedPlaylistItem = e.target.closest('.playjockey-playlist-item');
        if (clickedPlaylistItem) {
            DOM.playJockeyContextMenu.style.display = 'block';
            let x = e.clientX;
            let y = e.clientY;
            const menuWidth = DOM.playJockeyContextMenu.offsetWidth;
            const menuHeight = DOM.playJockeyContextMenu.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Adjust position to keep menu within viewport
            if (x + menuWidth > viewportWidth) x = viewportWidth - menuWidth - 5;
            if (y + menuHeight > viewportHeight) y = viewportHeight - menuHeight - 5;
            x = Math.max(0, x); y = Math.max(0, y);


            DOM.playJockeyContextMenu.style.left = `${x}px`;
            DOM.playJockeyContextMenu.style.top = `${y}px`;
            DOM.playJockeyContextMenu.dataset.currentItemId = clickedPlaylistItem.dataset.playlistItemId; // Use internal ID
        }
    }

    function hidePjContextMenu() {
        DOM.playJockeyContextMenu.style.display = 'none';
        delete DOM.playJockeyContextMenu.dataset.currentItemId;
    }

    function showPjTabContextMenu(e, playlistId) {
        e.preventDefault();
        hidePjContextMenu(); // Hide other context menu
        hidePjTabContextMenu();

        DOM.playJockeyTabContextMenu.style.display = 'block';
        let x = e.clientX;
        let y = e.clientY;
        const menuWidth = DOM.playJockeyTabContextMenu.offsetWidth;
        const menuHeight = DOM.playJockeyTabContextMenu.offsetHeight;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        if (x + menuWidth > viewportWidth) x = viewportWidth - menuWidth - 5;
        if (y + menuHeight > viewportHeight) y = viewportHeight - menuHeight - 5;
        x = Math.max(0, x); y = Math.max(0, y);

        DOM.playJockeyTabContextMenu.style.left = `${x}px`;
        DOM.playJockeyTabContextMenu.style.top = `${y}px`;
        DOM.playJockeyTabContextMenu.dataset.playlistId = playlistId;
    }

    function hidePjTabContextMenu() {
        DOM.playJockeyTabContextMenu.style.display = 'none';
        delete DOM.playJockeyTabContextMenu.dataset.playlistId;
    }


    function handlePjContextRename() {
        const itemId = DOM.playJockeyContextMenu.dataset.currentItemId; // Internal ID
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!itemId || !currentPlaylist) {
            hidePjContextMenu();
            return;
        }

        const itemToRename = currentPlaylist.videos.find(video => video.id === itemId);
        if (itemToRename) {
            DOM.trackNewNameInput.value = decodeHtmlEntities(itemToRename.title) || ''; // Populate with decoded
            DOM.trackNewArtistInput.value = decodeHtmlEntities(itemToRename.artist) || ''; // Populate with decoded
            DOM.saveRenamedTrackBtn.dataset.itemId = itemId; // Store internal ID
            openModal(MODAL_IDS.RENAME_TRACK);
            DOM.trackNewNameInput.focus();
        }
        hidePjContextMenu();
    }

    function handlePjContextRemove() {
        const itemId = DOM.playJockeyContextMenu.dataset.currentItemId; // Internal ID
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!itemId || !currentPlaylist) {
            hidePjContextMenu();
            return;
        }
        const itemToRemove = currentPlaylist.videos.find(video => video.id === itemId);
        if (itemToRemove) {
            DOM.confirmRemoveTrackMessage.textContent = `Are you sure you want to remove the track "${decodeHtmlEntities(itemToRemove.title)}"?`;
            DOM.confirmFinalTrackRemoveBtn.dataset.itemId = itemId; // Store internal ID
            openModal(MODAL_IDS.CONFIRM_REMOVE_TRACK);
        }
        hidePjContextMenu();
    }

    function saveRenamedTrack() {
        const itemId = DOM.saveRenamedTrackBtn.dataset.itemId; // Internal ID
        const newName = DOM.trackNewNameInput.value.trim(); // Plain text from input
        const newArtist = DOM.trackNewArtistInput.value.trim(); // Plain text
        const currentPlaylist = getCurrentPlayJockeyPlaylist();

        if (!itemId || !currentPlaylist) {
            alert("Error: Could not find track or playlist.");
            closeModal(MODAL_IDS.RENAME_TRACK);
            return;
        }
        if (!newName) {
            alert("Track name cannot be empty.");
            return;
        }

        const itemToRename = currentPlaylist.videos.find(video => video.id === itemId);
        if (itemToRename) {
            itemToRename.title = newName; // Store plain text
            itemToRename.artist = newArtist; // Store plain text
            // Update current video if it's the one being renamed
            if(appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === itemId) {
                appData.playJockeyCurrentVideo.title = newName;
                appData.playJockeyCurrentVideo.artist = newArtist;
            }
            renderPlayJockeyPlaylist();
            saveData();
        }
        closeModal(MODAL_IDS.RENAME_TRACK);
        delete DOM.saveRenamedTrackBtn.dataset.itemId;
    }

    function executeTrackDeletion() {
        const itemId = DOM.confirmFinalTrackRemoveBtn.dataset.itemId; // Internal ID
        const currentPlaylist = getCurrentPlayJockeyPlaylist();

        if (!itemId || !currentPlaylist) {
            alert("Error: Could not find track or playlist for deletion.");
            closeModal(MODAL_IDS.CONFIRM_REMOVE_TRACK);
            return;
        }

        const itemIndex = currentPlaylist.videos.findIndex(video => video.id === itemId);
        if (itemIndex > -1) {
            const removedItem = currentPlaylist.videos.splice(itemIndex, 1)[0]; // Remove and get item

            // Remove from random history if present
            const historyIndex = appData.playJockeyRandomHistory.indexOf(removedItem.id);
            if (historyIndex > -1) {
                appData.playJockeyRandomHistory.splice(historyIndex, 1);
            }

            if (appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === removedItem.id) { // If deleted video was playing
                if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                    ytPlayerInstance.stopVideo();
                }
                appData.playJockeyCurrentVideo = null; // Clear current video
                if (appData.playJockeyAutoPlayEnabled && currentPlaylist.videos.length > 0) {
                    playNextPjVideo(); // Try to play next if autoplay is on
                } else if (currentPlaylist.videos.length === 0) { // Playlist became empty
                     if (ytPlayerInstance && typeof ytPlayerInstance.destroy === 'function') {
                        // ytPlayerInstance.destroy(); ytPlayerInstance = null; // Optional: fully destroy
                        DOM.playJockeyPlayer.innerHTML = ''; // Clear player display
                    }
                }
            }
            renderPlayJockeyPlaylist();
            saveData();
        }
        closeModal(MODAL_IDS.CONFIRM_REMOVE_TRACK);
        delete DOM.confirmFinalTrackRemoveBtn.dataset.itemId;
    }


    function openRenamePlaylistModalFromContextMenu() {
        const playlistId = DOM.playJockeyTabContextMenu.dataset.playlistId;
        if (!playlistId) return;
        const playlistToRename = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
        if (playlistToRename) {
            DOM.playlistNewNameInput.value = decodeHtmlEntities(playlistToRename.name); // Decode for editing
            DOM.saveRenamedPlaylistBtn.dataset.playlistId = playlistId;
            openModal(MODAL_IDS.RENAME_PLAYLIST);
            DOM.playlistNewNameInput.focus();
        }
        hidePjTabContextMenu();
    }

    function saveRenamedPlaylist() {
        const playlistId = DOM.saveRenamedPlaylistBtn.dataset.playlistId;
        const newName = DOM.playlistNewNameInput.value.trim(); // Plain text from input

        if (!playlistId) { alert("Error: Playlist ID missing."); return;}
        if (!newName) { alert("Playlist name cannot be empty."); return; }

        const playlistToRename = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
        if (playlistToRename) {
            playlistToRename.name = newName; // Store plain text
            renderPlayJockeyTabs();
            saveData();
        }
        closeModal(MODAL_IDS.RENAME_PLAYLIST);
        delete DOM.saveRenamedPlaylistBtn.dataset.playlistId;
    }


    function openConfirmRemovePlaylistModalFromContextMenu() {
        const playlistId = DOM.playJockeyTabContextMenu.dataset.playlistId;
        if (!playlistId) return;
        const playlistToRemove = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
        if (playlistToRemove) {
            DOM.confirmRemovePlaylistMessage.textContent = `Are you sure you want to remove the playlist "${decodeHtmlEntities(playlistToRemove.name)}"? This action cannot be undone.`;
            DOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId = playlistId;
            openModal(MODAL_IDS.CONFIRM_REMOVE_PLAYLIST);
        }
        hidePjTabContextMenu();
    }

    function executePlaylistDeletion() {
        const playlistIdToRemove = DOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId;
        if (!playlistIdToRemove) return;

        const playlistIndex = appData.playJockeyPlaylists.findIndex(pl => pl.id === playlistIdToRemove);
        if (playlistIndex > -1) {
            appData.playJockeyPlaylists.splice(playlistIndex, 1); // Remove playlist

            if (appData.playJockeyCurrentPlaylistId === playlistIdToRemove) { // If deleted playlist was active
                if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                    ytPlayerInstance.stopVideo();
                }
                appData.playJockeyCurrentVideo = null;
                appData.playJockeyRandomHistory = [];

                if (appData.playJockeyPlaylists.length > 0) { // Switch to first available
                    appData.playJockeyCurrentPlaylistId = appData.playJockeyPlaylists[0].id;
                } else { // No playlists left, create a new default one
                    const defaultPlaylistId = 'playlist_default_' + Date.now();
                    appData.playJockeyPlaylists.push({id: defaultPlaylistId, name: "Playlist", videos: []});
                    appData.playJockeyCurrentPlaylistId = defaultPlaylistId;
                }
            }
        }
         // Ensure there's always at least one playlist (even if it was just created above)
        if (appData.playJockeyPlaylists.length === 0) { 
            const defaultPlaylistId = 'playlist_default_' + Date.now();
            appData.playJockeyPlaylists.push({id: defaultPlaylistId, name: "Playlist", videos: []});
            appData.playJockeyCurrentPlaylistId = defaultPlaylistId;
        }

        renderPlayJockeyTabs();
        renderPlayJockeyPlaylist(); // Render the (new) current playlist
        saveData();
        closeModal(MODAL_IDS.CONFIRM_REMOVE_PLAYLIST);
        delete DOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId;
    }


    function handlePjDragStart(e) {
        const target = e.target.closest('.playjockey-playlist-item');
        if (target) {
            pjDraggedItem = target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', target.dataset.playlistItemId); // Use internal ID
            setTimeout(() => { // Apply dragging class slightly after to ensure it's picked up
                target.classList.add('dragging');
            }, 0);
            hidePjContextMenu(); // Hide menu if open
        }
    }

    function handlePjDragEnd(e) {
        if (pjDraggedItem) {
            pjDraggedItem.classList.remove('dragging');
        }
        // Clear all drag-over highlights from playlist items
        DOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
        pjDraggedItem = null;
    }

    function clearPjDragOverHighlights() {
        DOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
    }

    function handlePjDragOver(e) {
        e.preventDefault(); // Necessary to allow drop
        const targetItem = e.target.closest('.playjockey-playlist-item');

        clearPjDragOverHighlights(); // Clear previous highlights

        if (targetItem && pjDraggedItem && targetItem !== pjDraggedItem) {
            const rect = targetItem.getBoundingClientRect();
            const midpointY = rect.top + rect.height / 2;
            if (e.clientY < midpointY) { // Dragging over top half
                targetItem.classList.add('drag-over-target-before');
            } else { // Dragging over bottom half
                targetItem.classList.add('drag-over-target-after');
            }
        }
    }

    function handlePjDragLeave(e) {
        // Only clear if leaving the playlist area or moving to a non-item child
        const relatedTargetIsChildOrSelf = DOM.playJockeyPlaylist.contains(e.relatedTarget);
        if (!relatedTargetIsChildOrSelf) {
             clearPjDragOverHighlights();
        } else { // If moving between items, dragOver on the new item will handle highlights
            const targetItem = e.target.closest('.playjockey-playlist-item');
            if (targetItem) { // Clear from the item being left
                 targetItem.classList.remove('drag-over-target-before', 'drag-over-target-after');
            }
        }
    }


    function handlePjDrop(e) {
        e.preventDefault();
        clearPjDragOverHighlights();
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!pjDraggedItem || !currentPlaylist) return;

        const draggedItemId = e.dataTransfer.getData('text/plain'); // Internal ID
        const targetItemElement = e.target.closest('.playjockey-playlist-item');

        const draggedItemIndex = currentPlaylist.videos.findIndex(item => item.id === draggedItemId);
        if (draggedItemIndex === -1) return; // Dragged item not found in current playlist data

        const itemToMove = currentPlaylist.videos[draggedItemIndex];
        currentPlaylist.videos.splice(draggedItemIndex, 1); // Remove from old position

        let targetIndex = -1; // Default to end of list if no specific target

        if (targetItemElement && targetItemElement.dataset.playlistItemId !== draggedItemId) {
            const targetItemId = targetItemElement.dataset.playlistItemId; // Internal ID
            // Find index in the *current state* of the playlist (after itemToMove was removed)
            targetIndex = currentPlaylist.videos.findIndex(item => item.id === targetItemId);

            if (targetIndex !== -1) { // If target found
                const rect = targetItemElement.getBoundingClientRect();
                const midpointY = rect.top + rect.height / 2;
                if (e.clientY >= midpointY) { // Dropped on bottom half, insert after
                    targetIndex++;
                }
                // If dropped on top half, targetIndex is correct (insert before)
            }
        }


        if (targetIndex !== -1 && targetIndex <= currentPlaylist.videos.length) {
            currentPlaylist.videos.splice(targetIndex, 0, itemToMove);
        } else { // No valid target, or dropped at the end
            currentPlaylist.videos.push(itemToMove);
        }

        renderPlayJockeyPlaylist();
        saveData();
        pjDraggedItem = null; // Reset dragged item
    }


    function togglePlayJockeyAutoPlay() {
        appData.playJockeyAutoPlayEnabled = !appData.playJockeyAutoPlayEnabled;
        updatePlayJockeyAutoPlayButtonState();
        saveData();
    }

    function updatePlayJockeyAutoPlayButtonState() {
        DOM.playJockeyAutoPlayBtn.classList.toggle('autoplay-on', appData.playJockeyAutoPlayEnabled);
        DOM.playJockeyAutoPlayBtn.textContent = `Auto Play: ${appData.playJockeyAutoPlayEnabled ? 'On' : 'Off'}`;
    }

    function togglePlayJockeyRandom() {
        appData.playJockeyRandomEnabled = !appData.playJockeyRandomEnabled;
        appData.playJockeyRandomHistory = []; // Reset history when toggling random
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (appData.playJockeyRandomEnabled && appData.playJockeyCurrentVideo && currentPlaylist && currentPlaylist.videos.length > 0) {
            // Add current video to history if random is turned on and a video is playing
             if (currentPlaylist.videos.length > 1 || appData.playJockeyRepeatState !== "off") {
                 appData.playJockeyRandomHistory.push(appData.playJockeyCurrentVideo.id);
            }
        }
        updatePlayJockeyRandomButtonState();
        saveData();
    }

    function updatePlayJockeyRandomButtonState() {
        DOM.playJockeyRandomBtn.classList.toggle('random-on', appData.playJockeyRandomEnabled);
        DOM.playJockeyRandomBtn.textContent = `Random: ${appData.playJockeyRandomEnabled ? 'On' : 'Off'}`;
    }

    function cyclePlayJockeyRepeat() {
        const states = ["off", "playlist", "song"];
        let currentIndex = states.indexOf(appData.playJockeyRepeatState);
        currentIndex = (currentIndex + 1) % states.length;
        appData.playJockeyRepeatState = states[currentIndex];
        
        appData.playJockeyRandomHistory = []; // Reset history on repeat change
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (appData.playJockeyRandomEnabled && appData.playJockeyCurrentVideo && currentPlaylist && currentPlaylist.videos.length > 0) {
             if (currentPlaylist.videos.length > 1 || appData.playJockeyRepeatState !== "off") {
                 appData.playJockeyRandomHistory.push(appData.playJockeyCurrentVideo.id);
            }
        }
        updatePlayJockeyRepeatButtonState();
        saveData();
    }

    function updatePlayJockeyRepeatButtonState() {
        DOM.playJockeyRepeatBtn.classList.remove('repeat-on'); // Remove class first
        switch (appData.playJockeyRepeatState) {
            case "off":
                DOM.playJockeyRepeatBtn.textContent = 'Repeat: Off';
                break;
            case "playlist":
                DOM.playJockeyRepeatBtn.textContent = 'Repeat: List';
                DOM.playJockeyRepeatBtn.classList.add('repeat-on');
                break;
            case "song":
                DOM.playJockeyRepeatBtn.textContent = 'Repeat: One';
                DOM.playJockeyRepeatBtn.classList.add('repeat-on');
                break;
        }
    }


    function openModal(modalId) {
        const modal = getById(modalId);
        if (modal) {
            modal.style.display = 'flex'; // Use flex for centering defined in CSS
        } else {
            console.error(`Modal with ID "${modalId}" not found.`);
        }
    }

    function closeModal(modalId) {
        const modal = getById(modalId);
         if (modal) {
            modal.style.display = 'none';
        } else {
            console.error(`Modal with ID "${modalId}" not found for closing.`);
        }
    }

    document.addEventListener('DOMContentLoaded', init);

</script>
</body>
</html>