<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life XP</title>
    <style>
        body {
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #3A6EA5;
            background-image: url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png');
            background-size: cover;
            background-position: 0% 0%;
            background-repeat: no-repeat;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }

        .xp-window {
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            min-height: 30px;
            display: flex;
            flex-direction: column;
            position: absolute;
            overflow: hidden;
        }

        .xp-window.disable-selection,
        .xp-window.disable-selection * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #000;
            cursor: grab;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
            user-select: none;
        }
        .title-bar:active {
            cursor: grabbing;
        }

        .title-bar-text {
            margin-left: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .title-bar-controls button {
            background-color: #ECE9D8;
            border: 1px solid #000;
            width: 22px;
            height: 18px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-size: 12px;
            line-height: 16px;
            margin-left: 2px;
            box-shadow: 1px 1px 0px #FFF inset, -1px -1px 0px #808080 inset;
            padding: 0;
            text-align: center;
            cursor: default;
        }
        .title-bar-controls button:active:not(:disabled) {
            box-shadow: -1px -1px 0px #FFF inset, 1px 1px 0px #808080 inset;
        }
        .title-bar-controls button:disabled {
            color: #7F7F7F;
            cursor: default;
            opacity: 0.7;
        }

        .window-body {
            padding: 15px;
            flex-grow: 1;
            overflow-y: auto;
            opacity: 1;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out, opacity 0.2s ease-out;
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
        }

        #xpMainWindow .window-body {
             padding: 15px;
             overflow-y: auto;
        }

        #playJockeyWindow .window-body {
            padding: 0;
            display: flex;
        }


        .xp-window.minimized .window-body {
            max-height: 0 !important;
            padding-top: 0 !important;
            padding-bottom: 0 !important;
            opacity: 0 !important;
            overflow: hidden !important;
            border-top: none !important;
        }
        .xp-window.minimized {
            min-height: 28px !important;
            height: 28px !important;
            overflow: hidden;
        }

        .controls-bar {
            display: flex;
            margin-bottom: 15px;
            padding: 8px;
            border: 1px solid #ACA899;
            background-color: #F0F0F0;
        }

        .controls-bar.layout-single-row {
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
        }
        .controls-bar.layout-single-row > div {
             margin: 2px 5px;
             flex-shrink: 0;
        }

        .controls-bar.layout-multi-row {
            flex-direction: column;
            align-items: stretch;
        }
        .controls-bar.layout-multi-row > div {
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            padding: 5px 0;
        }
        .controls-bar.layout-multi-row > div:last-child {
            margin-bottom: 0;
        }
        .controls-bar.layout-multi-row .controls-group {
             text-align: center;
        }

        .xp-button {
            background-color: #ECE9D8;
            border: 1px outset #7F7F7F;
            padding: 5px 12px;
            min-width: 75px;
            text-align: center;
            cursor: pointer;
            margin: 2px;
        }
        .xp-button:active {
            border-style: inset;
        }
        .xp-button:hover {
            border-color: #005CFE;
        }
        .xp-button-small {
            padding: 2px 5px;
            font-size: 10px;
            min-width: auto;
            margin: 0 2px;
        }


        .week-navigation {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }
        .week-navigation button {
            margin: 0 3px;
        }

        .controls-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0 10px;
            text-align: center;
        }
        #currentWeekDisplay {
            font-weight: bold;
        }
        #weekCountDisplay {
            font-size: 0.9em;
            color: #333;
        }

        .global-actions {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            table-layout: fixed;
        }

        th, td {
            border: 1px solid #ACA899;
            padding: 8px;
            text-align: left;
            vertical-align: top;
            word-wrap: break-word;
        }

        th {
            background-color: #D4D0C8;
            text-align: center;
        }

        td.area-name-cell {
            font-weight: bold;
            width: 180px;
        }
        .area-stats {
            font-size: 0.9em;
            margin-top: 5px;
            color: #333;
        }
        .area-stats span { display: flex; }
        .xp-bar-container {
            width: 100%;
            height: 12px;
            background-color: #BDBDBD;
            border: 1px solid #7F7F7F;
            margin-top: 3px;
            position: relative;
            border-radius: 2px;
            overflow: hidden;
        }
        .xp-bar {
            height: 100%;
            background-color: #008000;
            transition: width 0.3s ease;
            border-radius: 1px;
        }
        .xp-bar-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            line-height: 12px;
            color: white;
            text-shadow: 1px 1px 0px black;
            font-weight: bold;
            z-index: 1;
        }

        .achievement-item {
            background-color: #FFF;
            border: 1px solid #DDD;
            padding: 8px;
            margin-bottom: 4px;
            font-size: 0.9em;
            border-radius: 3px;
            word-wrap: break-word;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .achievement-content {
            width: 100%;
            text-align: center;
            margin-bottom: 8px;
        }

        .achievement-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin-left: auto;
            margin-right: auto;
            margin-top: 0px;
            border-radius: 2px;
        }

        .achievement-item-actions {
            display: flex;
            gap: 3px;
        }

        .achievement-add-btn-cell {
            display: block;
            width: 99.5%;
            box-sizing: border-box;
            margin-top: 5px;
        }


        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #ECE9D8;
            margin: auto;
            padding: 0;
            border: 1px solid #000;
            width: 80%;
            max-width: 500px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
            display: flex;
            flex-direction: column;
        }

        .modal-title-bar {
            background: linear-gradient(to bottom, #005CFE, #0039A9);
            color: white;
            padding: 5px 8px;
            font-weight: bold;
            border-bottom: 1px solid #000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 28px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        .modal-title-bar .close-button {
            color: white;
            font-size: 16px;
            font-family: "Marlett", "Webdings", sans-serif;
            font-weight: normal;
            background: #E04343;
            border: 1px outset white;
            width: 22px;
            height: 18px;
            text-align: center;
            line-height: 16px;
            padding: 0;
            cursor: pointer;
        }
        .modal-title-bar .close-button:hover,
        .modal-title-bar .close-button:focus {
            background: #FF6363;
            text-decoration: none;
        }
         .modal-title-bar .close-button:active {
            border-style: inset;
        }
        .modal-body {
            padding: 15px;
            overflow-y: auto;
            flex-grow: 1;
        }
        .modal-body p {
            margin-top: 0;
            margin-bottom: 10px;
        }
        .modal-body label {
            display: block;
            margin-bottom: 5px;
            margin-top: 12px;
        }
        .modal-body input[type="text"],
        .modal-body input[type="number"],
        .modal-body textarea,
        .modal-body select {
            width: calc(100% - 12px);
            padding: 5px;
            margin-bottom: 10px;
            border: 1px solid #ACA899;
            box-sizing: border-box;
        }
        .modal-body input[type="file"] {
            margin-bottom: 5px;
        }
         .modal-body hr {
            border: 0;
            height: 1px;
            background: #ACA899;
            margin: 20px 0;
        }
        .modal-footer {
            padding: 10px 15px;
            text-align: right;
            background-color: #F0F0F0;
            border-top: 1px solid #ACA899;
            flex-shrink: 0;
        }

        @keyframes fadeIn {
            from {opacity: 0; transform: scale(0.9);}
            to {opacity: 1; transform: scale(1);}
        }

        .quest-item {
            padding: 8px;
            border: 1px solid #ACA899;
            margin-bottom: 8px;
            background-color: #FFF;
            border-radius: 3px;
            position: relative;
        }
        .quest-item label {
            margin-left: 8px;
        }
        .quest-item.completed {
            background-color: #DFF0D8;
            text-decoration: line-through;
            color: #508a50;
        }
        .quest-item.completed .quest-title {
             color: #006400;
        }
        .quest-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #0039A9;
        }
        .quest-details {
            font-size: 0.95em;
            margin-bottom: 3px;
        }
        .quest-progress {
            font-size: 0.85em;
            color: #555;
            margin-top: 3px;
            margin-bottom: 25px;
        }
        .quest-actions {
            position: absolute;
            bottom: 5px;
            right: 5px;
        }


        .area-name-wrapper {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .delete-area-btn {
            padding: 1px 6px;
            min-width: auto;
            font-size: 10px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-weight: bold;
            margin-left: 10px;
            background-color: #E04343;
            color: white;
            border: 1px outset white;
            line-height: 1.2;
            cursor: pointer;
        }
        .delete-area-btn:hover {
            background-color: #FF6363;
        }
        .delete-area-btn:active {
            border-style: inset;
        }

        .resize-handle {
            width: 12px;
            height: 12px;
            position: absolute;
            right: 0;
            bottom: 0;
            cursor: nwse-resize;
            z-index: 10;
            box-sizing: border-box;
            opacity: 0.6;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23666' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: center center;
        }

        .resize-handle:hover {
            opacity: 1;
            background-image: url("data:image/svg+xml,%3Csvg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10L10 7' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3Cpath d='M3 10L10 3' stroke='%23333' stroke-width='1.2' stroke-linecap='round'/%3E%3C/svg%3E");
        }

        .xp-window.true-maximized .resize-handle {
            display: none;
        }

        .color-swatch-item {
            box-sizing: border-box;
            transition: transform 0.1s ease-out;
        }
        .color-swatch-item:hover {
            outline: 2px solid #005CFE;
            outline-offset: 1px;
            transform: scale(1.1);
        }

        .desktop-icon {
            position: absolute;
            width: 90px;
            height: 100px;
            text-align: center;
            color: white;
            text-shadow: 1px 1px 1px black;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 10px;
            box-sizing: border-box;
            z-index: 5;
        }
        .desktop-icon:active {
            cursor: grabbing;
        }
        .desktop-icon .icon-image {
            font-size: 48px;
            line-height: 1;
            margin-bottom: 8px;
        }
        .desktop-icon .icon-label {
            font-size: 12px;
            font-weight: normal;
            word-wrap: break-word;
            max-width: 100%;
        }

        /* PlayJockey Specific Styles */
        .playjockey-body-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background-color: #D4D0C8;
            padding: 5px;
            box-sizing: border-box;
        }

        .playjockey-input-bar {
            display: flex;
            margin-bottom: 5px;
            padding: 5px;
            background-color: #C0C0C0;
            border: 1px outset #FFFFFF;
            border-right-color: #808080;
            border-bottom-color: #808080;
            flex-shrink: 0;
        }

        #playJockeyLinkInput {
            flex-grow: 1;
            margin-right: 5px;
            border: 1px inset #7F7F7F;
            padding: 4px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #FFFFFF;
        }

        #playJockeyAddBtn {
            min-width: 60px;
            padding: 3px 8px;
            font-size: 11px;
        }

        .playjockey-player-area {
            flex-grow: 1;
            margin-bottom: 5px;
            border: 2px inset #808080;
            background-color: black;
            min-height: 150px;
            overflow: hidden;
        }

        #playJockeyPlayer {
            width: 100%;
            height: 100%;
        }

        .playjockey-tabs-bar {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            background-color: #C0C0C0;
            padding: 3px 3px 0 3px;
            border-bottom: 1px solid #808080;
            flex-shrink: 0;
            gap: 2px;
        }
        .playjockey-tab {
            padding: 6px 10px;
            border: 1px inset #FFFFFF;
            border-bottom: none;
            background-color: #D4D0C8;
            cursor: default;
            font-size: 10px;
            white-space: nowrap;
            border-top-left-radius: 3px;
            border-top-right-radius: 3px;
        }
        .playjockey-tab:hover {
            background-color: #E0E0E0;
        }
        .playjockey-tab.active {
            background-color: #F0F0F0;
            border-style: inset;
            border-bottom: 1px solid #F0F0F0;
            position: relative;
            z-index: 1;
            font-weight: bold;
        }
        .playjockey-add-tab-btn {
            padding: 6px 8px;
            margin-left: 0px;
            font-weight: bold;
        }


        .playjockey-controls-bar {
            display: flex;
            justify-content: center;
            padding: 5px 0px 5px 0px;
            flex-shrink: 0;
            gap: 5px;
            border-top: 1px solid #ACA899;
            background-color: #F0F0F0;
        }
        #playJockeyRandomBtn,
        #playJockeyAutoPlayBtn,
        #playJockeyRepeatBtn {
            min-width: 90px;
            padding: 3px 8px;
            font-size: 11px;
        }
        #playJockeyRandomBtn.random-on,
        #playJockeyAutoPlayBtn.autoplay-on,
        #playJockeyRepeatBtn.repeat-on {
            border-style: inset;
            font-weight: bold;
        }


        .playjockey-playlist-area {
            height: 100px;
            overflow-y: auto;
            border: 1px inset #7F7F7F;
            background-color: #FFFFFF;
            padding: 3px;
            flex-shrink: 0;
            border-top: none;
            position: relative;
            z-index: 0;
        }

        .playjockey-playlist-item {
            padding: 4px 6px;
            cursor: grab;
            border-bottom: 1px solid #ECE9D8;
            font-size: 10px;
            color: #000080;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            user-select: none;
        }
        .playjockey-playlist-item:hover {
            background-color: #000080;
            color: white;
        }
        .playjockey-playlist-item.playing {
            background-color: #005CFE;
            color: white;
            font-weight: bold;
        }
        .playjockey-playlist-item:last-child {
            border-bottom: none;
        }

        .playjockey-playlist-item.dragging {
            opacity: 0.5;
            background-color: #AED6F1;
        }
        .playjockey-playlist-item.drag-over-target-before {
            border-top: 2px dashed #005CFE;
        }
        .playjockey-playlist-item.drag-over-target-after {
            border-bottom: 2px dashed #005CFE;
        }


        .context-modal {
            display: none;
            position: fixed;
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            z-index: 2000;
            padding: 3px 0;
            min-width: 120px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
        }
        .context-modal-item {
            padding: 5px 12px;
            cursor: default;
            color: black;
        }
        .context-modal-item:hover {
            background-color: #005CFE;
            color: white;
        }

        /* Youtube Modal Specific Styles */
        #youtubeSearchResultsBody {
            max-height: 400px;
            overflow-y: auto;
        }

        .Youtube-result-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #ACA899;
            cursor: pointer;
            background-color: #FFFFFF;
        }
        .Youtube-result-item:hover {
            background-color: #E0E0E0;
        }
        .Youtube-result-item:last-child {
            border-bottom: none;
        }

        .Youtube-result-item img {
            width: 120px;
            height: 90px;
            margin-right: 10px;
            border: 1px solid #ACA899;
            object-fit: cover;
        }

        .Youtube-result-item-details {
            display: flex;
            flex-direction: column;
        }

        .Youtube-result-item-title {
            font-weight: bold;
            color: #0039A9;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .Youtube-result-item-channel {
            font-size: 10px;
            color: #555;
        }
        #youtubeSearchStatus {
            padding: 15px;
            font-size: 12px;
        }

        /* Gemini Chat Specific Styles */
        .gemini-chat-body-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background-color: #ECE9D8;
            padding: 0;
            box-sizing: border-box;
        }

        .gemini-chat-controls-bar {
            display: flex;
            justify-content: flex-end;
            padding: 3px 5px 0px 5px;
            background-color: #ECE9D8;
            flex-shrink: 0;
        }

        #geminiChatClearHistoryBtn {
            min-width: auto;
            padding: 2px 8px;
            margin-bottom: 3px;
        }

        .gemini-chat-display-area {
            flex-grow: 1;
            border: 1px inset #7F7F7F;
            background-color: #FFFFFF;
            padding: 8px;
            margin: 5px;
            margin-top: 0;
            overflow-y: auto;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            line-height: 1.4;
        }

        .gemini-chat-message {
            margin-bottom: 8px;
            padding: 6px 8px;
            border-radius: 3px;
            word-wrap: break-word;
            white-space: pre-wrap;
            max-width: 80%;
            box-sizing: border-box;
        }

        .gemini-chat-message .message-sender {
            font-weight: bold;
            display: block;
            margin-bottom: 3px;
            font-size: 10px;
        }
        .gemini-chat-message .message-content {
        }
         .gemini-chat-message .message-timestamp {
            font-size: 9px;
            color: #555;
            display: block;
            margin-top: 4px;
            text-align: inherit;
        }


        .gemini-chat-message.user-message {
            background-color: #E1EBF7;
            text-align: left;
            margin-left: auto;
            border: 1px solid #B4C9E2;
        }
        .gemini-chat-message.user-message .message-sender {
            color: #0039A9;
        }

        .gemini-chat-message.gemini-message {
            background-color: #F0F0F0;
            text-align: left;
            margin-right: auto;
            border: 1px solid #DCDCDC;
        }
        .gemini-chat-message.gemini-message .message-sender {
            color: #006400;
        }
        .gemini-chat-message.gemini-message.error-message {
            background-color: #FFDDDD;
            color: #D8000C;
            border: 1px solid #FFB8B8;
        }
        .gemini-chat-message.gemini-message.error-message .message-sender {
            color: #990000;
        }


        .gemini-chat-input-area {
            display: flex;
            flex-shrink: 0;
            padding: 8px 5px 5px 5px;
            border-top: 1px solid #ACA899;
            background-color: #ECE9D8;
        }

        #geminiChatPromptInput {
            flex-grow: 1;
            margin-right: 5px;
            border: 1px inset #7F7F7F;
            padding: 6px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 11px;
            background-color: #FFFFFF;
            resize: none;
            height: 44px;
            box-sizing: border-box;
        }

        #geminiChatSendBtn {
            min-width: 60px;
            padding: 3px 8px;
            font-size: 11px;
            height: 44px;
            box-sizing: border-box;
        }

        /* Pixel App Specific Styles */
        #pixelWindow .window-body {
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
        }
        .pixel-menu-bar {
            background-color: #ECE9D8;
            padding: 2px 3px;
            border-bottom: 1px solid #ACA899;
            display: flex;
            flex-shrink: 0;
            user-select: none;
            color: #000000;
        }
        .pixel-menu-item {
            padding: 3px 8px;
            cursor: default;
            position: relative;
            color: inherit;
        }
        .pixel-menu-item:hover {
            background-color: #005CFE;
            color: white;
        }
        .pixel-dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background-color: #ECE9D8;
            border: 1px solid #000;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            z-index: 100;
            padding: 2px 0;
            color: #000000;
        }
        .pixel-dropdown-item {
            padding: 4px 12px 4px 25px;
            cursor: default;
            white-space: nowrap;
            color: inherit;
        }
        .pixel-dropdown-item:hover:not(.disabled) {
            background-color: #005CFE;
            color: white;
        }
        .pixel-menu-item:focus-within .pixel-dropdown-content,
        .pixel-menu-item.open .pixel-dropdown-content {
            display: block;
        }

        .pixel-toolbar {
            display: flex;
            align-items: center;
            padding: 4px;
            border-bottom: 1px solid #000000;
            background-color: #ECE9D8;
            flex-shrink: 0;
            gap: 5px;
        }
        .pixel-tool-button {
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 22px;
            border: 1px outset #7F7F7F;
            background-color: #ECE9D8;
            min-width: 30px;
            height: 30px;
            padding: 0;
            cursor: default;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .pixel-tool-button.active {
            border-style: inset;
            background-color: #D4D0C8;
        }
        .pixel-tool-button:active:not(.active) {
            border-style: inset;
        }
        .pixel-color-picker {
            width: 30px;
            height: 30px;
            border: 1px solid #7F7F7F;
            padding: 0;
            background-color: #ECE9D8;
            cursor: pointer;
        }
        .pixel-size-input {
            width: 30px;
            height: 24px;
            border: 1px inset #7F7F7F;
            padding: 2px 4px;
            font-family: "Tahoma", "Geneva", sans-serif;
            font-size: 14px;
            text-align: center;
            background-color: #FFFFFF;
            margin-right: 3px;
            box-sizing: border-box;
        }
        /* Hide spinner buttons for number input in WebKit/Blink */
        .pixel-size-input::-webkit-outer-spin-button,
        .pixel-size-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        /* Hide spinner buttons for number input in Firefox */
        .pixel-size-input[type=number] {
            -moz-appearance: textfield;
        }

        .pixel-canvas-container {
            flex-grow: 1;
            background-color: #808080;
            padding: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
        }
        #pixelCanvas {
            background-color: white;
            border: 1px solid #000;
            cursor: default;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }


    </style>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-remote-config.js"></script>

</head>
<body>

    <div class="desktop-icon" id="textEditorIcon" data-window-id="textEditorWindow">
        <div class="icon-image">🗒️</div>
        <div class="icon-label">Jotter</div>
    </div>
    <div class="desktop-icon" id="trackerIcon" data-window-id="xpMainWindow">
        <div class="icon-image">✅</div>
        <div class="icon-label">XP Tracker</div>
    </div>
    <div class="desktop-icon" id="playJockeyIcon" data-window-id="playJockeyWindow">
        <div class="icon-image">⏯️</div>
        <div class="icon-label">Play Jockey</div>
    </div>
    <div class="desktop-icon" id="geminiChatIcon" data-window-id="geminiChatWindow">
        <div class="icon-image">✨</div>
        <div class="icon-label">Gemini Chat</div>
    </div>
    <div class="desktop-icon" id="pixelIcon" data-window-id="pixelWindow">
        <div class="icon-image">🎨</div>
        <div class="icon-label">Pixel</div>
    </div>


    <div class="xp-window" id="xpMainWindow">
        <div class="title-bar" id="xpMainWindowTitleBar">
            <span class="title-bar-text">XP Tracker</span>
            <div class="title-bar-controls">
                <button id="xpMainWindowMinimizeBtn" title="Minimize">0</button>
                <button id="xpMainWindowMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="xpMainWindowCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body">
            <div class="controls-bar" id="controlsBar">
                <div class="week-navigation">
                    <button id="prevWeekBtn" class="xp-button">< Prev Week</button>
                    <button id="thisWeekBtn" class="xp-button">This Week</button>
                    <button id="nextWeekBtn" class="xp-button">Next Week ></button>
                </div>
                <div class="controls-group">
                    <span id="currentWeekDisplay">Week X</span>
                    <span id="weekCountDisplay">Year Week: XX</span>
                </div>
                <div class="global-actions">
                    <button id="toggleViewBtn" class="xp-button">Day View</button>
                    <button id="showQuestsBtn" class="xp-button">Weekly Quests</button>
                    <button id="addAreaBtn" class="xp-button">New Area</button>
                </div>
            </div>
            <table id="gridTable">
                <thead>
                    <tr id="weekdayHeaders">
                        <th>Area</th>
                    </tr>
                </thead>
                <tbody id="gridBody">
                </tbody>
            </table>
        </div>
        <div class="resize-handle" id="xpMainWindowResizeHandle"></div>
    </div>

    <div class="xp-window" id="textEditorWindow">
        <div class="title-bar" id="textEditorWindowTitleBar">
            <span class="title-bar-text">Jotter</span>
            <div class="title-bar-controls">
                <button id="textEditorMinimizeBtn" title="Minimize">0</button>
                <button id="textEditorMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="textEditorCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="textEditorWindowBody">
            <iframe id="textEditorFrame" style="width: 100%; height: 100%; border: none;"></iframe>
        </div>
        <div class="resize-handle" id="textEditorResizeHandle"></div>
    </div>

    <div class="xp-window" id="playJockeyWindow">
        <div class="title-bar" id="playJockeyTitleBar">
            <span class="title-bar-text">Play Jockey</span>
            <div class="title-bar-controls">
                <button id="playJockeyMinimizeBtn" title="Minimize">0</button>
                <button id="playJockeyMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="playJockeyCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="playJockeyWindowBody">
            <div class="playjockey-body-container">
                <div class="playjockey-input-bar">
                    <input type="text" id="playJockeyLinkInput" placeholder="Paste YouTube Link or Search Query">
                    <button id="playJockeyAddBtn" class="xp-button">Add</button>
                </div>
                <div class="playjockey-player-area">
                    <div id="playJockeyPlayer"></div>
                </div>
                 <div class="playjockey-tabs-bar" id="playJockeyTabsBar">
                    </div>
                <div class="playjockey-playlist-area" id="playJockeyPlaylist">
                    </div>
                <div class="playjockey-controls-bar">
                    <button id="playJockeyRandomBtn" class="xp-button">Random: Off</button>
                    <button id="playJockeyAutoPlayBtn" class="xp-button">Auto Play: On</button>
                    <button id="playJockeyRepeatBtn" class="xp-button">Repeat: Off</button>
                </div>
            </div>
        </div>
        <div class="resize-handle" id="playJockeyResizeHandle"></div>
    </div>

    <div class="xp-window" id="geminiChatWindow">
        <div class="title-bar" id="geminiChatWindowTitleBar">
            <span class="title-bar-text">Gemini Chat</span>
            <div class="title-bar-controls">
                <button id="geminiChatMinimizeBtn" title="Minimize">0</button>
                <button id="geminiChatMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="geminiChatCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="geminiChatWindowBody">
            <div class="gemini-chat-body-container">
                <div class="gemini-chat-controls-bar">
                    <button id="geminiChatClearHistoryBtn" class="xp-button xp-button-small">Clear History</button>
                </div>
                <div class="gemini-chat-display-area" id="geminiChatDisplayArea">
                    </div>
                <div class="gemini-chat-input-area">
                    <textarea id="geminiChatPromptInput" placeholder="Type your message to Gemini..." rows="2"></textarea>
                    <button id="geminiChatSendBtn" class="xp-button">Send</button>
                </div>
            </div>
        </div>
        <div class="resize-handle" id="geminiChatResizeHandle"></div>
    </div>

    <div class="xp-window" id="pixelWindow">
        <div class="title-bar" id="pixelWindowTitleBar">
            <span class="title-bar-text">Pixel</span>
            <div class="title-bar-controls">
                <button id="pixelMinimizeBtn" title="Minimize">0</button>
                <button id="pixelMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="pixelCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="pixelWindowBody">
            <div class="pixel-menu-bar" id="pixelMenuBar">
                <div class="pixel-menu-item" tabindex="0">
                    File
                    <div class="pixel-dropdown-content">
                        <div class="pixel-dropdown-item" id="pixelFileSave">Save</div>
                        <div class="pixel-dropdown-item" id="pixelFileClearCanvas">Clear canvas</div>
                        <div class="pixel-dropdown-item" id="pixelFileCanvasSize">Canvas size...</div>
                    </div>
                </div>
            </div>
            <div class="pixel-toolbar">
                <input type="number" class="pixel-size-input" id="pixelSizeInput" value="2" min="1" max="50" title="Pencil/Eraser Size">
                <button class="pixel-tool-button active" id="pixelPencilTool" title="Pencil">✏️</button>
                <button class="pixel-tool-button" id="pixelEraserTool" title="Eraser">🧼</button>
                <button class="pixel-tool-button" id="pixelBucketTool" title="Paint Bucket">🫗</button>
                <input type="color" class="pixel-color-picker" id="pixelColorPicker" value="#000000" title="Color Picker">
            </div>
            <div class="pixel-canvas-container">
                <canvas id="pixelCanvas"></canvas>
            </div>
        </div>
        <div class="resize-handle" id="pixelResizeHandle"></div>
    </div>


    <div id="newAreaModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span id="newAreaModalTitle">Create New Area</span>
                <span class="close-button" data-modal-id="newAreaModal">r</span>
            </div>
            <div class="modal-body">
                <label for="newAreaName">Area Name:</label>
                <input type="text" id="newAreaName" placeholder="e.g., Fitness, Learning, Work">
            </div>
            <div class="modal-footer">
                <button id="saveNewAreaBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="newAreaModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="addEditAchievementModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span id="addEditAchievementModalTitle">Add Achievement</span>
                <span class="close-button" data-modal-id="addEditAchievementModal">r</span>
            </div>
            <div class="modal-body">
                <input type="hidden" id="achievementAreaName">
                <input type="hidden" id="achievementDayIndex">
                <input type="hidden" id="editingAchievementKey">
                <input type="hidden" id="editingAchievementId">
                <label>Type:</label>
                <input type="radio" name="achievementType" value="text" id="typeText" checked> Text
                <input type="radio" name="achievementType" value="image" id="typeImage"> Image
                <br><br>
                <div id="textInputDiv">
                    <label for="achievementText">Description:</label>
                    <textarea id="achievementText" rows="3"></textarea>
                </div>
                <div id="imageInputDiv" style="display:none;">
                    <label for="achievementImage">Upload Image:</label>
                    <input type="file" id="achievementImage" accept="image/*">
                    <p><small>Current image will be kept if no new image is selected during edit.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveAchievementBtn" class="xp-button">Save Achievement</button>
                <button class="xp-button" data-modal-id="addEditAchievementModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="questsModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Weekly Quests</span>
                <span class="close-button" data-modal-id="questsModal">r</span>
            </div>
            <div class="modal-body" id="questsList">
                </div>
            <div class="modal-footer">
                <button id="addQuestBtn" class="xp-button">Create New Quest</button>
                <button class="xp-button" data-modal-id="questsModal">Close</button>
            </div>
        </div>
    </div>
    <div id="confirmRemoveAreaModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Deletion</span>
                <span class="close-button" data-modal-id="confirmRemoveAreaModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemoveAreaMessage">Are you sure?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmRemoveBtn" class="xp-button">Confirm</button>
                <button class="xp-button" data-modal-id="confirmRemoveAreaModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmDeleteAchievementModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Achievement Deletion</span>
                <span class="close-button" data-modal-id="confirmDeleteAchievementModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this achievement? This will deduct its XP if it was awarded.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmDeleteAchievementBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmDeleteAchievementModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="createQuestModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Create New Quest</span>
                <span class="close-button" data-modal-id="createQuestModal">r</span>
            </div>
            <div class="modal-body">
                <label for="newQuestAreaName">Area:</label>
                <select id="newQuestAreaName"></select>
                <label for="newQuestDescription">Description:</label>
                <textarea id="newQuestDescription" rows="2" placeholder="e.g., Read 2 chapters"></textarea>
                <label for="newQuestTargetXP">Target XP to Earn in Area for Quest:</label>
                <input type="number" id="newQuestTargetXP" min="1" value="30">
                <label for="newQuestRewardXP">Quest Reward XP:</label>
                <input type="number" id="newQuestRewardXP" min="1" value="50">
            </div>
            <div class="modal-footer">
                <button id="saveNewQuestBtn" class="xp-button">Save Quest</button>
                <button class="xp-button" data-modal-id="createQuestModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmRefreshQuestModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Quest Refresh</span>
                <span class="close-button" data-modal-id="confirmRefreshQuestModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to refresh this quest? Current progress on this quest will be lost and a new quest will be generated.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmRefreshQuestBtn" class="xp-button">Refresh Quest</button>
                <button class="xp-button" data-modal-id="confirmRefreshQuestModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="changeBgImageModal" class="modal">
        <div class="modal-content" style="max-width: 550px;"> <div class="modal-title-bar">
                <span>Change Background</span>
                <span class="close-button" data-modal-id="changeBgImageModal">r</span>
            </div>
            <div class="modal-body">
                <p>Choose a background type for the application:</p>
                <div>
                    <label for="newBgImageInput">1. Upload image file:</label>
                    <input type="file" id="newBgImageInput" accept="image/*">
                     <p><small>Max 5MB recommended for file uploads due to browser storage limits.</small></p>
                    <button id="uploadBgImageBtn" class="xp-button" style="margin-top: 5px;">Upload File & Apply</button>
                </div>
                <hr>
                <div>
                    <label for="bgImageUrlInput">2. Enter image URL:</label>
                    <input type="text" id="bgImageUrlInput" placeholder="https://example.com/image.png">
                    <p><small>Using a URL is recommended for very large images from the web.</small></p>
                    <button id="applyBgImageUrlBtn" class="xp-button" style="margin-top: 5px;">Apply URL</button>
                </div>
                <hr>
                <div>
                    <label>3. Pick a solid color:</label>
                    <div id="bgColorSwatchesContainer" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; justify-content: center;">
                          </div>
                     <p style="margin-top: 8px;"><small>Click a color swatch to apply it immediately.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="xp-button" data-modal-id="changeBgImageModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="playJockeyContextMenu" class="context-modal">
        <div class="context-modal-item" id="pjContextRename">Rename Track</div>
        <div class="context-modal-item" id="pjContextRemove">Remove Track</div>
    </div>
    <div id="playJockeyTabContextMenu" class="context-modal">
        <div class="context-modal-item" id="pjTabContextRename">Rename Playlist</div>
        <div class="context-modal-item" id="pjTabContextRemove">Remove Playlist</div>
    </div>

    <div id="renamePlaylistModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Rename Playlist</span>
                <span class="close-button" data-modal-id="renamePlaylistModal">r</span>
            </div>
            <div class="modal-body">
                <label for="playlistNewNameInput">New playlist name:</label>
                <input type="text" id="playlistNewNameInput" placeholder="Enter playlist name">
            </div>
            <div class="modal-footer">
                <button id="saveRenamedPlaylistBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="renamePlaylistModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="confirmRemovePlaylistModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Playlist Deletion</span>
                <span class="close-button" data-modal-id="confirmRemovePlaylistModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemovePlaylistMessage">Are you sure you want to remove this playlist?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmFinalPlaylistRemoveBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmRemovePlaylistModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="youtubeSearchModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title-bar">
                <span>Youtube Results</span>
                <span class="close-button" data-modal-id="youtubeSearchModal">r</span>
            </div>
            <div class="modal-body" id="youtubeSearchResultsBody">
                <p id="youtubeSearchStatus" style="text-align: center; display: none;"></p>
            </div>
            <div class="modal-footer">
                <button class="xp-button" data-modal-id="youtubeSearchModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="renameTrackModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Rename Track</span>
                <span class="close-button" data-modal-id="renameTrackModal">r</span>
            </div>
            <div class="modal-body">
                <label for="trackNewNameInput">New track name:</label>
                <input type="text" id="trackNewNameInput" placeholder="Enter track name">
                <label for="trackNewArtistInput" style="margin-top:10px;">New artist name (optional):</label>
                <input type="text" id="trackNewArtistInput" placeholder="Enter artist name">
            </div>
            <div class="modal-footer">
                <button id="saveRenamedTrackBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="renameTrackModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="confirmRemoveTrackModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Track Deletion</span>
                <span class="close-button" data-modal-id="confirmRemoveTrackModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemoveTrackMessage">Are you sure you want to remove this track from the playlist?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmFinalTrackRemoveBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmRemoveTrackModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="confirmClearChatModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Clear History</span>
                <span class="close-button" data-modal-id="confirmClearChatModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to clear the entire chat history? This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmClearChatBtn" class="xp-button">Clear History</button>
                <button class="xp-button" data-modal-id="confirmClearChatModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="pixelCanvasSizeModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Set Canvas Size</span>
                <span class="close-button" data-modal-id="pixelCanvasSizeModal">r</span>
            </div>
            <div class="modal-body">
                <label for="pixelNewCanvasWidth">New Width (px):</label>
                <input type="number" id="pixelNewCanvasWidth" min="50" max="2000" value="600">
                <label for="pixelNewCanvasHeight">New Height (px):</label>
                <input type="number" id="pixelNewCanvasHeight" min="50" max="2000" value="400">
                <p><small>Min: 50px, Max: 2000px per dimension.</small></p>
            </div>
            <div class="modal-footer">
                <button id="savePixelCanvasSizeBtn" class="xp-button">Save New Size</button>
                <button class="xp-button" data-modal-id="pixelCanvasSizeModal">Cancel</button>
            </div>
        </div>
    </div>

    <div id="confirmPixelResizeModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Canvas Resize</span>
                <span class="close-button" data-modal-id="confirmPixelResizeModal">r</span>
            </div>
            <div class="modal-body">
                <p>Changing the canvas size will clear the current drawing. Are you sure you want to proceed?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmPixelResizeBtn" class="xp-button">Proceed & Clear</button>
                <button class="xp-button" data-modal-id="confirmPixelResizeModal">Cancel</button>
            </div>
        </div>
    </div>


    <script src="https://www.youtube.com/iframe_api"></script>

<script>
    "use strict";

    let YOUTUBE_API_KEY = "";
    let GEMINI_API_KEY = "";

    const WEEKDAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    const XP_PER_REGULAR_ACHIEVEMENT = 10;
    const XP_PER_QUEST_COMPLETED_BASE = 50;
    const STORAGE_KEY = 'lifeXpData_v1.11.0';
    const MAX_WEEKLY_QUESTS = 5;
    const ICON_GRID_SIZE = 25;

    let minTrackerAppWidth;
    const MIN_TRACKER_APP_HEIGHT = 250;
    const MIN_TEXTEDITOR_WIDTH = 375;
    const MIN_TEXTEDITOR_HEIGHT = 250;
    const MIN_PLAYJOCKEY_WIDTH = 375;
    const MIN_PLAYJOCKEY_HEIGHT = 250;
    const MIN_GEMINI_CHAT_WIDTH = 375;
    const MIN_GEMINI_CHAT_HEIGHT = 250;
    const MIN_PIXEL_WIDTH = 375;
    const MIN_PIXEL_HEIGHT = 250;


    const STANDARD_COLORS = [
        { name: 'Black', value: '#000000' }, { name: 'Silver', value: '#C0C0C0' },
        { name: 'Gray', value: '#808080' }, { name: 'White', value: '#FFFFFF' },
        { name: 'Maroon', value: '#800000' }, { name: 'Red', value: '#FF0000' },
        { name: 'Purple', value: '#800080' }, { name: 'Fuchsia', value: '#FF00FF' },
        { name: 'Green', value: '#008000' }, { name: 'Lime', value: '#00FF00' },
        { name: 'Olive', value: '#808000' }, { name: 'Yellow', value: '#FFFF00' },
        { name: 'Navy', value: '#000080' }, { name: 'Blue', value: '#0000FF' },
        { name: 'Teal', value: '#008080' }, { name: 'Aqua', value: '#00FFFF' },
        { name: 'Orange', value: '#FFA500' }, { name: 'Brown', value: '#A52A2A' },
        { name: 'Pink', value: '#FFC0CB' }, { name: 'Gold', value: '#FFD700' },
        { name: 'Dark Green', value: '#006400' }, { name: 'Light Blue', value: '#ADD8E6' },
        { name: 'Indigo', value: '#4B0082' }, { name: 'Violet', value: '#EE82EE' },
        { name: 'Coral', value: '#FF7F50' }, { name: 'Sky Blue', value: '#87CEEB' }
    ];

    const MODAL_IDS = {
        NEW_AREA: 'newAreaModal',
        ADD_EDIT_ACHIEVEMENT: 'addEditAchievementModal',
        QUESTS: 'questsModal',
        CONFIRM_REMOVE_AREA: 'confirmRemoveAreaModal',
        CONFIRM_DELETE_ACHIEVEMENT: 'confirmDeleteAchievementModal',
        CREATE_QUEST: 'createQuestModal',
        CONFIRM_REFRESH_QUEST: 'confirmRefreshQuestModal',
        CHANGE_BG_IMAGE: 'changeBgImageModal',
        RENAME_PLAYLIST: 'renamePlaylistModal',
        CONFIRM_REMOVE_PLAYLIST: 'confirmRemovePlaylistModal',
        Youtube: 'youtubeSearchModal',
        RENAME_TRACK: 'renameTrackModal',
        CONFIRM_REMOVE_TRACK: 'confirmRemoveTrackModal',
        CONFIRM_CLEAR_CHAT: 'confirmClearChatModal',
        PIXEL_CANVAS_SIZE: 'pixelCanvasSizeModal',
        CONFIRM_PIXEL_RESIZE: 'confirmPixelResizeModal'
    };

    const firebaseConfig = {
      apiKey: "AIzaSyCVWUnnXiOvKRqbvngafdZC7DedEY-7vpg",
      authDomain: "lifexpapp-f5578.firebaseapp.com",
      projectId: "lifexpapp-f5578",
      storageBucket: "lifexpapp-f5578.appspot.com",
      messagingSenderId: "194098013746",
      appId: "1:194098013746:web:720ba296ee9e40dee37e2b"
    };

    firebase.initializeApp(firebaseConfig);
    const remoteConfig = firebase.remoteConfig();

    remoteConfig.defaultConfig = {
      'youtube_api_key': '',
      'gemini_api_key': ''
    };

    remoteConfig.settings.minimumFetchIntervalMillis = 3600000;


    const getById = (id) => document.getElementById(id);

    function decodeHtmlEntities(text) {
        if (typeof text !== 'string') {
            return text;
        }
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }

    const DOM = {
        xpMainWindow: getById('xpMainWindow'),
        xpMainWindowTitleBar: getById('xpMainWindowTitleBar'),
        xpMainWindowResizeHandle: getById('xpMainWindowResizeHandle'),
        xpMainWindowMinimizeBtn: getById('xpMainWindowMinimizeBtn'),
        xpMainWindowMaximizeBtn: getById('xpMainWindowMaximizeBtn'),
        xpMainWindowCloseBtn: getById('xpMainWindowCloseBtn'),
        weekdayHeaders: getById('weekdayHeaders'),
        gridBody: getById('gridBody'),
        addAreaBtn: getById('addAreaBtn'),
        prevWeekBtn: getById('prevWeekBtn'),
        nextWeekBtn: getById('nextWeekBtn'),
        thisWeekBtn: getById('thisWeekBtn'),
        toggleViewBtn: getById('toggleViewBtn'),
        currentWeekDisplay: getById('currentWeekDisplay'),
        weekCountDisplay: getById('weekCountDisplay'),
        showQuestsBtn: getById('showQuestsBtn'),
        controlsBar: getById('controlsBar'),

        textEditorWindow: getById('textEditorWindow'),
        textEditorWindowTitleBar: getById('textEditorWindowTitleBar'),
        textEditorWindowBody: getById('textEditorWindowBody'),
        textEditorFrame: getById('textEditorFrame'),
        textEditorResizeHandle: getById('textEditorResizeHandle'),
        textEditorMinimizeBtn: getById('textEditorMinimizeBtn'),
        textEditorMaximizeBtn: getById('textEditorMaximizeBtn'),
        textEditorCloseBtn: getById('textEditorCloseBtn'),

        playJockeyWindow: getById('playJockeyWindow'),
        playJockeyTitleBar: getById('playJockeyTitleBar'),
        playJockeyWindowBody: getById('playJockeyWindowBody'),
        playJockeyResizeHandle: getById('playJockeyResizeHandle'),
        playJockeyMinimizeBtn: getById('playJockeyMinimizeBtn'),
        playJockeyMaximizeBtn: getById('playJockeyMaximizeBtn'),
        playJockeyCloseBtn: getById('playJockeyCloseBtn'),
        playJockeyLinkInput: getById('playJockeyLinkInput'),
        playJockeyAddBtn: getById('playJockeyAddBtn'),
        playJockeyPlayer: getById('playJockeyPlayer'),
        playJockeyTabsBar: getById('playJockeyTabsBar'),
        playJockeyPlaylist: getById('playJockeyPlaylist'),
        playJockeyContextMenu: getById('playJockeyContextMenu'),
        pjContextRenameBtn: getById('pjContextRename'),
        pjContextRemoveBtn: getById('pjContextRemove'),
        playJockeyTabContextMenu: getById('playJockeyTabContextMenu'),
        pjTabContextRenameBtn: getById('pjTabContextRename'),
        pjTabContextRemoveBtn: getById('pjTabContextRemove'),
        playJockeyRandomBtn: getById('playJockeyRandomBtn'),
        playJockeyAutoPlayBtn: getById('playJockeyAutoPlayBtn'),
        playJockeyRepeatBtn: getById('playJockeyRepeatBtn'),

        geminiChatWindow: getById('geminiChatWindow'),
        geminiChatWindowTitleBar: getById('geminiChatWindowTitleBar'),
        geminiChatWindowBody: getById('geminiChatWindowBody'),
        geminiChatResizeHandle: getById('geminiChatResizeHandle'),
        geminiChatMinimizeBtn: getById('geminiChatMinimizeBtn'),
        geminiChatMaximizeBtn: getById('geminiChatMaximizeBtn'),
        geminiChatCloseBtn: getById('geminiChatCloseBtn'),
        geminiChatDisplayArea: getById('geminiChatDisplayArea'),
        geminiChatPromptInput: getById('geminiChatPromptInput'),
        geminiChatSendBtn: getById('geminiChatSendBtn'),
        geminiChatClearHistoryBtn: getById('geminiChatClearHistoryBtn'),
        geminiChatIcon: getById('geminiChatIcon'),

        pixelWindow: getById('pixelWindow'),
        pixelWindowTitleBar: getById('pixelWindowTitleBar'),
        pixelWindowBody: getById('pixelWindowBody'),
        pixelResizeHandle: getById('pixelResizeHandle'),
        pixelMinimizeBtn: getById('pixelMinimizeBtn'),
        pixelMaximizeBtn: getById('pixelMaximizeBtn'),
        pixelCloseBtn: getById('pixelCloseBtn'),
        pixelMenuBar: getById('pixelMenuBar'),
        pixelFileSave: getById('pixelFileSave'),
        pixelFileClearCanvas: getById('pixelFileClearCanvas'),
        pixelFileCanvasSize: getById('pixelFileCanvasSize'),
        pixelPencilTool: getById('pixelPencilTool'),
        pixelEraserTool: getById('pixelEraserTool'),
        pixelBucketTool: getById('pixelBucketTool'),
        pixelColorPicker: getById('pixelColorPicker'),
        pixelSizeInput: getById('pixelSizeInput'),
        pixelCanvas: getById('pixelCanvas'),
        pixelCanvasContainer: getById('pixelCanvasContainer'),


        textEditorIcon: getById('textEditorIcon'),
        trackerIcon: getById('trackerIcon'),
        playJockeyIcon: getById('playJockeyIcon'),
        pixelIcon: getById('pixelIcon'),

        newAreaModal: getById(MODAL_IDS.NEW_AREA),
        newAreaNameInput: getById('newAreaName'),
        saveNewAreaBtn: getById('saveNewAreaBtn'),
        addEditAchievementModal: getById(MODAL_IDS.ADD_EDIT_ACHIEVEMENT),
        addEditAchievementModalTitle: getById('addEditAchievementModalTitle'),
        achievementAreaNameInput: getById('achievementAreaName'),
        achievementDayIndexInput: getById('achievementDayIndex'),
        editingAchievementKeyInput: getById('editingAchievementKey'),
        editingAchievementIdInput: getById('editingAchievementId'),
        achievementTypeRadios: document.getElementsByName('achievementType'),
        textInputDiv: getById('textInputDiv'),
        imageInputDiv: getById('imageInputDiv'),
        achievementTextInput: getById('achievementText'),
        achievementImageInput: getById('achievementImage'),
        saveAchievementBtn: getById('saveAchievementBtn'),
        questsModal: getById(MODAL_IDS.QUESTS),
        questsList: getById('questsList'),
        addQuestBtn: getById('addQuestBtn'),
        createQuestModal: getById(MODAL_IDS.CREATE_QUEST),
        newQuestAreaNameSelect: getById('newQuestAreaName'),
        newQuestDescriptionInput: getById('newQuestDescription'),
        newQuestTargetXPInput: getById('newQuestTargetXP'),
        newQuestRewardXPInput: getById('newQuestRewardXP'),
        saveNewQuestBtn: getById('saveNewQuestBtn'),
        confirmRefreshQuestModal: getById(MODAL_IDS.CONFIRM_REFRESH_QUEST),
        confirmRefreshQuestBtn: getById('confirmRefreshQuestBtn'),
        confirmRemoveAreaModal: getById(MODAL_IDS.CONFIRM_REMOVE_AREA),
        confirmRemoveAreaMessage: getById('confirmRemoveAreaMessage'),
        confirmRemoveBtn: getById('confirmRemoveBtn'),
        confirmDeleteAchievementModal: getById(MODAL_IDS.CONFIRM_DELETE_ACHIEVEMENT),
        confirmDeleteAchievementBtn: getById('confirmDeleteAchievementBtn'),
        changeBgImageModal: getById(MODAL_IDS.CHANGE_BG_IMAGE),
        newBgImageInput: getById('newBgImageInput'),
        uploadBgImageBtn: getById('uploadBgImageBtn'),
        bgImageUrlInput: getById('bgImageUrlInput'),
        applyBgImageUrlBtn: getById('applyBgImageUrlBtn'),
        bgColorSwatchesContainer: getById('bgColorSwatchesContainer'),

        renamePlaylistModal: getById(MODAL_IDS.RENAME_PLAYLIST),
        playlistNewNameInput: getById('playlistNewNameInput'),
        saveRenamedPlaylistBtn: getById('saveRenamedPlaylistBtn'),
        confirmRemovePlaylistModal: getById(MODAL_IDS.CONFIRM_REMOVE_PLAYLIST),
        confirmRemovePlaylistMessage: getById('confirmRemovePlaylistMessage'),
        confirmFinalPlaylistRemoveBtn: getById('confirmFinalPlaylistRemoveBtn'),

        youtubeSearchModal: getById(MODAL_IDS.Youtube),
        youtubeSearchResultsBody: getById('youtubeSearchResultsBody'),
        youtubeSearchStatus: getById('youtubeSearchStatus'),

        renameTrackModal: getById(MODAL_IDS.RENAME_TRACK),
        trackNewNameInput: getById('trackNewNameInput'),
        trackNewArtistInput: getById('trackNewArtistInput'),
        saveRenamedTrackBtn: getById('saveRenamedTrackBtn'),
        confirmRemoveTrackModal: getById(MODAL_IDS.CONFIRM_REMOVE_TRACK),
        confirmRemoveTrackMessage: getById('confirmRemoveTrackMessage'),
        confirmFinalTrackRemoveBtn: getById('confirmFinalTrackRemoveBtn'),

        confirmClearChatModal: getById(MODAL_IDS.CONFIRM_CLEAR_CHAT),
        confirmClearChatBtn: getById('confirmClearChatBtn'),

        pixelCanvasSizeModal: getById(MODAL_IDS.PIXEL_CANVAS_SIZE),
        pixelNewCanvasWidthInput: getById('pixelNewCanvasWidth'),
        pixelNewCanvasHeightInput: getById('pixelNewCanvasHeight'),
        savePixelCanvasSizeBtn: getById('savePixelCanvasSizeBtn'),
        confirmPixelResizeModal: getById(MODAL_IDS.CONFIRM_PIXEL_RESIZE),
        confirmPixelResizeBtn: getById('confirmPixelResizeBtn'),


        modalCloseButtons: null
    };
    DOM.modalCloseButtons = document.querySelectorAll('.modal .close-button, .modal .xp-button[data-modal-id]');

    let defaultAppData;

    let appData = {
        areas: [],
        achievements: {},
        quests: {},
        currentWeekStartDate: null,
        viewMode: 'week',
        selectedDayIndex: 0,
        windowStates: {},
        iconPositions: {},
        customBgImage: null,
        customBgColor: null,
        playJockeyPlaylists: [],
        playJockeyCurrentPlaylistId: null,
        playJockeyCurrentVideo: null,
        playJockeyAutoPlayEnabled: true,
        playJockeyRandomEnabled: false,
        playJockeyRepeatState: "off",
        playJockeyRandomHistory: [],
        geminiChatHistory: [],
        pixelAppData: {
            currentColor: '#000000',
            currentTool: 'pencil',
            pencilSize: 2,
            canvasWidth: 600,
            canvasHeight: 400
        }
    };

    let lastNormalStates = {};
    let highestZIndex = 9;

    let activeDragWindow = null;
    let activeResizeWindow = null;
    let dragOffsetX, dragOffsetY;
    let resizeInitialX, resizeInitialY, resizeInitialWidth, resizeInitialHeight;

    let activeDragIcon = null;
    let iconDragOffsetX, iconDragOffsetY;

    let pjDraggedItem = null;

    let ytPlayerInstance = null;
    let isYouTubeApiReady = false;
    let pendingVideoToLoad = null;

    let pixelCtx = null;
    let pixelIsDrawing = false;
    let pixelLastX, pixelLastY;


    function parseYYYYMMDDToLocalDate(dateString) {
        if (!dateString || typeof dateString !== 'string') return null;
        const parts = dateString.split('-');
        if (parts.length !== 3) return null;
        const [year, month, day] = parts.map(Number);
        if (isNaN(year) || isNaN(month) || isNaN(day)) return null;
        return new Date(year, month - 1, day);
    }

    function getDayOfYear(date) {
        const startOfYear = new Date(date.getFullYear(), 0, 0);
        const diff = date - startOfYear;
        const oneDay = 1000 * 60 * 60 * 24;
        return Math.floor(diff / oneDay);
    }

    function applyCurrentBackgroundStyle() {
        if (appData.customBgColor) {
            document.body.style.backgroundImage = 'none';
            document.body.style.backgroundColor = appData.customBgColor;
        } else if (appData.customBgImage) {
            document.body.style.backgroundColor = '';
            document.body.style.backgroundImage = `url('${appData.customBgImage}')`;
        } else {
            document.body.style.backgroundColor = '#3A6EA5';
            document.body.style.backgroundImage = "url('https://archive.org/download/bliss-600dpi/bliss-600dpi.png')";
        }
    }

    function checkAndAwardScheduledXP() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        let xpWasAwardedThisCheck = false;

        for (const achievementsKey in appData.achievements) {
            if (appData.achievements.hasOwnProperty(achievementsKey)) {
                const achievementsInCell = appData.achievements[achievementsKey];
                const keyParts = achievementsKey.split('_');

                if (keyParts.length < 3) {
                    console.warn(`Skipping invalid achievementsKey during XP check: ${achievementsKey}`);
                    continue;
                }
                const areaName = keyParts.slice(1, keyParts.length - 1).join('_');

                for (const ach of achievementsInCell) {
                    if (ach.xpAwarded === undefined) {
                        ach.xpAwarded = false;
                    }
                    if (!ach.scheduledDate) {
                        console.warn(`Achievement ${ach.id} in ${areaName} is missing scheduledDate. Cannot process for auto XP.`);
                        continue;
                    }

                    if (!ach.xpAwarded) {
                        const achievementScheduledDate = parseYYYYMMDDToLocalDate(ach.scheduledDate);
                        if (achievementScheduledDate && achievementScheduledDate <= today) {
                            console.log(`Awarding XP for past due achievement: ${ach.id} (scheduled: ${ach.scheduledDate}) in area ${areaName}`);
                            addXpToArea(areaName, ach.xp);
                            updateQuestProgress(areaName, ach.xp);
                            ach.xpAwarded = true;
                            xpWasAwardedThisCheck = true;
                        }
                    }
                }
            }
        }

        if (xpWasAwardedThisCheck) {
            renderGrid();
            saveData();
        }
    }


    function init() {
        loadData();
        applyCurrentBackgroundStyle();
        populateColorSwatches();
        initDesktopIcons();
        initPixelApp();

        checkAndAwardScheduledXP();

        if (appData.viewMode === 'week') {
            minTrackerAppWidth = 905;
        } else {
            minTrackerAppWidth = 375;
        }
        if (appData.viewMode !== 'week' && appData.viewMode !== 'day') {
             console.warn("Invalid viewMode loaded, defaulting to week.");
             appData.viewMode = 'week';
             minTrackerAppWidth = 905;
        }

        if (!appData.currentWeekStartDate) {
            appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        }
        if (appData.viewMode === 'day' && (appData.selectedDayIndex === undefined || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) ) {
             appData.selectedDayIndex = 0;
        }

        initWindowInteractions('xpMainWindow');
        restoreWindowState('xpMainWindow');

        DOM.textEditorFrame.srcdoc = getTextEditorHTMLContent();
        initWindowInteractions('textEditorWindow');
        restoreWindowState('textEditorWindow');

        initWindowInteractions('playJockeyWindow');
        restoreWindowState('playJockeyWindow');

        initWindowInteractions('geminiChatWindow');
        restoreWindowState('geminiChatWindow');

        initWindowInteractions('pixelWindow');
        restoreWindowState('pixelWindow');


        updateMinMaxButtonStates('xpMainWindow');
        updateMinMaxButtonStates('textEditorWindow');
        updateMinMaxButtonStates('playJockeyWindow');
        updateMinMaxButtonStates('geminiChatWindow');
        updateMinMaxButtonStates('pixelWindow');


        renderPlayJockeyTabs();
        renderPlayJockeyPlaylist();
        updatePlayJockeyAutoPlayButtonState();
        updatePlayJockeyRandomButtonState();
        updatePlayJockeyRepeatButtonState();


        if (appData.playJockeyCurrentVideo && (isYouTubeApiReady || typeof YT !== 'undefined')) {
            const currentPlaylist = getCurrentPlayJockeyPlaylist();
            if (currentPlaylist && currentPlaylist.videos.some(v => v.id === appData.playJockeyCurrentVideo.id)) {
                 playYouTubeVideoById(appData.playJockeyCurrentVideo.videoId, appData.playJockeyAutoPlayEnabled);
            } else {
                appData.playJockeyCurrentVideo = null;
            }
        } else if (appData.playJockeyCurrentVideo) {
            const currentPlaylist = getCurrentPlayJockeyPlaylist();
             if (currentPlaylist && currentPlaylist.videos.some(v => v.id === appData.playJockeyCurrentVideo.id)) {
                pendingVideoToLoad = { videoId: appData.playJockeyCurrentVideo.videoId, autoplayIntent: appData.playJockeyAutoPlayEnabled };
            } else {
                appData.playJockeyCurrentVideo = null;
            }
        }

        let maxLoadedWindowZ = highestZIndex;
        ['xpMainWindow', 'textEditorWindow', 'playJockeyWindow', 'geminiChatWindow', 'pixelWindow'].forEach(windowId => {
            if (appData.windowStates[windowId] && appData.windowStates[windowId].zIndex) {
                maxLoadedWindowZ = Math.max(maxLoadedWindowZ, parseInt(appData.windowStates[windowId].zIndex));
            }
        });
        highestZIndex = maxLoadedWindowZ;


        addEventListeners();
        initPlayJockeyContextMenu();
        initPlayJockeyTabContextMenu();


        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        handleAppWindowResize();

        const trackerWindowObserver = new ResizeObserver(handleAppWindowResize);
        trackerWindowObserver.observe(DOM.xpMainWindow);
        const pixelWindowObserver = new ResizeObserver(handlePixelWindowResize);
        pixelWindowObserver.observe(DOM.pixelWindow);

    }

    function initDesktopIcons() {
        const icons = [DOM.textEditorIcon, DOM.trackerIcon, DOM.playJockeyIcon, DOM.geminiChatIcon, DOM.pixelIcon];
        const iconData = [
            { id: 'trackerIcon', defaultX: 0, defaultY: 0, element: DOM.trackerIcon },
            { id: 'textEditorIcon', defaultX: 0, defaultY: 100, element: DOM.textEditorIcon },
            { id: 'playJockeyIcon', defaultX: 0, defaultY: 200, element: DOM.playJockeyIcon },
            { id: 'geminiChatIcon', defaultX: 0, defaultY: 300, element: DOM.geminiChatIcon },
            { id: 'pixelIcon', defaultX: 0, defaultY: 400, element: DOM.pixelIcon }
        ];

        iconData.forEach(data => {
            const iconElement = data.element;
            if (!iconElement) return;

            const iconId = iconElement.id;
            if (appData.iconPositions && appData.iconPositions[iconId]) {
                iconElement.style.left = appData.iconPositions[iconId].x + 'px';
                iconElement.style.top = appData.iconPositions[iconId].y + 'px';
            } else {
                const { x: finalX, y: finalY } = findNonCollidingPosition(iconElement, data.defaultX, data.defaultY);

                iconElement.style.left = finalX + 'px';
                iconElement.style.top = finalY + 'px';

                if (!appData.iconPositions) appData.iconPositions = {};
                appData.iconPositions[iconId] = { x: finalX, y: finalY };
            }

            iconElement.addEventListener('mousedown', handleIconMouseDown);
            iconElement.addEventListener('dblclick', handleIconDoubleClick);
        });
    }


    function handleIconMouseDown(e) {
        if (e.button !== 0 || activeDragWindow || activeResizeWindow) return;

        activeDragIcon = e.currentTarget;
        const windowId = activeDragIcon.dataset.windowId;
        const windowEl = getById(windowId);
        if(windowEl && windowEl.style.display !== 'none' && !windowEl.classList.contains('minimized')) {
             bringToFront(windowEl);
        }

        iconDragOffsetX = e.clientX - activeDragIcon.offsetLeft;
        iconDragOffsetY = e.clientY - activeDragIcon.offsetTop;

        activeDragIcon.style.cursor = 'grabbing';
        activeDragIcon.style.zIndex = '6';

        document.addEventListener('mousemove', handleIconMouseMove);
        document.addEventListener('mouseup', handleIconMouseUp);
        e.preventDefault();
    }

    function handleIconMouseMove(e) {
        if (!activeDragIcon) return;
        let newX = e.clientX - iconDragOffsetX;
        let newY = e.clientY - iconDragOffsetY;

        const bodyRect = document.body.getBoundingClientRect();
        const iconWidth = activeDragIcon.offsetWidth || 90;
        const iconHeight = activeDragIcon.offsetHeight || 100;

        newX = Math.max(0, Math.min(newX, bodyRect.width - iconWidth));
        newY = Math.max(0, Math.min(newY, bodyRect.height - iconHeight));

        activeDragIcon.style.left = newX + 'px';
        activeDragIcon.style.top = newY + 'px';
    }

    function findNonCollidingPosition(draggedIcon, initialX, initialY) {
        let currentX = initialX;
        let currentY = initialY;
        let attempt = 0;
        const maxAttempts = 100;
        const iconWidth = draggedIcon.offsetWidth || 90;
        const iconHeight = draggedIcon.offsetHeight || 100;

        const checkCollisionAt = (x, y, currentDraggedIcon) => {
            const iconsToCompare = [DOM.textEditorIcon, DOM.trackerIcon, DOM.playJockeyIcon, DOM.geminiChatIcon, DOM.pixelIcon].filter(
                icon => icon && icon !== currentDraggedIcon && icon.style.left && icon.style.top
            );

            for (const otherIcon of iconsToCompare) {
                const otherLeft = parseInt(otherIcon.style.left, 10);
                const otherTop = parseInt(otherIcon.style.top, 10);
                const otherWidth = otherIcon.offsetWidth || 90;
                const otherHeight = otherIcon.offsetHeight || 100;

                if (x < otherLeft + otherWidth &&
                    x + iconWidth > otherLeft &&
                    y < otherTop + otherHeight &&
                    y + iconHeight > otherTop) {
                    return true;
                }
            }
            return false;
        };

        let snappedX = Math.round(initialX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        let snappedY = Math.round(initialY / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        snappedX = Math.max(0, Math.min(snappedX, document.body.clientWidth - iconWidth));
        snappedY = Math.max(0, Math.min(snappedY, document.body.clientHeight - iconHeight));


        if (!checkCollisionAt(snappedX, snappedY, draggedIcon)) {
            return { x: snappedX, y: snappedY };
        }

        let layer = 1;
        while (attempt < maxAttempts) {
            const positionsToTry = [];
            for (let i = -layer; i <= layer; i++) {
                positionsToTry.push({ x: snappedX + i * ICON_GRID_SIZE, y: snappedY - layer * ICON_GRID_SIZE });
                if (layer !== 0) positionsToTry.push({ x: snappedX + i * ICON_GRID_SIZE, y: snappedY + layer * ICON_GRID_SIZE });
            }
            for (let i = -layer + 1; i < layer; i++) {
                positionsToTry.push({ x: snappedX - layer * ICON_GRID_SIZE, y: snappedY + i * ICON_GRID_SIZE });
                if (layer !== 0) positionsToTry.push({ x: snappedX + layer * ICON_GRID_SIZE, y: snappedY + i * ICON_GRID_SIZE });
            }

            for (const pos of positionsToTry) {
                attempt++;
                if (attempt >= maxAttempts) break;

                let testX = pos.x;
                let testY = pos.y;

                testX = Math.max(0, Math.min(testX, document.body.clientWidth - iconWidth));
                testY = Math.max(0, Math.min(testY, document.body.clientHeight - iconHeight));
                testX = Math.round(testX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
                testY = Math.round(testY / ICON_GRID_SIZE) * ICON_GRID_SIZE;


                if (!checkCollisionAt(testX, testY, draggedIcon)) {
                    return { x: testX, y: testY };
                }
            }
            if (attempt >= maxAttempts) break;
            layer++;
            if (layer * ICON_GRID_SIZE > Math.max(document.body.clientWidth, document.body.clientHeight) && attempt > 20) {
                 console.warn("Collision search boundary too large for icon placement. Layer:", layer); break;
            }
        }

        console.warn("Could not find a non-colliding position for icon " + draggedIcon.id + " after " + attempt + " attempts. Using original snapped position which might collide.");
        return { x: snappedX, y: snappedY };
    }


    function handleIconMouseUp() {
        if (!activeDragIcon) return;

        activeDragIcon.style.zIndex = '5';

        let finalX = activeDragIcon.offsetLeft;
        let finalY = activeDragIcon.offsetTop;

        let snappedX = Math.round(finalX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        let snappedY = Math.round(finalY / ICON_GRID_SIZE) * ICON_GRID_SIZE;

        const iconWidth = activeDragIcon.offsetWidth || 90;
        const iconHeight = activeDragIcon.offsetHeight || 100;
        snappedX = Math.max(0, Math.min(snappedX, document.body.clientWidth - iconWidth));
        snappedY = Math.max(0, Math.min(snappedY, document.body.clientHeight - iconHeight));
        snappedX = Math.round(snappedX / ICON_GRID_SIZE) * ICON_GRID_SIZE;
        snappedY = Math.round(snappedY / ICON_GRID_SIZE) * ICON_GRID_SIZE;


        const { x: finalSnappedX, y: finalSnappedY } = findNonCollidingPosition(activeDragIcon, snappedX, snappedY);

        activeDragIcon.style.left = finalSnappedX + 'px';
        activeDragIcon.style.top = finalSnappedY + 'px';

        const iconId = activeDragIcon.id;
        if (!appData.iconPositions) appData.iconPositions = {};
        appData.iconPositions[iconId] = { x: finalSnappedX, y: finalSnappedY };
        saveData();

        activeDragIcon.style.cursor = 'grab';
        activeDragIcon = null;
        document.removeEventListener('mousemove', handleIconMouseMove);
        document.removeEventListener('mouseup', handleIconMouseUp);
    }

    function handleIconDoubleClick(e) {
        const iconElement = e.currentTarget;
        const windowId = iconElement.dataset.windowId;
        const windowElement = getById(windowId);

        if (!windowElement) return;

        let state = appData.windowStates[windowId];
        if (!state) {
            console.warn(`State for window ${windowId} was missing on double click. Attempting to restore/initialize.`);
            restoreWindowState(windowId);
            state = appData.windowStates[windowId];
            if(!state) {
                console.error(`Failed to initialize state for ${windowId} on double click.`);
                return;
            }
        }


        if (state.hiddenByUser || windowElement.style.display === 'none') {
            state.hiddenByUser = false;
            state.minimized = false;

            windowElement.style.display = 'flex';
            windowElement.classList.remove('minimized');
            restoreWindowState(windowId);

            if (windowId === 'playJockeyWindow') {
                if (appData.playJockeyCurrentVideo && !ytPlayerInstance && isYouTubeApiReady) {
                    playYouTubeVideoById(appData.playJockeyCurrentVideo.videoId, false);
                } else if (pendingVideoToLoad && isYouTubeApiReady) {
                    playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
                    pendingVideoToLoad = null;
                }
            }
            if (windowId === 'pixelWindow') {
                handlePixelWindowResize();
            }
        } else if (state.minimized || windowElement.classList.contains('minimized')) {
            maximizeWindow(windowId);
        }

        bringToFront(windowElement);
        saveWindowState(windowId);
    }


    function getTextEditorHTMLContent() {
        return `
<html lang="en">
<head>
    <title>Jotter</title>
    <style>
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; }
        body { font-family: "Tahoma", "Geneva", sans-serif; font-size: 11px; background-color: #ECE9D8; color: #000000; display: flex; flex-direction: column; }
        [contenteditable]:focus { outline: none; }
        .jotter-menu-bar { background-color: #ECE9D8; padding: 2px 3px; border-bottom: 1px solid #ACA899; display: flex; flex-shrink: 0; user-select: none; color: #000000; }
        .jotter-menu-item { padding: 3px 8px; cursor: default; position: relative; color: inherit; }
        .jotter-menu-item:hover { background-color: #005CFE; color: white; }
        .jotter-dropdown-content { display: none; position: absolute; top: 100%; left: 0; background-color: #ECE9D8; border: 1px solid #000; box-shadow: 1px 1px 3px rgba(0,0,0,0.2); z-index: 100; padding: 2px 0; color: #000000; }
        .jotter-dropdown-item { padding: 4px 12px 4px 25px; cursor: default; white-space: nowrap; position: relative; color: inherit; display: flex; align-items: center; min-height: 22px; box-sizing: border-box; }
        .jotter-dropdown-item:not(.font-size-control-container):hover:not(.disabled) { background-color: #005CFE; color: white; }
        .jotter-dropdown-item.disabled { color: #7F7F7F !important; background-color: #ECE9D8 !important; cursor: default; }
        .jotter-menu-item:focus-within .jotter-dropdown-content, .jotter-menu-item.open .jotter-dropdown-content { display: block; }
        #editorArea { border: 1px solid #7F7F7F; padding: 5px; background-color: white; overflow-y: auto; font-family: 'Lucida Console', Monaco, monospace; font-size: 14px; line-height: 1.4; color: #000000; white-space: pre-wrap; word-wrap: break-word; box-sizing: border-box; margin: 5px; flex-grow: 1; }
        .font-size-control-container { display: flex; align-items: center; padding: 0px 5px 0px 15px !important; }
        .font-size-control-container span { margin-right: 8px; }
        .font-size-btn { font-family: "Tahoma", "Geneva", sans-serif; font-size: 10px; border: 1px outset #7F7F7F; background-color: #ECE9D8; width: 20px; height: 20px; line-height: 18px; text-align: center; padding: 0; cursor: default; color: black; }
        .font-size-btn:active { border-style: inset; }
        .font-size-btn:hover { background-color: #005CFE; color: white; }
        .font-size-input { width: 30px; height: 18px; border: 1px solid #7F7F7F; text-align: center; margin: 0 3px; font-family: "Tahoma", "Geneva", sans-serif; font-size: 11px; padding: 1px; box-sizing: border-box; }
    </style>
</head>
<body>
    <div class="jotter-menu-bar" id="jotterMenuBarInFrame">
        <div class="jotter-menu-item" tabindex="0"> File <div class="jotter-dropdown-content"> <div class="jotter-dropdown-item" id="fileSaveInFrame">Save</div> </div> </div>
        <div class="jotter-menu-item" tabindex="0"> View <div class="jotter-dropdown-content"> <div class="jotter-dropdown-item font-size-control-container" id="fontSizeControlItemInFrame"> <span>Font Size:</span> <button class="font-size-btn" id="fontDecrementBtnInFrame">-</button> <input type="number" class="font-size-input" id="fontSizeInputInFrame" value="14" min="8" max="72"> <button class="font-size-btn" id="fontIncrementBtnInFrame">+</button> </div> </div> </div>
    </div>
    <div id="editorArea" contenteditable="true"></div>
    <script>
        const editorArea = document.getElementById('editorArea');
        const jotterMenuBar = document.getElementById('jotterMenuBarInFrame');
        let activeMenu = null;
        const fontDecrementBtn = document.getElementById('fontDecrementBtnInFrame');
        const fontIncrementBtn = document.getElementById('fontIncrementBtnInFrame');
        const fontSizeInput = document.getElementById('fontSizeInputInFrame');
        jotterMenuBar.querySelectorAll('.jotter-menu-bar > .jotter-menu-item').forEach(menuItem => {
            menuItem.addEventListener('click', (event) => {
                event.stopPropagation();
                if (event.target.closest('.font-size-control-container')) {
                    if(!menuItem.classList.contains('open')) { if (activeMenu && activeMenu !== menuItem) activeMenu.classList.remove('open'); menuItem.classList.add('open'); activeMenu = menuItem; } return;
                }
                if (activeMenu && activeMenu !== menuItem) activeMenu.classList.remove('open');
                menuItem.classList.toggle('open'); activeMenu = menuItem.classList.contains('open') ? menuItem : null;
            });
            menuItem.addEventListener('keydown', (event) => { if (event.key === 'Enter' || event.key === ' ') { event.preventDefault(); if (event.target === menuItem || menuItem.contains(event.target) && !event.target.closest('.jotter-dropdown-content .jotter-menu-item')) menuItem.click(); } });
        });
        window.addEventListener('click', (event) => { if (activeMenu && !activeMenu.contains(event.target) && !event.target.closest('.font-size-control-container')) { activeMenu.classList.remove('open'); activeMenu = null; } });
        window.addEventListener('keydown', (event) => { if (event.key === 'Escape' && activeMenu) { activeMenu.classList.remove('open'); activeMenu.focus(); activeMenu = null; } });
        document.getElementById('fileSaveInFrame').addEventListener('click', (event) => { event.stopPropagation(); performSave(); });
        function performSave() {
            let filename = prompt("Filename:", "jotter_content.html");
            if (filename) {
                let htmlContent = \`<!DOCTYPE html><html><head><title>Saved Content</title><meta charset="UTF-8"><style>body { font-family: 'Lucida Console', Monaco, monospace; font-size: \${editorArea.style.fontSize || '14px'}; margin: 20px; white-space: pre-wrap; word-wrap: break-word; }</style></head><body>\${editorArea.innerHTML}</body></html>\`;
                let blob = new Blob([htmlContent], { type: "text/html" }); let url = URL.createObjectURL(blob); let downloadLink = document.createElement("a"); downloadLink.setAttribute("href", url); downloadLink.setAttribute("download", filename); downloadLink.click(); URL.revokeObjectURL(url);
            }
            if (activeMenu) { activeMenu.classList.remove('open'); activeMenu = null; }
        }
        editorArea.addEventListener('keydown', function(e) { if (e.ctrlKey && (e.key === 's' || e.key === 'S')) { e.preventDefault(); performSave(); } });
        window.addEventListener('keydown', function(e) { if (e.ctrlKey && (e.key === 's' || e.key === 'S') && !e.target.closest('#editorArea')) { e.preventDefault(); performSave(); } });
        function applyFontSize(size) { const newSize = Math.max(8, Math.min(72, parseInt(size))); if (!isNaN(newSize)) { editorArea.style.fontSize = newSize + 'px'; fontSizeInput.value = newSize; } }
        fontDecrementBtn.addEventListener('click', (event) => { event.stopPropagation(); let currentSize = parseInt(fontSizeInput.value) || 14; applyFontSize(currentSize - 1); });
        fontIncrementBtn.addEventListener('click', (event) => { event.stopPropagation(); let currentSize = parseInt(fontSizeInput.value) || 14; applyFontSize(currentSize + 1); });
        fontSizeInput.addEventListener('change', () => { applyFontSize(fontSizeInput.value); });
        fontSizeInput.addEventListener('click', (event) => { event.stopPropagation(); });
        fontSizeInput.addEventListener('input', () => { let val = parseInt(fontSizeInput.value); if(!isNaN(val) && val >=8 && val <=72){ editorArea.style.fontSize = val + 'px'; } });
        applyFontSize(fontSizeInput.value); editorArea.focus();
    <\/script>
</body>
</html>`;
    }


    function populateColorSwatches() {
        STANDARD_COLORS.forEach(color => {
            const swatch = document.createElement('div');
            swatch.style.width = '30px';
            swatch.style.height = '30px';
            swatch.style.backgroundColor = color.value;
            swatch.style.border = '1px solid #7F7F7F';
            swatch.style.cursor = 'pointer';
            swatch.title = color.name;
            swatch.dataset.colorValue = color.value;
            swatch.classList.add('color-swatch-item');
            DOM.bgColorSwatchesContainer.appendChild(swatch);
        });
    }

    function bringToFront(windowElement) {
        if (!windowElement) return;
        highestZIndex++;
        windowElement.style.zIndex = highestZIndex;
        const windowId = windowElement.id;
        if (!appData.windowStates[windowId]) appData.windowStates[windowId] = {};
        appData.windowStates[windowId].zIndex = highestZIndex;
    }


    function initWindowInteractions(windowId) {
        const windowElement = getById(windowId);
        let titleBarElement;
        let resizeHandleElement;

        if (windowId === 'xpMainWindow') {
            titleBarElement = DOM.xpMainWindowTitleBar;
            resizeHandleElement = DOM.xpMainWindowResizeHandle;
        } else if (windowId === 'textEditorWindow') {
            titleBarElement = DOM.textEditorWindowTitleBar;
            resizeHandleElement = DOM.textEditorResizeHandle;
        } else if (windowId === 'playJockeyWindow') {
            titleBarElement = DOM.playJockeyTitleBar;
            resizeHandleElement = DOM.playJockeyResizeHandle;
        } else if (windowId === 'geminiChatWindow') {
            titleBarElement = DOM.geminiChatWindowTitleBar;
            resizeHandleElement = DOM.geminiChatResizeHandle;
        } else if (windowId === 'pixelWindow') {
            titleBarElement = DOM.pixelWindowTitleBar;
            resizeHandleElement = DOM.pixelResizeHandle;
        }


        if (!windowElement || !titleBarElement) {
            console.error("Window or TitleBar element not found for ID:", windowId);
            return;
        }

        windowElement.addEventListener('mousedown', (e) => {
             if (e.target.closest('.desktop-icon') || e.target.closest('.context-modal')) return;
            if (e.target === windowElement ||
                (titleBarElement.contains(e.target) && !e.target.closest('button')) ||
                (windowElement.querySelector('.window-body')?.contains(e.target) && !e.target.closest('button, input, select, textarea, .resize-handle, .achievement-item, .xp-button, iframe, #playJockeyPlayer, .playjockey-playlist-item, .playjockey-tab, .gemini-chat-input-area, .gemini-chat-display-area, .gemini-chat-controls-bar, #pixelCanvas, .pixel-tool-button, .pixel-color-picker, .pixel-menu-item'))) {
                 bringToFront(windowElement);
            }
        }, true);

        titleBarElement.addEventListener('mousedown', (e) => {
            if (e.target.closest('button') || windowElement.classList.contains('true-maximized') || activeDragIcon) return;
            activeDragWindow = windowElement;
            dragOffsetX = e.clientX - activeDragWindow.offsetLeft;
            dragOffsetY = e.clientY - activeDragWindow.offsetTop;
            activeDragWindow.classList.add('disable-selection');

            if (windowId === 'textEditorWindow' && DOM.textEditorFrame) {
                DOM.textEditorFrame.style.pointerEvents = 'none';
            }
            if (windowId === 'pixelWindow' && DOM.pixelCanvas) {
                DOM.pixelCanvas.style.pointerEvents = 'none';
            }

            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', stopDragOrResize);
            bringToFront(windowElement);
        });

        if (resizeHandleElement) {
            resizeHandleElement.addEventListener('mousedown', (e) => {
                if (windowElement.classList.contains('true-maximized') || activeDragIcon) return;
                activeResizeWindow = windowElement;
                activeResizeWindow.classList.add('disable-selection');
                resizeInitialX = e.clientX;
                resizeInitialY = e.clientY;
                resizeInitialWidth = activeResizeWindow.offsetWidth;
                resizeInitialHeight = activeResizeWindow.offsetHeight;

                if (windowId === 'textEditorWindow' && DOM.textEditorFrame) {
                    DOM.textEditorFrame.style.pointerEvents = 'none';
                }
                if (windowId === 'pixelWindow' && DOM.pixelCanvas) {
                    DOM.pixelCanvas.style.pointerEvents = 'none';
                }
                document.addEventListener('mousemove', doResize);
                document.addEventListener('mouseup', stopDragOrResize);
                bringToFront(windowElement);
            });
        }
    }

    function doDrag(e) {
        if (!activeDragWindow) return;

        let newLeft = e.clientX - dragOffsetX;
        let newTop = e.clientY - dragOffsetY;

        const windowWidth = activeDragWindow.offsetWidth;
        const windowHeight = activeDragWindow.offsetHeight;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        newLeft = Math.max(0, newLeft);
        newTop = Math.max(0, newTop);
        newLeft = Math.min(newLeft, viewportWidth - windowWidth);
        newTop = Math.min(newTop, viewportHeight - windowHeight);

        activeDragWindow.style.left = newLeft + 'px';
        activeDragWindow.style.top = newTop + 'px';

        if (appData.windowStates[activeDragWindow.id]) {
            appData.windowStates[activeDragWindow.id].userManuallySet = true;
        }
    }

    function doResize(e) {
        if (!activeResizeWindow) return;
        const windowId = activeResizeWindow.id;
        let currentMinWidth, currentMinHeight;

        if (windowId === 'xpMainWindow') {
            currentMinWidth = minTrackerAppWidth;
            currentMinHeight = MIN_TRACKER_APP_HEIGHT;
        } else if (windowId === 'textEditorWindow') {
            currentMinWidth = MIN_TEXTEDITOR_WIDTH;
            currentMinHeight = MIN_TEXTEDITOR_HEIGHT;
        } else if (windowId === 'playJockeyWindow') {
            currentMinWidth = MIN_PLAYJOCKEY_WIDTH;
            currentMinHeight = MIN_PLAYJOCKEY_HEIGHT;
        } else if (windowId === 'geminiChatWindow') {
            currentMinWidth = MIN_GEMINI_CHAT_WIDTH;
            currentMinHeight = MIN_GEMINI_CHAT_HEIGHT;
        } else if (windowId === 'pixelWindow') {
            currentMinWidth = MIN_PIXEL_WIDTH;
            currentMinHeight = MIN_PIXEL_HEIGHT;
        } else {
            return;
        }


        let newWidth = resizeInitialWidth + (e.clientX - resizeInitialX);
        let newHeight = resizeInitialHeight + (e.clientY - resizeInitialY);
        activeResizeWindow.style.width = Math.max(currentMinWidth, newWidth) + 'px';
        activeResizeWindow.style.height = Math.max(currentMinHeight, newHeight) + 'px';

        if (appData.windowStates[windowId]) {
            appData.windowStates[windowId].userManuallySet = true;
        }
        if (windowId === 'xpMainWindow') {
            handleAppWindowResize();
        }
        if (windowId === 'pixelWindow') {
            handlePixelWindowResize();
        }
    }

    function stopDragOrResize() {
        let windowToSaveState = null;
        let operatedWindow = null;

        if (activeDragWindow) {
            activeDragWindow.classList.remove('disable-selection');
            windowToSaveState = activeDragWindow.id;
            operatedWindow = activeDragWindow;
            activeDragWindow = null;
        }
        if (activeResizeWindow) {
            activeResizeWindow.classList.remove('disable-selection');
            windowToSaveState = activeResizeWindow.id;
            operatedWindow = activeResizeWindow;
            activeResizeWindow = null;
        }

        if (operatedWindow && operatedWindow.id === 'textEditorWindow' && DOM.textEditorFrame) {
            DOM.textEditorFrame.style.pointerEvents = 'auto';
        }
        if (operatedWindow && operatedWindow.id === 'pixelWindow' && DOM.pixelCanvas) {
            DOM.pixelCanvas.style.pointerEvents = 'auto';
        }


        if (windowToSaveState) {
            saveWindowState(windowToSaveState);
        }

        document.removeEventListener('mousemove', doDrag);
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', stopDragOrResize);
    }


    function setWindowDefaults(windowId, isBrowserResize = false) {
        const appWindow = getById(windowId);
        if (!appWindow || appWindow.classList.contains('minimized')) return;

        if (appWindow.classList.contains('true-maximized') && !isBrowserResize) {
            appWindow.style.width = '100vw';
            appWindow.style.height = '100vh';
            appWindow.style.top = '0px';
            appWindow.style.left = '0px';
            return;
        }

        const state = appData.windowStates[windowId];
        if (!state) {
            console.error(`State missing for ${windowId} in setWindowDefaults`);
            return;
        }

        const hasValidSavedSize = state.width && state.width > 0 && state.height && state.height > 0;
        const hasValidSavedPosition = state.x != null && state.y != null;

        let currentMinWidth, currentMinHeight, defaultWidth, defaultHeight, defaultOffsetX, defaultOffsetY;

        if (windowId === 'xpMainWindow') {
            currentMinWidth = minTrackerAppWidth; currentMinHeight = MIN_TRACKER_APP_HEIGHT;
            defaultWidth = 905; defaultHeight = 705;
            defaultOffsetX = 0; defaultOffsetY = 0;
        } else if (windowId === 'textEditorWindow') {
            currentMinWidth = MIN_TEXTEDITOR_WIDTH; currentMinHeight = MIN_TEXTEDITOR_HEIGHT;
            defaultWidth = 450; defaultHeight = 705;
            defaultOffsetX = 50; defaultOffsetY = 50;
        } else if (windowId === 'playJockeyWindow') {
            currentMinWidth = MIN_PLAYJOCKEY_WIDTH; currentMinHeight = MIN_PLAYJOCKEY_HEIGHT;
            defaultWidth = 480; defaultHeight = 705;
            defaultOffsetX = 100; defaultOffsetY = 100;
        } else if (windowId === 'geminiChatWindow') {
            currentMinWidth = MIN_GEMINI_CHAT_WIDTH; currentMinHeight = MIN_GEMINI_CHAT_HEIGHT;
            defaultWidth = 450; defaultHeight = 705;
            defaultOffsetX = 150; defaultOffsetY = 150;
        } else if (windowId === 'pixelWindow') {
            currentMinWidth = MIN_PIXEL_WIDTH; currentMinHeight = MIN_PIXEL_HEIGHT;
            defaultWidth = 650; defaultHeight = 500;
            defaultOffsetX = 200; defaultOffsetY = 200;
        } else {
            return;
        }

        if (isBrowserResize || !state.userManuallySet || !hasValidSavedSize || !hasValidSavedPosition) {
            let newWidth = defaultWidth;
            let newHeight = defaultHeight;

            newWidth = Math.max(currentMinWidth, newWidth);
            newHeight = Math.max(currentMinHeight, newHeight);

            let newLeft = (defaultOffsetX === 0 && window.innerWidth > newWidth) ? (window.innerWidth - newWidth) / 2 : defaultOffsetX;
            let newTop = (defaultOffsetY === 0 && window.innerHeight > newHeight) ? (window.innerHeight - newHeight) / 2 : defaultOffsetY;

            newTop = Math.max(10, Math.min(newTop, window.innerHeight - newHeight - 10));
            newLeft = Math.max(10, Math.min(newLeft, window.innerWidth - newWidth - 10));
            if (window.innerHeight <= newHeight + 20) newTop = 10;
            if (window.innerWidth <= newWidth + 20) newLeft = 10;

            appWindow.style.width = newWidth + 'px';
            appWindow.style.height = newHeight + 'px';
            appWindow.style.left = newLeft + 'px';
            appWindow.style.top = newTop + 'px';

            state.width = newWidth;
            state.height = newHeight;
            state.x = newLeft;
            state.y = newTop;
            state.userManuallySet = false;
        }
    }


    function handleAppWindowResize() {
        if (DOM.xpMainWindow.classList.contains('minimized') || DOM.xpMainWindow.style.display === 'none') return;
        checkControlsBarLayout();
        checkToggleDayView();
    }

    function checkControlsBarLayout() {
        const controlsBar = DOM.controlsBar;
        if (!controlsBar || !controlsBar.clientWidth) return;

        const children = [
            controlsBar.querySelector('.week-navigation'),
            controlsBar.querySelector('.controls-group'),
            controlsBar.querySelector('.global-actions')
        ].filter(el => el);

        if (children.length === 0) return;

        const originalClasses = controlsBar.className;
        controlsBar.className = 'controls-bar layout-single-row';

        let totalChildrenWidth = 0;
        children.forEach(child => {
            const childStyle = getComputedStyle(child);
            totalChildrenWidth += child.scrollWidth + parseFloat(childStyle.marginLeft) + parseFloat(childStyle.marginRight);
        });

        controlsBar.className = originalClasses;

        const controlsBarClientWidth = controlsBar.clientWidth - (parseFloat(getComputedStyle(controlsBar).paddingLeft) + parseFloat(getComputedStyle(controlsBar).paddingRight));

        if (totalChildrenWidth > controlsBarClientWidth && controlsBarClientWidth > 0) {
            controlsBar.classList.add('layout-multi-row');
            controlsBar.classList.remove('layout-single-row');
        } else {
            controlsBar.classList.add('layout-single-row');
            controlsBar.classList.remove('layout-multi-row');
        }
    }


    function checkToggleDayView() { }


    function addEventListeners() {
        document.body.addEventListener('contextmenu', function(event) {
            if (event.target === document.body) {
                event.preventDefault();
                DOM.newBgImageInput.value = null;
                DOM.bgImageUrlInput.value = '';
                openModal(MODAL_IDS.CHANGE_BG_IMAGE);
            }
        });

        DOM.uploadBgImageBtn.addEventListener('click', function() {
            const file = DOM.newBgImageInput.files[0];
            if (file) {
                if (file.size > 5 * 1024 * 1024) {
                    alert("Image file is large (over 5MB). This might exceed browser storage limits when saved. Try a smaller file or use the URL option for large images.");
                }
                const reader = new FileReader();
                reader.onloadend = function() {
                    document.body.style.backgroundColor = '';
                    document.body.style.backgroundImage = `url('${reader.result}')`;
                    appData.customBgImage = reader.result;
                    appData.customBgColor = null;
                    saveData();
                    closeModal(MODAL_IDS.CHANGE_BG_IMAGE);
                }
                reader.onerror = function() {
                    alert("Error reading image file.");
                }
                reader.readAsDataURL(file);
            } else {
                alert("Please select an image file first.");
            }
        });

        DOM.applyBgImageUrlBtn.addEventListener('click', function() {
            const imageUrl = DOM.bgImageUrlInput.value.trim();
            if (imageUrl) {
                try {
                    new URL(imageUrl);
                    document.body.style.backgroundColor = '';
                    document.body.style.backgroundImage = `url('${imageUrl}')`;
                    appData.customBgImage = imageUrl;
                    appData.customBgColor = null;
                    saveData();
                    closeModal(MODAL_IDS.CHANGE_BG_IMAGE);
                } catch (e) {
                    alert("Invalid image URL provided. Please enter a complete and valid URL (e.g., https://example.com/image.png).");
                }
            } else {
                alert("Please enter an image URL.");
            }
        });

        DOM.bgColorSwatchesContainer.addEventListener('click', function(event) {
            if (event.target.classList.contains('color-swatch-item')) {
                const selectedColor = event.target.dataset.colorValue;
                if (selectedColor) {
                    document.body.style.backgroundImage = 'none';
                    document.body.style.backgroundColor = selectedColor;

                    appData.customBgColor = selectedColor;
                    appData.customBgImage = null;
                    saveData();
                    closeModal(MODAL_IDS.CHANGE_BG_IMAGE);
                }
            }
        });


        DOM.gridBody.addEventListener('click', function(event) {
            const target = event.target;
            if (target.classList.contains('delete-area-btn')) {
                const areaName = target.dataset.areaName;
                if (areaName) promptRemoveArea(areaName);
            } else if (target.classList.contains('edit-ach-btn')) {
                const achKey = target.dataset.achKey;
                const achId = target.dataset.achId;
                openAddEditAchievementModal(null, null, achKey, achId);
            } else if (target.classList.contains('remove-ach-btn')) {
                const achKey = target.dataset.achKey;
                const achId = target.dataset.achId;
                promptRemoveAchievement(achKey, achId);
            } else if (target.classList.contains('achievement-add-btn-cell')) {
                const areaName = target.dataset.areaName;
                const dayIndex = parseInt(target.dataset.dayIndex);
                openAddEditAchievementModal(areaName, dayIndex);
            }
        });

        DOM.addAreaBtn.addEventListener('click', () => openModal(MODAL_IDS.NEW_AREA));
        DOM.saveNewAreaBtn.addEventListener('click', saveNewArea);
        DOM.newAreaNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveNewArea();
        });

        DOM.saveAchievementBtn.addEventListener('click', saveOrUpdateAchievement);
        DOM.achievementTypeRadios.forEach(radio => {
            radio.addEventListener('change', toggleAchievementInputType);
        });

        DOM.prevWeekBtn.addEventListener('click', () => {
            if (appData.viewMode === 'week') navigateWeek(-7);
            else navigateDay(-1);
        });
        DOM.nextWeekBtn.addEventListener('click', () => {
            if (appData.viewMode === 'week') navigateWeek(7);
            else navigateDay(1);
        });
        DOM.thisWeekBtn.addEventListener('click', goToThisWeek);
        DOM.toggleViewBtn.addEventListener('click', toggleViewMode);

        DOM.showQuestsBtn.addEventListener('click', showQuests);
        DOM.addQuestBtn.addEventListener('click', openCreateQuestModal);
        DOM.saveNewQuestBtn.addEventListener('click', saveNewQuest);

        DOM.questsList.addEventListener('click', function(event) {
            if (event.target.classList.contains('refresh-quest-btn')) {
                const questId = event.target.dataset.questId;
                promptRefreshQuest(questId);
            }
        });
        DOM.confirmRefreshQuestBtn.addEventListener('click', confirmAndRefreshQuest);

        DOM.xpMainWindowMinimizeBtn.addEventListener('click', () => minimizeWindow('xpMainWindow'));
        DOM.xpMainWindowMaximizeBtn.addEventListener('click', () => maximizeWindow('xpMainWindow'));
        DOM.xpMainWindowCloseBtn.addEventListener('click', () => {
            const win = DOM.xpMainWindow;
            const windowId = 'xpMainWindow';
            let state = appData.windowStates[windowId];
            if (state) {
                state.hiddenByUser = true;
            }
            saveWindowState(windowId);
            win.style.display = 'none';
        });

        DOM.textEditorMinimizeBtn.addEventListener('click', () => minimizeWindow('textEditorWindow'));
        DOM.textEditorMaximizeBtn.addEventListener('click', () => maximizeWindow('textEditorWindow'));
        DOM.textEditorCloseBtn.addEventListener('click', () => {
            const win = DOM.textEditorWindow;
            const windowId = 'textEditorWindow';
            let state = appData.windowStates[windowId];
            if (state) {
                state.hiddenByUser = true;
            }
            saveWindowState(windowId);
            win.style.display = 'none';
        });

        DOM.playJockeyMinimizeBtn.addEventListener('click', () => minimizeWindow('playJockeyWindow'));
        DOM.playJockeyMaximizeBtn.addEventListener('click', () => maximizeWindow('playJockeyWindow'));
        DOM.playJockeyCloseBtn.addEventListener('click', () => {
            const win = DOM.playJockeyWindow;
            const windowId = 'playJockeyWindow';
            let state = appData.windowStates[windowId];
            if (state) {
                state.hiddenByUser = true;
            }

            if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                ytPlayerInstance.stopVideo();
            }
            saveWindowState(windowId);
            win.style.display = 'none';
        });

        DOM.geminiChatMinimizeBtn.addEventListener('click', () => minimizeWindow('geminiChatWindow'));
        DOM.geminiChatMaximizeBtn.addEventListener('click', () => maximizeWindow('geminiChatWindow'));
        DOM.geminiChatCloseBtn.addEventListener('click', () => {
            const win = DOM.geminiChatWindow;
            const windowId = 'geminiChatWindow';
            let state = appData.windowStates[windowId];
            if (state) {
                state.hiddenByUser = true;
            }
            saveWindowState(windowId);
            win.style.display = 'none';
        });

        DOM.pixelMinimizeBtn.addEventListener('click', () => minimizeWindow('pixelWindow'));
        DOM.pixelMaximizeBtn.addEventListener('click', () => maximizeWindow('pixelWindow'));
        DOM.pixelCloseBtn.addEventListener('click', () => {
            const win = DOM.pixelWindow;
            const windowId = 'pixelWindow';
            let state = appData.windowStates[windowId];
            if (state) {
                state.hiddenByUser = true;
            }
            saveWindowState(windowId);
            win.style.display = 'none';
        });


        DOM.geminiChatSendBtn.addEventListener('click', handleSendGeminiPrompt);
        DOM.geminiChatPromptInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSendGeminiPrompt();
            }
        });
        DOM.geminiChatClearHistoryBtn.addEventListener('click', handleClearGeminiChatHistory);
        DOM.confirmClearChatBtn.addEventListener('click', confirmClearChat);

        DOM.playJockeyAddBtn.addEventListener('click', handlePlayJockeyInput);
        DOM.playJockeyLinkInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handlePlayJockeyInput();
        });

        DOM.playJockeyPlaylist.addEventListener('dragstart', handlePjDragStart);
        DOM.playJockeyPlaylist.addEventListener('dragend', handlePjDragEnd);
        DOM.playJockeyPlaylist.addEventListener('dragover', handlePjDragOver);
        DOM.playJockeyPlaylist.addEventListener('dragleave', handlePjDragLeave);
        DOM.playJockeyPlaylist.addEventListener('drop', handlePjDrop);
        DOM.playJockeyPlaylist.addEventListener('contextmenu', showPjContextMenu);

        DOM.playJockeyRandomBtn.addEventListener('click', togglePlayJockeyRandom);
        DOM.playJockeyAutoPlayBtn.addEventListener('click', togglePlayJockeyAutoPlay);
        DOM.playJockeyRepeatBtn.addEventListener('click', cyclePlayJockeyRepeat);

        DOM.modalCloseButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                const modalId = event.target.dataset.modalId || event.target.closest('.modal').id;
                if (modalId) closeModal(modalId);
            });
        });

        DOM.confirmRemoveBtn.addEventListener('click', function() {
            const areaNameToRemove = this.dataset.areaNameToRemove;
            if (areaNameToRemove) {
                removeArea(areaNameToRemove);
                closeModal(MODAL_IDS.CONFIRM_REMOVE_AREA);
                delete this.dataset.areaNameToRemove;
            }
        });

        DOM.confirmDeleteAchievementBtn.addEventListener('click', function() {
            const key = this.dataset.achievementKey;
            const id = this.dataset.achievementId;
            if (key && id) {
                confirmRemoveAchievement(key, id);
            }
        });

        DOM.saveRenamedPlaylistBtn.addEventListener('click', saveRenamedPlaylist);
        DOM.playlistNewNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveRenamedPlaylist();
        });
        DOM.confirmFinalPlaylistRemoveBtn.addEventListener('click', executePlaylistDeletion);

        DOM.saveRenamedTrackBtn.addEventListener('click', saveRenamedTrack);
        DOM.trackNewNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') DOM.saveRenamedTrackBtn.click();});
        DOM.trackNewArtistInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') DOM.saveRenamedTrackBtn.click();});
        DOM.confirmFinalTrackRemoveBtn.addEventListener('click', executeTrackDeletion);

        DOM.pixelFileCanvasSize.addEventListener('click', openPixelCanvasSizeModal);
        DOM.savePixelCanvasSizeBtn.addEventListener('click', handleSavePixelCanvasSize);
        DOM.confirmPixelResizeBtn.addEventListener('click', executePixelCanvasResize);


        window.addEventListener('resize', () => {
            setWindowDefaults('xpMainWindow', true);
            setWindowDefaults('textEditorWindow', true);
            setWindowDefaults('playJockeyWindow', true);
            setWindowDefaults('geminiChatWindow', true);
            setWindowDefaults('pixelWindow', true);
            saveData();
        });

        document.addEventListener('click', (e) => {
            if (DOM.playJockeyContextMenu.style.display === 'block' && !DOM.playJockeyContextMenu.contains(e.target) && !e.target.closest('.playjockey-playlist-item')) {
                hidePjContextMenu();
            }
            if (DOM.playJockeyTabContextMenu.style.display === 'block' && !DOM.playJockeyTabContextMenu.contains(e.target) && !e.target.closest('.playjockey-tab')) {
                hidePjTabContextMenu();
            }
        });
    }

    function minimizeWindow(windowId) {
        const appWindow = getById(windowId);
        if (!appWindow || appWindow.classList.contains('minimized')) return;

        const state = appData.windowStates[windowId];
        if (!state) { console.error(`State missing for ${windowId} in minimizeWindow`); return; }

        state.minimized = true;

        if (appWindow.classList.contains('true-maximized')) {
            state.wasMaximizedBeforeMinimize = true;
            if (lastNormalStates[windowId]) {
                state.width = parseInt(lastNormalStates[windowId].width);
                state.height = parseInt(lastNormalStates[windowId].height);
                state.x = parseInt(lastNormalStates[windowId].left);
                state.y = parseInt(lastNormalStates[windowId].top);
            } else {
                console.warn(`lastNormalStates missing for ${windowId} during minimize from maximized.`);
            }
        } else {
            state.wasMaximizedBeforeMinimize = false;
            state.width = appWindow.offsetWidth;
            state.height = appWindow.offsetHeight;
            state.x = appWindow.offsetLeft;
            state.y = appWindow.offsetTop;
        }
        appWindow.classList.remove('true-maximized');
        appWindow.classList.add('minimized');

        updateMinMaxButtonStates(windowId);
        saveWindowState(windowId);
    }

    function maximizeWindow(windowId) {
        const appWindow = getById(windowId);
        if (!appWindow) return;

        const state = appData.windowStates[windowId];
        if (!state) { console.error(`State missing for ${windowId} in maximizeWindow`); return; }

        const isMinimized = appWindow.classList.contains('minimized');
        let currentLastNormal = lastNormalStates[windowId] || {};

        if (isMinimized) {
            appWindow.classList.remove('minimized');
            state.minimized = false;
            const wasMaximized = state.wasMaximizedBeforeMinimize;
            delete state.wasMaximizedBeforeMinimize;

            if (wasMaximized) {
                appWindow.style.width = '100vw';
                appWindow.style.height = '100vh';
                appWindow.style.top = '0px';
                appWindow.style.left = '0px';
                appWindow.classList.add('true-maximized');
                state.maximized = true;
            } else {
                let minW, minH;
                if (windowId === 'xpMainWindow') { minW = minTrackerAppWidth; minH = MIN_TRACKER_APP_HEIGHT;}
                else if (windowId === 'textEditorWindow') { minW = MIN_TEXTEDITOR_WIDTH; minH = MIN_TEXTEDITOR_HEIGHT;}
                else if (windowId === 'playJockeyWindow') { minW = MIN_PLAYJOCKEY_WIDTH; minH = MIN_PLAYJOCKEY_HEIGHT;}
                else if (windowId === 'geminiChatWindow') { minW = MIN_GEMINI_CHAT_WIDTH; minH = MIN_GEMINI_CHAT_HEIGHT;}
                else if (windowId === 'pixelWindow') { minW = MIN_PIXEL_WIDTH; minH = MIN_PIXEL_HEIGHT;}


                appWindow.style.width = Math.max(minW, state.width || parseInt(currentLastNormal.width) || 0) + 'px';
                appWindow.style.height = Math.max(minH, state.height || parseInt(currentLastNormal.height) || 0) + 'px';
                appWindow.style.left = (state.x || parseInt(currentLastNormal.left) || 0) + 'px';
                appWindow.style.top = (state.y || parseInt(currentLastNormal.top) || 0) + 'px';
                state.maximized = false;
            }
        } else if (appWindow.classList.contains('true-maximized')) {
            if (currentLastNormal.width && currentLastNormal.height) {
                appWindow.style.width = currentLastNormal.width;
                appWindow.style.height = currentLastNormal.height;
                appWindow.style.top = currentLastNormal.top;
                appWindow.style.left = currentLastNormal.left;
                state.width = parseInt(currentLastNormal.width);
                state.height = parseInt(currentLastNormal.height);
                state.x = parseInt(currentLastNormal.left);
                state.y = parseInt(currentLastNormal.top);
            } else {
                setWindowDefaults(windowId, false);
            }
            appWindow.classList.remove('true-maximized');
            state.maximized = false;
            state.userManuallySet = true;
        } else {
            lastNormalStates[windowId] = {
                width: appWindow.style.width || (appWindow.offsetWidth + 'px'),
                height: appWindow.style.height || (appWindow.offsetHeight + 'px'),
                top: appWindow.style.top || (appWindow.offsetTop + 'px'),
                left: appWindow.style.left || (appWindow.offsetLeft + 'px')
            };

            appWindow.style.width = '100vw';
            appWindow.style.height = '100vh';
            appWindow.style.top = '0px';
            appWindow.style.left = '0px';
            appWindow.classList.add('true-maximized');
            state.maximized = true;
            state.userManuallySet = false;
        }

        updateMinMaxButtonStates(windowId);
        saveWindowState(windowId);
        if (windowId === 'xpMainWindow' && !isMinimized) handleAppWindowResize();
        if (windowId === 'pixelWindow' && !isMinimized) handlePixelWindowResize();
    }


    function updateMinMaxButtonStates(windowId) {
        const win = getById(windowId);
        let minimizeBtn, maximizeBtn;

        if (windowId === 'xpMainWindow') {
            minimizeBtn = DOM.xpMainWindowMinimizeBtn;
            maximizeBtn = DOM.xpMainWindowMaximizeBtn;
        } else if (windowId === 'textEditorWindow') {
            minimizeBtn = DOM.textEditorMinimizeBtn;
            maximizeBtn = DOM.textEditorMaximizeBtn;
        } else if (windowId === 'playJockeyWindow') {
            minimizeBtn = DOM.playJockeyMinimizeBtn;
            maximizeBtn = DOM.playJockeyMaximizeBtn;
        } else if (windowId === 'geminiChatWindow') {
            minimizeBtn = DOM.geminiChatMinimizeBtn;
            maximizeBtn = DOM.geminiChatMaximizeBtn;
        } else if (windowId === 'pixelWindow') {
            minimizeBtn = DOM.pixelMinimizeBtn;
            maximizeBtn = DOM.pixelMaximizeBtn;
        }


        if (!win || !minimizeBtn || !maximizeBtn) return;

        const isMinimized = win.classList.contains('minimized');
        const isTrueMaximized = win.classList.contains('true-maximized');

        minimizeBtn.disabled = isMinimized;
        maximizeBtn.disabled = false;

        if (isMinimized) {
            maximizeBtn.textContent = '1';
            maximizeBtn.title = "Restore";
        } else if (isTrueMaximized) {
            maximizeBtn.textContent = '2';
            maximizeBtn.title = "Restore Down";
        } else {
            maximizeBtn.textContent = '1';
            maximizeBtn.title = "Maximize";
        }
    }

    function updateViewControls() {
        if (appData.viewMode === 'week') {
            DOM.toggleViewBtn.textContent = 'Day View';
            DOM.prevWeekBtn.textContent = '< Prev Week';
            DOM.nextWeekBtn.textContent = 'Next Week >';
            DOM.thisWeekBtn.textContent = 'This Week';
        } else {
            DOM.toggleViewBtn.textContent = 'Week View';
            DOM.prevWeekBtn.textContent = '< Prev Day';
            DOM.nextWeekBtn.textContent = 'Next Day >';
            DOM.thisWeekBtn.textContent = 'Today';
        }
    }

    function saveWindowState(windowId) {
        const win = getById(windowId);
        if (!win) return;

        let state = appData.windowStates[windowId];
        if (!state) {
            console.warn(`Window state for ${windowId} was missing during saveWindowState. Re-initializing.`);
            appData.windowStates[windowId] = {};
            state = appData.windowStates[windowId];
            state.hiddenByUser = (win.style.display === 'none');
            state.minimized = win.classList.contains('minimized');
            state.maximized = win.classList.contains('true-maximized');
            state.userManuallySet = false;
        }

        state.minimized = win.classList.contains('minimized');
        state.maximized = win.classList.contains('true-maximized');
        state.zIndex = parseInt(win.style.zIndex) || highestZIndex;
        if (!state.minimized && !state.maximized) {
            state.x = win.offsetLeft;
            state.y = win.offsetTop;
            state.width = win.offsetWidth;
            state.height = win.offsetHeight;
        }
        saveData();
    }


    function restoreWindowState(windowId) {
        const win = getById(windowId);
        if (!win) {
            console.error(`Window element ${windowId} not found for restore.`);
            return;
        }

        let state = appData.windowStates[windowId];
        const defaultStateTemplate = (defaultAppData.windowStates && defaultAppData.windowStates[windowId]) || {
            x: null, y: null, width: null, height: null,
            maximized: false, minimized: false, zIndex: highestZIndex + 1, userManuallySet: false,
            hiddenByUser: true
        };

        if (!state) {
            appData.windowStates[windowId] = { ...defaultStateTemplate };
            state = appData.windowStates[windowId];
        } else {
            state = {
                ...defaultStateTemplate,
                ...state,
                minimized: state.minimized === undefined ? defaultStateTemplate.minimized : state.minimized,
                maximized: state.maximized === undefined ? defaultStateTemplate.maximized : state.maximized,
                hiddenByUser: state.hiddenByUser === undefined ? defaultStateTemplate.hiddenByUser : state.hiddenByUser,
                userManuallySet: state.userManuallySet === undefined ? defaultStateTemplate.userManuallySet : state.userManuallySet,
                zIndex: parseInt(state.zIndex) || defaultStateTemplate.zIndex
            };
            appData.windowStates[windowId] = state;
        }

        if (state.hiddenByUser) {
            win.style.display = 'none';
        } else {
            win.style.display = 'flex';
        }
        const isNowVisible = win.style.display === 'flex';

        let loadedZ = state.zIndex;
        if (loadedZ <= 5 && windowId !== 'desktop-icon') loadedZ = highestZIndex + 1;
        win.style.zIndex = loadedZ;
        state.zIndex = loadedZ;
        highestZIndex = Math.max(highestZIndex, loadedZ);

        if (state.minimized) {
            win.classList.add('minimized');
            win.classList.remove('true-maximized');
        } else if (state.maximized) {
            win.classList.add('true-maximized');
            win.classList.remove('minimized');
            win.style.width = '100vw';
            win.style.height = '100vh';
            win.style.top = '0px';
            win.style.left = '0px';

            let minW, minH, defaultNormalWidth, defaultNormalHeight, defaultX, defaultY;
            if (windowId === 'xpMainWindow') { defaultNormalWidth = 905; defaultNormalHeight = 705; minW = minTrackerAppWidth; minH = MIN_TRACKER_APP_HEIGHT; defaultX = (window.innerWidth - defaultNormalWidth)/2; defaultY = 20;}
            else if (windowId === 'textEditorWindow') { defaultNormalWidth = 450; defaultNormalHeight = 705; minW = MIN_TEXTEDITOR_WIDTH; minH = MIN_TEXTEDITOR_HEIGHT; defaultX = 50; defaultY = 50;}
            else if (windowId === 'playJockeyWindow') { defaultNormalWidth = 480; defaultNormalHeight = 705; minW = MIN_PLAYJOCKEY_WIDTH; minH = MIN_PLAYJOCKEY_HEIGHT; defaultX = 100; defaultY = 100;}
            else if (windowId === 'geminiChatWindow') { defaultNormalWidth = 500; defaultNormalHeight = 400; minW = MIN_GEMINI_CHAT_WIDTH; minH = MIN_GEMINI_CHAT_HEIGHT; defaultX = 150; defaultY = 150;}
            else if (windowId === 'pixelWindow') { defaultNormalWidth = 650; defaultNormalHeight = 500; minW = MIN_PIXEL_WIDTH; minH = MIN_PIXEL_HEIGHT; defaultX = 200; defaultY = 200;}


            lastNormalStates[windowId] = {
                width: (state.width ? Math.max(minW, state.width) : defaultNormalWidth) + 'px',
                height: (state.height ? Math.max(minH, state.height) : defaultNormalHeight) + 'px',
                top: (state.y != null ? state.y : defaultY) + 'px',
                left: (state.x != null ? state.x : defaultX) + 'px'
            };
        } else {
            win.classList.remove('minimized');
            win.classList.remove('true-maximized');

            if (state.userManuallySet && state.width != null && state.height != null && state.x != null && state.y != null) {
                let currentMinWidth, currentMinHeight;
                if (windowId === 'xpMainWindow') { currentMinWidth = minTrackerAppWidth; currentMinHeight = MIN_TRACKER_APP_HEIGHT; }
                else if (windowId === 'textEditorWindow') { currentMinWidth = MIN_TEXTEDITOR_WIDTH; currentMinHeight = MIN_TEXTEDITOR_HEIGHT; }
                else if (windowId === 'playJockeyWindow') { currentMinWidth = MIN_PLAYJOCKEY_WIDTH; currentMinHeight = MIN_PLAYJOCKEY_HEIGHT; }
                else if (windowId === 'geminiChatWindow') { currentMinWidth = MIN_GEMINI_CHAT_WIDTH; currentMinHeight = MIN_GEMINI_CHAT_HEIGHT; }
                else if (windowId === 'pixelWindow') { currentMinWidth = MIN_PIXEL_WIDTH; currentMinHeight = MIN_PIXEL_HEIGHT; }
                else { currentMinWidth = 100; currentMinHeight = 100; }

                win.style.left = state.x + 'px';
                win.style.top = state.y + 'px';
                win.style.width = Math.max(currentMinWidth, state.width) + 'px';
                win.style.height = Math.max(currentMinHeight, state.height) + 'px';
            } else {
                if (!state.hiddenByUser) {
                    setWindowDefaults(windowId, false);
                }
            }
        }

        if (isNowVisible && windowId === 'geminiChatWindow') {
            renderGeminiChatHistory();
        }
        if (isNowVisible && windowId === 'pixelWindow') {
            handlePixelWindowResize();
        }
        updateMinMaxButtonStates(windowId);
    }


    function saveData() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(appData));
        } catch (error) {
            console.error("Error saving data to localStorage:", error);
            if (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED') {
                alert("Could not save data: Storage limit exceeded. This might be due to a very large background image from file upload. Try a smaller file or use the URL option for large images.");
            }
        }
    }

    function loadData() {
        const storedData = localStorage.getItem(STORAGE_KEY);
        const defaultPlaylistId = 'playlist_default_0';

        defaultAppData = {
            viewMode: 'week',
            selectedDayIndex: 0,
            windowStates: {
                xpMainWindow: { x: null, y: null, width: 905, height: 705, maximized: false, minimized: false, zIndex: 11, userManuallySet: false, hiddenByUser: false },
                textEditorWindow: { x: null, y: null, width: 450, height: 705, maximized: false, minimized: false, zIndex: 10, userManuallySet: false, hiddenByUser: false },
                playJockeyWindow: { x: null, y: null, width: 480, height: 705, maximized: false, minimized: false, zIndex: 9, userManuallySet: false, hiddenByUser: true },
                geminiChatWindow: { x: null, y: null, width: 450, height: 705, maximized: false, minimized: false, zIndex: 8, userManuallySet: false, hiddenByUser: true },
                pixelWindow: { x: null, y: null, width: 650, height: 500, maximized: false, minimized: false, zIndex: 7, userManuallySet: false, hiddenByUser: true }
            },
            iconPositions: {
                trackerIcon: { x: 0, y: 0 },
                textEditorIcon: { x: 0, y: 100 },
                playJockeyIcon: { x: 0, y: 200 },
                geminiChatIcon: { x: 0, y: 300 },
                pixelIcon: { x: 0, y: 400 }
            },
            areas: [],
            achievements: {},
            quests: {},
            currentWeekStartDate: null,
            customBgImage: null,
            customBgColor: null,
            playJockeyPlaylists: [{id: defaultPlaylistId, name: "Playlist", videos: []}],
            playJockeyCurrentPlaylistId: defaultPlaylistId,
            playJockeyCurrentVideo: null,
            playJockeyAutoPlayEnabled: true,
            playJockeyRandomEnabled: false,
            playJockeyRepeatState: "off",
            playJockeyRandomHistory: [],
            geminiChatHistory: [],
            pixelAppData: {
                currentColor: '#000000',
                currentTool: 'pencil',
                pencilSize: 2,
                canvasWidth: 600,
                canvasHeight: 400
            }
        };

        if (storedData) {
            try {
                const loadedData = JSON.parse(storedData);
                appData = {
                    ...defaultAppData,
                    ...loadedData,
                    windowStates: {
                        xpMainWindow: { ...defaultAppData.windowStates.xpMainWindow, ...(loadedData.windowStates ? loadedData.windowStates.xpMainWindow : {}) },
                        textEditorWindow: { ...defaultAppData.windowStates.textEditorWindow, ...(loadedData.windowStates ? loadedData.windowStates.textEditorWindow : {}) },
                        playJockeyWindow: { ...defaultAppData.windowStates.playJockeyWindow, ...(loadedData.windowStates ? loadedData.windowStates.playJockeyWindow : {}) },
                        geminiChatWindow: { ...defaultAppData.windowStates.geminiChatWindow, ...(loadedData.windowStates ? loadedData.windowStates.geminiChatWindow : {}) },
                        pixelWindow: { ...defaultAppData.windowStates.pixelWindow, ...(loadedData.windowStates ? loadedData.windowStates.pixelWindow : {}) }
                    },

                    iconPositions: { ...defaultAppData.iconPositions, ...(loadedData.iconPositions || {}), pixelIcon: (loadedData.iconPositions && loadedData.iconPositions.pixelIcon) ? loadedData.iconPositions.pixelIcon : defaultAppData.iconPositions.pixelIcon },
                    playJockeyPlaylists: (loadedData.playJockeyPlaylists && loadedData.playJockeyPlaylists.length > 0)
                        ? loadedData.playJockeyPlaylists.map(pl => ({
                            ...pl,
                            videos: (pl.videos || []).map(video => ({
                                ...video,
                                title: video.title ? decodeHtmlEntities(video.title) : (video.originalUrl ? decodeHtmlEntities(video.originalUrl) : "Unknown Title"),
                                artist: video.artist ? decodeHtmlEntities(video.artist) : ""
                            }))
                          }))
                        : [{id: defaultPlaylistId, name: "Playlist", videos: []}],
                    playJockeyCurrentPlaylistId: loadedData.playJockeyCurrentPlaylistId || defaultPlaylistId,
                    playJockeyCurrentVideo: loadedData.playJockeyCurrentVideo ? {
                        ...(loadedData.playJockeyCurrentVideo),
                        title: loadedData.playJockeyCurrentVideo.title ? decodeHtmlEntities(loadedData.playJockeyCurrentVideo.title) : "Unknown Title",
                        artist: loadedData.playJockeyCurrentVideo.artist ? decodeHtmlEntities(loadedData.playJockeyCurrentVideo.artist) : ""
                    } : null,
                    playJockeyAutoPlayEnabled: typeof loadedData.playJockeyAutoPlayEnabled === 'boolean' ? loadedData.playJockeyAutoPlayEnabled : defaultAppData.playJockeyAutoPlayEnabled,
                    playJockeyRandomEnabled: typeof loadedData.playJockeyRandomEnabled === 'boolean' ? loadedData.playJockeyRandomEnabled : defaultAppData.playJockeyRandomEnabled,
                    playJockeyRepeatState: ["off", "playlist", "song"].includes(loadedData.playJockeyRepeatState) ? loadedData.playJockeyRepeatState : defaultAppData.playJockeyRepeatState,
                    playJockeyRandomHistory: Array.isArray(loadedData.playJockeyRandomHistory) ? loadedData.playJockeyRandomHistory : [],
                    geminiChatHistory: Array.isArray(loadedData.geminiChatHistory) ? loadedData.geminiChatHistory : [],
                    pixelAppData: { ...defaultAppData.pixelAppData, ...(loadedData.pixelAppData || {}), pencilSize: (loadedData.pixelAppData && typeof loadedData.pixelAppData.pencilSize === 'number') ? loadedData.pixelAppData.pencilSize : defaultAppData.pixelAppData.pencilSize }
                };

                if (!appData.playJockeyPlaylists.find(pl => pl.id === appData.playJockeyCurrentPlaylistId)) {
                    appData.playJockeyCurrentPlaylistId = appData.playJockeyPlaylists[0]?.id || defaultPlaylistId;
                     if (appData.playJockeyPlaylists.length === 0) {
                        appData.playJockeyPlaylists = [{id: defaultPlaylistId, name: "Playlist", videos: []}];
                        appData.playJockeyCurrentPlaylistId = defaultPlaylistId;
                    }
                }
                appData.areas = appData.areas || [];
                appData.achievements = appData.achievements || {};
                for (const key in appData.achievements) {
                    if (appData.achievements.hasOwnProperty(key)) {
                        appData.achievements[key].forEach(ach => {
                            if (ach.xpAwarded === undefined) ach.xpAwarded = false;
                        });
                    }
                }

                appData.quests = appData.quests || {};
                if (typeof appData.selectedDayIndex !== 'number' || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) {
                    appData.selectedDayIndex = defaultAppData.selectedDayIndex;
                }
                 if (appData.viewMode !== 'week' && appData.viewMode !== 'day') {
                    appData.viewMode = defaultAppData.viewMode;
                }

            } catch (error) {
                console.error("Error parsing stored data, reverting to defaults:", error);
                appData = JSON.parse(JSON.stringify(defaultAppData));
            }
        } else {
             appData = JSON.parse(JSON.stringify(defaultAppData));
        }
    }

    function getMonday(d) {
        d = new Date(d);
        const currentDay = d.getDay();
        const diffToMondayVal = d.getDate() - currentDay + (currentDay === 0 ? -6 : 1);
        const mondayDate = new Date(d.getFullYear(), d.getMonth(), diffToMondayVal);
        return mondayDate;
    }

    function getWeekNumber(d) {
        d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }

    function getCurrentWeekId() {
        if (!appData.currentWeekStartDate) {
            appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        }
        const startDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        return `${startDate.getFullYear()}-W${String(getWeekNumber(startDate)).padStart(2, '0')}`;
    }

    function navigateWeek(offsetInDays) {
        const currentMon = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        currentMon.setDate(currentMon.getDate() + offsetInDays);
        appData.currentWeekStartDate = getMonday(currentMon).toISOString().split('T')[0];
        updateDateDisplay();
        renderWeekdayHeaders();
        checkAndAwardScheduledXP();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        saveData();
    }

    function navigateDay(offset) {
        appData.selectedDayIndex += offset;
        let weekChanged = false;
        let currentMonDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);

        if (appData.selectedDayIndex < 0) {
            currentMonDate.setDate(currentMonDate.getDate() - 7);
            appData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            appData.selectedDayIndex = 6;
            weekChanged = true;
        } else if (appData.selectedDayIndex > 6) {
            currentMonDate.setDate(currentMonDate.getDate() + 7);
            appData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            appData.selectedDayIndex = 0;
            weekChanged = true;
        }

        updateDateDisplay();
        renderWeekdayHeaders();
        checkAndAwardScheduledXP();
        renderGrid();
        if (weekChanged) {
            generateQuestsForCurrentWeekIfNeeded();
        }
        saveData();
    }

    function goToThisWeek() {
        appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        if(appData.viewMode === 'day') {
            const today = new Date();
            let currentDayOfWeek = today.getDay();
            appData.selectedDayIndex = (currentDayOfWeek === 0) ? 6 : currentDayOfWeek - 1;
        }
        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        checkAndAwardScheduledXP();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        saveData();
    }

    function toggleViewMode() {
        const appWindow = DOM.xpMainWindow;
        const state = appData.windowStates.xpMainWindow;

        const wasMaximized = appWindow.classList.contains('true-maximized');
        const wasMinimized = appWindow.classList.contains('minimized');

        if (appData.viewMode === 'week') {
            appData.viewMode = 'day';
            minTrackerAppWidth = 375;
            const today = new Date();
            const currentWeekMondayObj = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
            const checkDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const weekStartCheck = new Date(currentWeekMondayObj.getFullYear(), currentWeekMondayObj.getMonth(), currentWeekMondayObj.getDate());
            const weekEndCheck = new Date(weekStartCheck);
            weekEndCheck.setDate(weekStartCheck.getDate() + 6);

            if (checkDate >= weekStartCheck && checkDate <= weekEndCheck) {
                let currentDayOfWeek = today.getDay();
                appData.selectedDayIndex = (currentDayOfWeek === 0) ? 6 : currentDayOfWeek - 1;
            } else {
                 if (appData.selectedDayIndex === undefined || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) {
                    appData.selectedDayIndex = 0;
                }
            }
        } else {
            appData.viewMode = 'week';
            minTrackerAppWidth = 905;
        }

        if (!wasMaximized && !wasMinimized) {
            let currentWidth = appWindow.offsetWidth;
            if (currentWidth < minTrackerAppWidth) {
                appWindow.style.width = minTrackerAppWidth + 'px';
                if(state) {
                    state.width = minTrackerAppWidth;
                    state.userManuallySet = false;
                }
            } else if (state && !state.userManuallySet) {
                 setWindowDefaults('xpMainWindow', false);
            }
        }


        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        saveData();
    }

    function updateDateDisplay() {
        const currentMonday = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        if (appData.viewMode === 'week') {
            const weekEndDate = new Date(currentMonday);
            weekEndDate.setDate(currentMonday.getDate() + 6);
            const options = { month: 'short', day: 'numeric' };
            DOM.currentWeekDisplay.textContent = `${currentMonday.toLocaleDateString(undefined, options)} - ${weekEndDate.toLocaleDateString(undefined, options)}`;
            DOM.weekCountDisplay.textContent = `Year Week: ${getWeekNumber(currentMonday)}`;
        } else {
            const selectedDate = new Date(currentMonday);
             const currentDayIndex = (typeof appData.selectedDayIndex === 'number' && appData.selectedDayIndex >= 0 && appData.selectedDayIndex <=6) ? appData.selectedDayIndex : 0;
             selectedDate.setDate(selectedDate.getDate() + currentDayIndex);

            const dayDisplayOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            DOM.currentWeekDisplay.textContent = selectedDate.toLocaleDateString(undefined, dayDisplayOptions);
            DOM.weekCountDisplay.textContent = `Year Day: ${getDayOfYear(selectedDate)}`;
        }
    }

    function renderWeekdayHeaders() {
        DOM.weekdayHeaders.innerHTML = '<th>Area</th>';
        if (appData.viewMode === 'week') {
            WEEKDAYS.forEach(day => {
                const th = document.createElement('th');
                th.textContent = day;
                DOM.weekdayHeaders.appendChild(th);
            });
        } else {
            const th = document.createElement('th');
            const dayDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
            const currentDayIndex = (typeof appData.selectedDayIndex === 'number' && appData.selectedDayIndex >= 0 && appData.selectedDayIndex <=6) ? appData.selectedDayIndex : 0;
            dayDate.setDate(dayDate.getDate() + currentDayIndex);
            th.textContent = `${WEEKDAYS[currentDayIndex]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;
            DOM.weekdayHeaders.appendChild(th);
        }
    }

    function renderGrid() {
        DOM.gridBody.innerHTML = '';
        appData.areas.forEach(area => {
            const tr = document.createElement('tr');
            tr.dataset.areaName = area.name;

            const nameTd = document.createElement('td');
            nameTd.className = 'area-name-cell';
            const currentXP = area.xp;
            const xpToNext = xpForNextLevel(area.level);
            const percentage = xpToNext > 0 ? Math.min((currentXP / xpToNext) * 100, 100) : (currentXP > 0 ? 100 : 0);

            nameTd.innerHTML = `
                <div class="area-name-wrapper">
                    <span>${decodeHtmlEntities(area.name)}</span>
                    <button class="xp-button delete-area-btn" data-area-name="${area.name}" title="Delete ${area.name}">X</button>
                </div>
                <div class="area-stats">
                    <span>Level: <span class="area-level">${area.level}</span></span>
                    <div class="xp-bar-container">
                        <div class="xp-bar" style="width: ${percentage}%;"></div>
                        <div class="xp-bar-text"><span class="area-xp">${currentXP}</span> / ${xpToNext} XP</div>
                    </div>
                </div>`;
            tr.appendChild(nameTd);

            const renderCellContent = (td, areaName, dayIdx) => {
                const achievementsKey = `${appData.currentWeekStartDate}_${areaName}_${dayIdx}`;
                const cellAchievements = appData.achievements[achievementsKey] || [];

                cellAchievements.forEach(ach => {
                    const achDiv = document.createElement('div');
                    achDiv.className = 'achievement-item';
                    achDiv.dataset.achId = ach.id;
                    achDiv.dataset.achKey = achievementsKey;

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'achievement-content';
                    if (ach.type === 'text') {
                        contentDiv.textContent = decodeHtmlEntities(ach.content);
                    } else if (ach.type === 'image') {
                        const img = document.createElement('img');
                        img.src = ach.content;
                        img.alt = "Achievement Image";
                        contentDiv.appendChild(img);
                    }
                    achDiv.appendChild(contentDiv);

                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'achievement-item-actions';
                    actionsDiv.innerHTML = `
                        <button class="xp-button xp-button-small edit-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Edit">Edit</button>
                        <button class="xp-button xp-button-small remove-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Delete">Delete</button>
                    `;
                    achDiv.appendChild(actionsDiv);
                    let titleText = `XP: ${ach.xp} | Added: ${new Date(ach.timestamp).toLocaleString()}`;
                    if (ach.scheduledDate) {
                        titleText += ` | Scheduled: ${ach.scheduledDate}`;
                        titleText += ach.xpAwarded ? ' (XP Awarded)' : ' (XP Pending)';
                    }
                    achDiv.title = titleText;
                    td.appendChild(achDiv);
                });

                const addAchBtn = document.createElement('button');
                addAchBtn.className = 'xp-button achievement-add-btn-cell';
                addAchBtn.textContent = '+';
                addAchBtn.dataset.areaName = areaName;
                addAchBtn.dataset.dayIndex = dayIdx;

                const dayDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
                dayDate.setDate(dayDate.getDate() + dayIdx);
                addAchBtn.title = `Add achievement to ${decodeHtmlEntities(areaName)} on ${WEEKDAYS[dayIdx]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;

                td.appendChild(addAchBtn);
            };

            if (appData.viewMode === 'week') {
                WEEKDAYS.forEach((day, dayIndex) => {
                    const td = document.createElement('td');
                    td.dataset.areaName = area.name;
                    td.dataset.dayIndex = dayIndex;
                    renderCellContent(td, area.name, dayIndex);
                    tr.appendChild(td);
                });
            } else {
                const dayIndex = (typeof appData.selectedDayIndex === 'number' && appData.selectedDayIndex >= 0 && appData.selectedDayIndex <=6) ? appData.selectedDayIndex : 0;
                const td = document.createElement('td');
                td.dataset.areaName = area.name;
                td.dataset.dayIndex = dayIndex;
                renderCellContent(td, area.name, dayIndex);
                tr.appendChild(td);
            }
            DOM.gridBody.appendChild(tr);
        });
    }

    function saveNewArea() {
        const name = DOM.newAreaNameInput.value.trim();
        if (!name) {
            alert("Area name cannot be empty.");
            return;
        }
        if (appData.areas.find(a => a.name.toLowerCase() === name.toLowerCase())) {
            alert("Area with this name already exists.");
            return;
        }

        appData.areas.push({ name: name, level: 1, xp: 0 });
        DOM.newAreaNameInput.value = '';
        closeModal(MODAL_IDS.NEW_AREA);
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded(true);
        saveData();
    }

    function promptRemoveArea(areaName) {
        DOM.confirmRemoveAreaMessage.textContent = `Are you sure you want to remove the area "${decodeHtmlEntities(areaName)}"? This action cannot be undone and will delete all associated achievements and quests.`;
        DOM.confirmRemoveBtn.dataset.areaNameToRemove = areaName;
        openModal(MODAL_IDS.CONFIRM_REMOVE_AREA);
    }

    function removeArea(areaName) {
        appData.areas = appData.areas.filter(area => area.name !== areaName);

        const achievementKeysToDelete = [];
        for (const key in appData.achievements) {
            if (appData.achievements.hasOwnProperty(key)) {
                const parts = key.split('_');
                const keyAreaName = parts.slice(1, parts.length -1).join('_');
                if (keyAreaName === areaName) {
                    achievementKeysToDelete.push(key);
                }
            }
        }
        achievementKeysToDelete.forEach(key => delete appData.achievements[key]);

        for (const weekId in appData.quests) {
            if (appData.quests.hasOwnProperty(weekId)) {
                appData.quests[weekId] = appData.quests[weekId].filter(quest => quest.areaName !== areaName);
            }
        }

        generateQuestsForCurrentWeekIfNeeded(true);
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        saveData();
    }

    function openAddEditAchievementModal(areaName, dayIndex, achievementKeyToEdit = null, achievementIdToEdit = null) {
        DOM.achievementImageInput.value = null;
        DOM.achievementTextInput.value = '';
        DOM.editingAchievementKeyInput.value = '';
        DOM.editingAchievementIdInput.value = '';

        if (achievementKeyToEdit && achievementIdToEdit) {
            const achievementsInCell = appData.achievements[achievementKeyToEdit];
            const achievementToEdit = achievementsInCell ? achievementsInCell.find(ach => ach.id === achievementIdToEdit) : null;

            if (!achievementToEdit) {
                alert("Error: Could not find achievement to edit.");
                return;
            }

            const keyParts = achievementKeyToEdit.split('_');
            const currentAreaName = keyParts.slice(1, keyParts.length -1).join('_');
            const currentDayIndex = parseInt(keyParts[keyParts.length -1]);

            DOM.achievementAreaNameInput.value = currentAreaName;
            DOM.achievementDayIndexInput.value = currentDayIndex;
            DOM.editingAchievementKeyInput.value = achievementKeyToEdit;
            DOM.editingAchievementIdInput.value = achievementIdToEdit;

            DOM.addEditAchievementModalTitle.textContent = "Edit Achievement";
            DOM.saveAchievementBtn.textContent = "Update Achievement";

            if (achievementToEdit.type === 'text') {
                DOM.achievementTypeRadios[0].checked = true;
                DOM.achievementTextInput.value = decodeHtmlEntities(achievementToEdit.content);
            } else if (achievementToEdit.type === 'image') {
                DOM.achievementTypeRadios[1].checked = true;
            }
        } else {
            DOM.achievementAreaNameInput.value = areaName;
            DOM.achievementDayIndexInput.value = dayIndex;
            DOM.addEditAchievementModalTitle.textContent = "Add Achievement";
            DOM.saveAchievementBtn.textContent = "Save Achievement";
            DOM.achievementTypeRadios[0].checked = true;
        }
        toggleAchievementInputType();
        openModal(MODAL_IDS.ADD_EDIT_ACHIEVEMENT);
        if(DOM.achievementTypeRadios[0].checked) DOM.achievementTextInput.focus();
    }


    function toggleAchievementInputType() {
        if (DOM.achievementTypeRadios[0].checked) {
            DOM.textInputDiv.style.display = 'block';
            DOM.imageInputDiv.style.display = 'none';
        } else {
            DOM.textInputDiv.style.display = 'none';
            DOM.imageInputDiv.style.display = 'block';
        }
    }

    function getAchievementDate(weekStartDateStr, dayIdx) {
        const achievementDate = parseYYYYMMDDToLocalDate(weekStartDateStr);
        achievementDate.setDate(achievementDate.getDate() + dayIdx);
        return achievementDate;
    }

    function saveOrUpdateAchievement() {
        const areaName = DOM.achievementAreaNameInput.value;
        const dayIndex = parseInt(DOM.achievementDayIndexInput.value);
        const type = document.querySelector('input[name="achievementType"]:checked').value;
        const editingKey = DOM.editingAchievementKeyInput.value;
        const editingId = DOM.editingAchievementIdInput.value;

        const isEditing = editingKey && editingId;
        let achievement;

        const achievementsKey = isEditing ? editingKey : `${appData.currentWeekStartDate}_${areaName}_${dayIndex}`;
        if (!appData.achievements[achievementsKey] && !isEditing) {
            appData.achievements[achievementsKey] = [];
        }

        let achievementList = appData.achievements[achievementsKey] || [];

        if (isEditing) {
            achievement = achievementList.find(ach => ach.id === editingId);
            if (!achievement) {
                alert("Error: Could not find achievement to update.");
                return;
            }
        } else {
            achievement = {
                id: Date.now() + '-' + Math.random().toString(36).substring(2, 9),
                timestamp: new Date().toISOString(),
                xp: XP_PER_REGULAR_ACHIEVEMENT,
                scheduledDate: getAchievementDate(appData.currentWeekStartDate, dayIndex).toISOString().split('T')[0],
                xpAwarded: false
            };
        }

        achievement.type = type;

        const processSave = (contentToSave) => {
            achievement.content = contentToSave;
            if (isEditing) {
            } else {
                achievementList.push(achievement);
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const achievementScheduledDateObj = parseYYYYMMDDToLocalDate(achievement.scheduledDate);

                if (achievementScheduledDateObj && achievementScheduledDateObj <= today) {
                    addXpToArea(areaName, achievement.xp);
                    updateQuestProgress(areaName, achievement.xp);
                    achievement.xpAwarded = true;
                } else {
                    achievement.xpAwarded = false;
                    if(achievementScheduledDateObj) {
                        console.log(`XP for new achievement "${achievement.id}" (scheduled: ${achievement.scheduledDate}) will be awarded on its scheduled date.`);
                    }
                }
            }

            closeModal(MODAL_IDS.ADD_EDIT_ACHIEVEMENT);
            renderGrid();
            saveData();
        };

        if (type === 'text') {
            const textContent = DOM.achievementTextInput.value.trim();
            if (!textContent) {
                alert("Achievement description cannot be empty.");
                return;
            }
            processSave(textContent);
        } else if (type === 'image') {
            const file = DOM.achievementImageInput.files[0];
            if (file) {
                if (file.size > 2 * 1024 * 1024) {
                    alert("Image file is too large. Please choose an image under 2MB.");
                    return;
                }
                const reader = new FileReader();
                reader.onloadend = function() {
                    processSave(reader.result);
                }
                reader.onerror = function() { alert("Error reading image file."); }
                reader.readAsDataURL(file);
            } else if (isEditing && achievement.type === 'image' && achievement.content) {
                processSave(achievement.content);
            } else if (!isEditing || (isEditing && achievement.type !== 'image')) {
                alert("Please select an image file for an image type achievement.");
                return;
            }
        }
    }

    function promptRemoveAchievement(achievementKey, achievementId) {
        DOM.confirmDeleteAchievementBtn.dataset.achievementKey = achievementKey;
        DOM.confirmDeleteAchievementBtn.dataset.achievementId = achievementId;
        openModal(MODAL_IDS.CONFIRM_DELETE_ACHIEVEMENT);
    }

    function confirmRemoveAchievement(achievementKey, achievementId) {
        if (!appData.achievements[achievementKey]) return;

        const achIndex = appData.achievements[achievementKey].findIndex(ach => ach.id === achievementId);
        if (achIndex === -1) return;

        const achievementToRemove = appData.achievements[achievementKey][achIndex];
        const xpToRemove = achievementToRemove.xp;

        const keyParts = achievementKey.split('_');
        const areaName = keyParts.slice(1, keyParts.length -1).join('_');

        appData.achievements[achievementKey].splice(achIndex, 1);
        if (appData.achievements[achievementKey].length === 0) {
            delete appData.achievements[achievementKey];
        }

        if (achievementToRemove.xpAwarded) {
            subtractXpFromArea(areaName, xpToRemove);
            updateQuestProgress(areaName, -xpToRemove);
        } else {
            console.log(`XP for deleted achievement "${achievementToRemove.id}" (scheduled: ${achievementToRemove.scheduledDate}) was not yet awarded, so no XP subtracted.`);
        }

        closeModal(MODAL_IDS.CONFIRM_DELETE_ACHIEVEMENT);
        renderGrid();
        saveData();
    }


    function xpForNextLevel(currentLevel) {
        if (currentLevel <= 0) return 50;
        return Math.floor(50 * Math.pow(currentLevel, 1.5));
    }

    function addXpToArea(areaName, xpAmount) {
        const area = appData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp += xpAmount;
            let leveledUp = false;
            let requiredForNext = xpForNextLevel(area.level);

            while (area.xp >= requiredForNext && requiredForNext > 0) {
                area.xp -= requiredForNext;
                area.level++;
                leveledUp = true;
                requiredForNext = xpForNextLevel(area.level);
            }

            if (leveledUp) {
                alert(`${decodeHtmlEntities(area.name)} leveled up to Level ${area.level}!`);
                generateQuestsForCurrentWeekIfNeeded(true);
            }
        }
    }

    function subtractXpFromArea(areaName, xpAmount) {
        const area = appData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp -= xpAmount;
            let deLeveled = false;
            while (area.xp < 0) {
                if (area.level > 1) {
                    area.level--;
                    deLeveled = true;
                    area.xp += xpForNextLevel(area.level);
                } else {
                    area.xp = 0;
                    break;
                }
            }
            if (deLeveled) {
                 generateQuestsForCurrentWeekIfNeeded(true);
            }
        }
    }


    function generateQuestsForCurrentWeekIfNeeded(forceRegenerate = false) {
        const weekId = getCurrentWeekId();

        if (!appData.quests) appData.quests = {};
        if (!appData.quests[weekId] || forceRegenerate) {
            appData.quests[weekId] = [];
        }

        if (appData.areas.length < 1 && !forceRegenerate) {
            if(appData.quests[weekId].length === 0) return;
        }

        if (forceRegenerate || (appData.quests[weekId].length === 0 && appData.areas.length > 0)) {
            if (forceRegenerate) appData.quests[weekId] = [];

            const questsToPotentiallyGenerate = Math.min(MAX_WEEKLY_QUESTS, appData.areas.length, 3);
            let generatedCount = 0;

            const availableAreasForNewQuests = [...appData.areas].filter(area =>
                !appData.quests[weekId].some(q => q.areaName === area.name)
            );
            let shuffledAreas = [...(availableAreasForNewQuests.length > 0 ? availableAreasForNewQuests : appData.areas)];
            for (let i = shuffledAreas.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledAreas[i], shuffledAreas[j]] = [shuffledAreas[j], shuffledAreas[i]];
            }


            for (let i = 0; i < questsToPotentiallyGenerate && appData.quests[weekId].length < MAX_WEEKLY_QUESTS; i++) {
                if (shuffledAreas.length === 0) break;

                const selectedArea = shuffledAreas.pop();
                if (!selectedArea) continue;
                if(!forceRegenerate && appData.quests[weekId].some(q => q.areaName === selectedArea.name)) continue;


                const targetXPEarned = 20 + (selectedArea.level * 10);
                const rewardXP = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5);

                appData.quests[weekId].push({
                    id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}_${i}`,
                    areaName: selectedArea.name,
                    description: `Earn ${targetXPEarned} XP in "${decodeHtmlEntities(selectedArea.name)}" this week.`,
                    targetXPEarned: targetXPEarned,
                    currentXPEarned: 0,
                    rewardXP: rewardXP,
                    completed: false
                });
                generatedCount++;
            }
        }
    }

    function updateQuestProgress(areaName, xpGained) {
        const weekId = getCurrentWeekId();
        if (!appData.quests || !appData.quests[weekId]) return;

        let questCompletedThisUpdate = false;
        appData.quests[weekId].forEach(quest => {
            if (quest.areaName === areaName && !quest.completed) {
                quest.currentXPEarned += xpGained;
                if (quest.currentXPEarned < 0) quest.currentXPEarned = 0;

                if (quest.currentXPEarned >= quest.targetXPEarned) {
                    quest.completed = true;
                    quest.currentXPEarned = quest.targetXPEarned;
                    addXpToArea(quest.areaName, quest.rewardXP);
                    alert(`Quest Completed: ${decodeHtmlEntities(quest.description)}\n+${quest.rewardXP} XP to ${decodeHtmlEntities(quest.areaName)}!`);
                    questCompletedThisUpdate = true;
                }
            }
        });

        if (questCompletedThisUpdate) {
            renderGrid();
            saveData();
        }
    }

    function showQuests() {
        const weekId = getCurrentWeekId();
        DOM.questsList.innerHTML = '';

        generateQuestsForCurrentWeekIfNeeded();

        const currentQuests = appData.quests[weekId] || [];

        if (currentQuests.length === 0) {
            DOM.questsList.innerHTML = `<p>No quests available for this week.${appData.areas.length === 0 ? ' Add some areas first to generate quests!' : ' You can create new quests manually.'}</p>`;
        } else {
            currentQuests.forEach(quest => {
                const questDiv = document.createElement('div');
                questDiv.className = 'quest-item';
                if (quest.completed) {
                    questDiv.classList.add('completed');
                }

                const title = document.createElement('div');
                title.className = 'quest-title';
                title.textContent = `Quest for: ${decodeHtmlEntities(quest.areaName)}`;

                const details = document.createElement('div');
                details.className = 'quest-details';
                details.textContent = decodeHtmlEntities(quest.description);

                const progress = document.createElement('div');
                progress.className = 'quest-progress';
                progress.textContent = `Progress: ${Math.min(quest.currentXPEarned, quest.targetXPEarned)} / ${quest.targetXPEarned} XP. Reward: ${quest.rewardXP} XP.`;

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'quest-actions';
                if (!quest.completed) {
                    const refreshBtn = document.createElement('button');
                    refreshBtn.className = 'xp-button xp-button-small refresh-quest-btn';
                    refreshBtn.dataset.questId = quest.id;
                    refreshBtn.textContent = 'Refresh';
                    actionsDiv.appendChild(refreshBtn);
                }

                questDiv.appendChild(title);
                questDiv.appendChild(details);
                questDiv.appendChild(progress);
                questDiv.appendChild(actionsDiv);
                DOM.questsList.appendChild(questDiv);
            });
        }
        DOM.addQuestBtn.disabled = currentQuests.length >= MAX_WEEKLY_QUESTS;
        openModal(MODAL_IDS.QUESTS);
    }

    function openCreateQuestModal() {
        const weekId = getCurrentWeekId();
        if (appData.quests[weekId] && appData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Maximum of ${MAX_WEEKLY_QUESTS} quests per week reached.`);
            return;
        }
        if (appData.areas.length === 0) {
            alert("Please create at least one Area before adding quests.");
            return;
        }

        DOM.newQuestAreaNameSelect.innerHTML = '';
        appData.areas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.name;
            option.textContent = decodeHtmlEntities(area.name);
            DOM.newQuestAreaNameSelect.appendChild(option);
        });
        DOM.newQuestDescriptionInput.value = '';
        DOM.newQuestTargetXPInput.value = 30;
        DOM.newQuestRewardXPInput.value = 50;
        openModal(MODAL_IDS.CREATE_QUEST);
    }

    function saveNewQuest() {
        const weekId = getCurrentWeekId();
        if (!appData.quests[weekId]) appData.quests[weekId] = [];

        if (appData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Cannot add new quest: Maximum of ${MAX_WEEKLY_QUESTS} quests reached for this week.`);
            return;
        }

        const areaName = DOM.newQuestAreaNameSelect.value;
        const description = DOM.newQuestDescriptionInput.value.trim();
        const targetXP = parseInt(DOM.newQuestTargetXPInput.value);
        const rewardXP = parseInt(DOM.newQuestRewardXPInput.value);

        if (!areaName) { alert("Please select an area."); return; }
        if (!description) { alert("Please enter a description."); return; }
        if (isNaN(targetXP) || targetXP <= 0) { alert("Target XP must be a positive number."); return; }
        if (isNaN(rewardXP) || rewardXP <= 0) { alert("Reward XP must be a positive number."); return; }

        const newQuest = {
            id: `quest_${weekId}_${areaName.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName: areaName,
            description: description,
            targetXPEarned: targetXP,
            currentXPEarned: 0,
            rewardXP: rewardXP,
            completed: false
        };

        appData.quests[weekId].push(newQuest);

        closeModal(MODAL_IDS.CREATE_QUEST);
        showQuests();
        saveData();
    }

    function promptRefreshQuest(questId) {
        DOM.confirmRefreshQuestBtn.dataset.questIdToRefresh = questId;
        openModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
    }

    function generateSingleRandomQuest(weekId, questToReplace = null) {
        if (appData.areas.length === 0) return null;

        let potentialAreas = [...appData.areas];
        if (questToReplace && potentialAreas.length > 1) {
            const filteredAreas = potentialAreas.filter(a => a.name !== questToReplace.areaName);
            if (filteredAreas.length > 0) {
                potentialAreas = filteredAreas;
            }
        }

        if(potentialAreas.length === 0) potentialAreas = [...appData.areas];

        const randomAreaIndex = Math.floor(Math.random() * potentialAreas.length);
        const selectedArea = potentialAreas[randomAreaIndex];

        const baseTarget = 20 + (selectedArea.level * 10);
        const targetXPEarned = Math.max(10, Math.round(baseTarget + (Math.random() * baseTarget * 0.3) - (baseTarget * 0.15)) );
        const baseReward = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5);
        const rewardXP = Math.max(10, Math.round(baseReward + (Math.random() * baseReward * 0.2) - (baseReward * 0.1)));

        return {
            id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName: selectedArea.name,
            description: `Earn ${targetXPEarned} XP in "${decodeHtmlEntities(selectedArea.name)}" this week. (Refreshed)`,
            targetXPEarned: targetXPEarned,
            currentXPEarned: 0,
            rewardXP: rewardXP,
            completed: false
        };
    }

    function confirmAndRefreshQuest() {
        const questIdToRefresh = DOM.confirmRefreshQuestBtn.dataset.questIdToRefresh;
        const weekId = getCurrentWeekId();

        if (!questIdToRefresh || !appData.quests[weekId]) {
            closeModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
            return;
        }

        const questIndex = appData.quests[weekId].findIndex(q => q.id === questIdToRefresh);
        if (questIndex === -1) {
            closeModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
            return;
        }

        const oldQuest = appData.quests[weekId][questIndex];
        appData.quests[weekId].splice(questIndex, 1);

        const newQuest = generateSingleRandomQuest(weekId, oldQuest);
        if (newQuest) {
            appData.quests[weekId].push(newQuest);
        } else if (appData.areas.length > 0) {
            alert("Could not generate a new quest. Try again or create one manually.");
        }

        closeModal(MODAL_IDS.CONFIRM_REFRESH_QUEST);
        showQuests();
        saveData();
    }

    // --- PlayJockey Functions ---

    function getCurrentPlayJockeyPlaylist() {
        if (!appData.playJockeyCurrentPlaylistId || !appData.playJockeyPlaylists) {
            if (appData.playJockeyPlaylists && appData.playJockeyPlaylists.length > 0) {
                appData.playJockeyCurrentPlaylistId = appData.playJockeyPlaylists[0].id;
            } else {
                return null;
            }
        }
        return appData.playJockeyPlaylists.find(p => p.id === appData.playJockeyCurrentPlaylistId);
    }


    function onYouTubeIframeAPIReady() {
        isYouTubeApiReady = true;
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        const currentVideoInPlaylist = currentPlaylist?.videos.find(v => v.id === appData.playJockeyCurrentVideo?.id);

        if (pendingVideoToLoad && currentVideoInPlaylist) {
            playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
            pendingVideoToLoad = null;
        } else if (appData.playJockeyCurrentVideo && currentVideoInPlaylist && !ytPlayerInstance && DOM.playJockeyWindow.style.display !== 'none' && !DOM.playJockeyWindow.classList.contains('minimized')) {
            playYouTubeVideoById(appData.playJockeyCurrentVideo.videoId, appData.playJockeyAutoPlayEnabled);
        }
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        const regex = /(?:youtube\.com\/(?:[^\/\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }

    function isValidYouTubeUrl(url) {
        if (!url) return false;
        const regex = /^(https?:\/\/)?(www\.)?(youtube\.com\/(watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})([&?].*)?$/;
        return regex.test(url);
    }

    async function handlePlayJockeyInput() {
        const input = DOM.playJockeyLinkInput.value.trim();
        if (!input) {
            alert("Please enter a YouTube link or search query.");
            return;
        }

        const apiKeyMissing = (!YOUTUBE_API_KEY);

        if (isValidYouTubeUrl(input)) {
            addYouTubeLinkToPlayJockey(input);
        } else {
            if (apiKeyMissing) {
                alert("YouTube API Key is not configured or could not be loaded. Video search is disabled. You can only add direct YouTube video links.");
                return;
            }
            searchYouTubeVideos(input);
        }
    }

    async function searchYouTubeVideos(query) {
        DOM.youtubeSearchResultsBody.innerHTML = '';
        DOM.youtubeSearchStatus.textContent = 'Searching...';
        DOM.youtubeSearchStatus.style.display = 'block';
        openModal(MODAL_IDS.Youtube);

        const maxResults = 10;
        const apiUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&key=${YOUTUBE_API_KEY}&maxResults=${maxResults}`;

        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                const errorData = await response.json();
                console.error('YouTube API Error:', errorData);
                let errorMessage = `Error searching videos: ${response.statusText}`;
                if (errorData.error && errorData.error.message) {
                    errorMessage += ` - ${errorData.error.message}`;
                }
                DOM.youtubeSearchStatus.textContent = errorMessage;
                return;
            }
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                DOM.youtubeSearchStatus.style.display = 'none';
                renderYouTubeSearchResults(data.items);
            } else {
                DOM.youtubeSearchStatus.textContent = 'No videos found for your search query.';
            }
        } catch (error) {
            console.error('Error fetching Youtube results:', error);
            DOM.youtubeSearchStatus.textContent = 'Failed to search videos. Check console for details.';
        }
    }

    function renderYouTubeSearchResults(items) {
        DOM.youtubeSearchResultsBody.innerHTML = '';

        items.forEach(item => {
            const videoId = item.id.videoId;
            const title = decodeHtmlEntities(item.snippet.title);
            const channelTitle = decodeHtmlEntities(item.snippet.channelTitle);
            const thumbnailUrl = item.snippet.thumbnails.default.url;

            const resultDiv = document.createElement('div');
            resultDiv.className = 'Youtube-result-item';
            resultDiv.dataset.videoId = videoId;

            const img = document.createElement('img');
            img.src = thumbnailUrl;
            img.alt = title;

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'Youtube-result-item-details';

            const titleDiv = document.createElement('div');
            titleDiv.className = 'Youtube-result-item-title';
            titleDiv.textContent = title;
            titleDiv.title = title;


            const channelDiv = document.createElement('div');
            channelDiv.className = 'Youtube-result-item-channel';
            channelDiv.textContent = channelTitle;
            channelDiv.title = channelTitle;


            detailsDiv.appendChild(titleDiv);
            detailsDiv.appendChild(channelDiv);
            resultDiv.appendChild(img);
            resultDiv.appendChild(detailsDiv);

            resultDiv.addEventListener('click', () => {
                addVideoFromSearchResult(videoId, title, channelTitle);
                closeModal(MODAL_IDS.Youtube);
            });
            DOM.youtubeSearchResultsBody.appendChild(resultDiv);
        });
    }

    function addVideoFromSearchResult(videoId, title, artist) {
        let currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist) {
            addNewPlayJockeyPlaylist();
            currentPlaylist = getCurrentPlayJockeyPlaylist();
            if (!currentPlaylist) {
                alert("Error: Could not create or find a playlist.");
                return;
            }
        }

        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            DOM.playJockeyLinkInput.value = '';
            return;
        }

        const videoEntry = {
            id: 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7),
            originalUrl: `https://www.youtube.com/watch?v=$$$${videoId}`,
            videoId: videoId,
            title: title,
            artist: artist.replace(/\s-\sTopic$/, '').trim()
        };

        currentPlaylist.videos.push(videoEntry);
        renderPlayJockeyPlaylist();
        DOM.playJockeyLinkInput.value = '';

        if (!ytPlayerInstance || !appData.playJockeyCurrentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true);
        }
        saveData();
    }


    function addYouTubeLinkToPlayJockey(link) {
        if (!link) {
            alert("Please enter a YouTube link.");
            return;
        }
        const videoId = extractYouTubeVideoId(link);
        if (!videoId) {
            alert("Invalid YouTube link. Please ensure it's a valid YouTube video URL.");
            return;
        }

        let currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist) {
            addNewPlayJockeyPlaylist();
            currentPlaylist = getCurrentPlayJockeyPlaylist();
             if (!currentPlaylist) {
                console.error("Failed to create/get playlist after attempting to add a link.");
                return;
            }
        }

        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            DOM.playJockeyLinkInput.value = '';
            return;
        }

        const tempId = 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7);
        const videoEntry = {
            id: tempId,
            originalUrl: link,
            videoId: videoId,
            title: "Loading title...",
            artist: ""
        };

        currentPlaylist.videos.push(videoEntry);
        renderPlayJockeyPlaylist();
        DOM.playJockeyLinkInput.value = '';

        fetchYouTubeTitle(videoEntry, currentPlaylist.id);

        if (!ytPlayerInstance || !appData.playJockeyCurrentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true);
        }
        saveData();
    }


    async function fetchYouTubeTitle(videoEntryToUpdate, playlistId) {
        try {
            let newTitle = "Unknown Title";
            let newArtist = "";

            if (YOUTUBE_API_KEY) {
                 const apiUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoEntryToUpdate.videoId}&key=${YOUTUBE_API_KEY}`;
                 const response = await fetch(apiUrl);
                 if (response.ok) {
                     const data = await response.json();
                     if (data.items && data.items.length > 0) {
                         newTitle = decodeHtmlEntities(data.items[0].snippet.title);
                         newArtist = decodeHtmlEntities(data.items[0].snippet.channelTitle).replace(/\s-\sTopic$/, '').trim();
                     } else {
                         console.warn(`No video data found via API for ${videoEntryToUpdate.videoId}`);
                         newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl);
                     }
                 } else {
                     console.warn(`Failed to fetch title/author via API for ${videoEntryToUpdate.videoId}. Status: ${response.status}`);
                     newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl);
                 }
            } else {
                try {
                    const oEmbedUrl = `https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=$$$${videoEntryToUpdate.videoId}&format=json`;
                    const oEmbedResponse = await fetch(oEmbedUrl);
                    if (oEmbedResponse.ok) {
                        const oEmbedData = await oEmbedResponse.json();
                        newTitle = decodeHtmlEntities(oEmbedData.title);
                        newArtist = decodeHtmlEntities(oEmbedData.author_name).replace(/\s-\sTopic$/, '').trim();
                    } else {
                         newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl);
                    }
                } catch (oEmbedError) {
                    console.warn(`oEmbed fetch failed for ${videoEntryToUpdate.videoId}:`, oEmbedError);
                    newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl);
                }
            }


            const targetPlaylist = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const itemInPlaylist = targetPlaylist.videos.find(item => item.id === videoEntryToUpdate.id);
                if (itemInPlaylist) {
                    itemInPlaylist.title = newTitle;
                    itemInPlaylist.artist = newArtist;
                    if (appData.playJockeyCurrentPlaylistId === playlistId) {
                        renderPlayJockeyPlaylist();
                    }
                    if(appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === itemInPlaylist.id) {
                        appData.playJockeyCurrentVideo.title = newTitle;
                        appData.playJockeyCurrentVideo.artist = newArtist;
                    }
                    saveData();
                }
            }
        } catch (error) {
            console.error(`Error in fetchYouTubeTitle for ${videoEntryToUpdate.videoId}:`, error);
             const targetPlaylist = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const itemInPlaylist = targetPlaylist.videos.find(item => item.id === videoEntryToUpdate.id);
                if (itemInPlaylist && (itemInPlaylist.title === "Loading title..." || !itemInPlaylist.title.trim())) {
                    itemInPlaylist.title = decodeHtmlEntities(itemInPlaylist.originalUrl);
                    if (appData.playJockeyCurrentPlaylistId === playlistId) renderPlayJockeyPlaylist();
                    saveData();
                }
            }
        }
    }


    function renderPlayJockeyTabs() {
        DOM.playJockeyTabsBar.innerHTML = '';
        appData.playJockeyPlaylists.forEach(playlist => {
            const tab = document.createElement('div');
            tab.className = 'playjockey-tab';
            const displayName = decodeHtmlEntities(playlist.name);
            tab.textContent = displayName;
            tab.title = displayName;
            tab.dataset.playlistId = playlist.id;
            if (playlist.id === appData.playJockeyCurrentPlaylistId) {
                tab.classList.add('active');
            }
            tab.addEventListener('click', () => switchPlayJockeyPlaylist(playlist.id));
            tab.addEventListener('contextmenu', (e) => showPjTabContextMenu(e, playlist.id));
            DOM.playJockeyTabsBar.appendChild(tab);
        });

        const addTabBtn = document.createElement('button');
        addTabBtn.className = 'playjockey-tab playjockey-add-tab-btn xp-button xp-button-small';
        addTabBtn.textContent = '+';
        addTabBtn.title = "New Playlist";
        addTabBtn.addEventListener('click', addNewPlayJockeyPlaylist);
        DOM.playJockeyTabsBar.appendChild(addTabBtn);
    }

    function addNewPlayJockeyPlaylist() {
        let newPlaylistName = "Playlist";
        let counter = 1;
        const existingNames = appData.playJockeyPlaylists.map(p => p.name.toLowerCase());

        let potentialName = newPlaylistName.toLowerCase();
        while (existingNames.includes(potentialName)) {
            potentialName = `${newPlaylistName} ${counter}`.toLowerCase();
            counter++;
        }
        if (counter > 1) newPlaylistName = `${newPlaylistName} ${counter-1}`;


        const newPlaylistId = 'playlist_' + Date.now() + '_' + Math.random().toString(36).substring(2,9);
        appData.playJockeyPlaylists.push({
            id: newPlaylistId,
            name: newPlaylistName,
            videos: []
        });
        switchPlayJockeyPlaylist(newPlaylistId);
    }

    function switchPlayJockeyPlaylist(playlistId) {
        if (appData.playJockeyCurrentPlaylistId === playlistId) return;

        appData.playJockeyCurrentPlaylistId = playlistId;
        appData.playJockeyCurrentVideo = null;
        appData.playJockeyRandomHistory = [];

        if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
            ytPlayerInstance.stopVideo();
        }
        renderPlayJockeyTabs();
        renderPlayJockeyPlaylist();
        saveData();
    }


    function renderPlayJockeyPlaylist() {
        DOM.playJockeyPlaylist.innerHTML = '';
        const currentPlaylist = getCurrentPlayJockeyPlaylist();

        if (!currentPlaylist || currentPlaylist.videos.length === 0) {
            const emptyMsg = document.createElement('div');
            emptyMsg.textContent = "Playlist is empty. Add some YouTube links or search!";
            emptyMsg.style.padding = "10px";
            emptyMsg.style.textAlign = "center";
            emptyMsg.style.color = "#555";
            DOM.playJockeyPlaylist.appendChild(emptyMsg);
            updatePlayingClassInPlaylist(null);
            return;
        }

        currentPlaylist.videos.forEach(video => {
            const item = document.createElement('div');
            item.className = 'playjockey-playlist-item';

            let cleanTitle = decodeHtmlEntities(video.title);
            let cleanArtist = decodeHtmlEntities(video.artist);

            let displayTitle = cleanTitle;
            if (cleanTitle === "Loading title..." || cleanTitle === video.originalUrl || !cleanTitle.trim()) {
                const decodedOriginalUrl = decodeHtmlEntities(video.originalUrl);
                displayTitle = decodedOriginalUrl.length > 40 ? decodedOriginalUrl.substring(0, 37) + '...' : decodedOriginalUrl;
            } else {
                 displayTitle = cleanTitle.length > 40 ? cleanTitle.substring(0, 37) + '...' : cleanTitle;
            }

            let itemText = displayTitle;
            let itemTooltip = (cleanTitle !== "Loading title..." && cleanTitle.trim()) ? cleanTitle : decodeHtmlEntities(video.originalUrl);

            if (cleanArtist && cleanArtist.trim() !== "") {
                const artistShort = cleanArtist.length > 20 ? cleanArtist.substring(0, 17) + '...' : cleanArtist;
                itemText = `${displayTitle} - ${artistShort}`;
                itemTooltip = `${itemTooltip} by ${cleanArtist}`;
            }

            item.textContent = itemText;
            item.title = itemTooltip;

            item.dataset.videoId = video.videoId;
            item.dataset.playlistItemId = video.id;
            item.draggable = true;

            if (appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === video.id) {
                item.classList.add('playing');
            }
            item.addEventListener('click', (event) => {
                if (event.target.closest('.context-modal')) return;
                if (item.classList.contains('dragging')) return;

                const clickedItem = event.currentTarget;
                if (clickedItem && clickedItem.dataset.videoId) {
                    playYouTubeVideoById(clickedItem.dataset.videoId, true, true);
                }
            });
            DOM.playJockeyPlaylist.appendChild(item);
        });
    }

    function playYouTubeVideoById(videoId, autoplayIntent = true, isManualPlay = false) {
        if (!videoId) { console.warn("playYouTubeVideoById called with no videoId"); return; }

        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist) { console.warn("No current playlist to play from"); return; }

        const videoToPlay = currentPlaylist.videos.find(v => v.videoId === videoId);
        if (!videoToPlay) {
            console.warn(`Video with ID ${videoId} not found in current playlist.`);
            appData.playJockeyCurrentVideo = null;
            updatePlayingClassInPlaylist(null);
            if(ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') ytPlayerInstance.stopVideo();
            return;
        }

        if ( isManualPlay && videoToPlay && appData.playJockeyRandomEnabled &&
             appData.playJockeyAutoPlayEnabled && appData.playJockeyRepeatState === "off" &&
             currentPlaylist.videos.length > 0 ) {
            const uniqueVideoIdsInPlaylist = new Set(currentPlaylist.videos.map(v => v.id));
            if (new Set(appData.playJockeyRandomHistory).size >= uniqueVideoIdsInPlaylist.size) {
                 appData.playJockeyRandomHistory = [videoToPlay.id];
            } else if (!appData.playJockeyRandomHistory.includes(videoToPlay.id)) {
                 appData.playJockeyRandomHistory.push(videoToPlay.id);
            }
        }


        appData.playJockeyCurrentVideo = { ...videoToPlay };
        updatePlayingClassInPlaylist(videoToPlay.id);
        saveData();

        if (!isYouTubeApiReady) {
            pendingVideoToLoad = { videoId, autoplayIntent };
            console.log("YouTube API not ready, video load queued:", videoId);
            if (typeof YT !== 'undefined' && YT.Player) { onYouTubeIframeAPIReady(); }
            return;
        }

        if (ytPlayerInstance && typeof ytPlayerInstance.loadVideoById === 'function') {
            ytPlayerInstance.loadVideoById({ 'videoId': videoId });
            if (autoplayIntent && typeof ytPlayerInstance.playVideo === 'function') {
                 ytPlayerInstance.playVideo();
            }
        } else {
            if (DOM.playJockeyPlayer.firstChild && DOM.playJockeyPlayer.firstChild.tagName === 'IFRAME') {
                 DOM.playJockeyPlayer.innerHTML = '';
            }
            ytPlayerInstance = new YT.Player('playJockeyPlayer', {
                height: '100%',
                width: '100%',
                videoId: videoId,
                playerVars: {
                    'autoplay': autoplayIntent ? 1 : 0,
                    'controls': 1, 'enablejsapi': 1, 'origin': window.location.origin,
                    'modestbranding': 1, 'rel': 0
                },
                events: {
                    'onReady': (event) => { if (autoplayIntent) event.target.playVideo(); },
                    'onStateChange': onPlayerStateChange
                }
            });
        }
    }

    function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.ENDED && appData.playJockeyAutoPlayEnabled) {
            playNextPjVideo();
        }
    }

    function playNextPjVideo() {
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!ytPlayerInstance || !appData.playJockeyCurrentVideo || !currentPlaylist || currentPlaylist.videos.length === 0) {
            return;
        }

        let nextVideoItem = null;
        const currentVideoUniqueId = appData.playJockeyCurrentVideo.id;
        const activePlaylistVideos = currentPlaylist.videos;


        if (appData.playJockeyRepeatState === "song") {
            nextVideoItem = activePlaylistVideos.find(item => item.id === currentVideoUniqueId);
        } else if (appData.playJockeyRandomEnabled) {
            if (activePlaylistVideos.length === 0) return;

            if (activePlaylistVideos.length === 1) {
                if (appData.playJockeyRepeatState === "off") {
                    if (appData.playJockeyRandomHistory.includes(currentVideoUniqueId)) return;
                    nextVideoItem = activePlaylistVideos[0];
                } else {
                    nextVideoItem = activePlaylistVideos[0];
                }
            } else {
                let eligibleVideos = activePlaylistVideos.filter(
                    video => !appData.playJockeyRandomHistory.includes(video.id) || video.id === currentVideoUniqueId
                );

                if (eligibleVideos.length === 1 && eligibleVideos[0].id === currentVideoUniqueId && appData.playJockeyRepeatState !== "song") {
                     eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                     if (eligibleVideos.length === 0 && appData.playJockeyRepeatState === "playlist") {
                        appData.playJockeyRandomHistory = [currentVideoUniqueId];
                        eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                     }
                } else if (eligibleVideos.length === 0 && appData.playJockeyRepeatState === "playlist") {
                    appData.playJockeyRandomHistory = [currentVideoUniqueId];
                    eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                }


                if (eligibleVideos.length === 0) {
                    if (appData.playJockeyRepeatState === "playlist") {
                        appData.playJockeyRandomHistory = [];
                        eligibleVideos = [...activePlaylistVideos];
                        if(activePlaylistVideos.length === 1) nextVideoItem = activePlaylistVideos[0];
                    } else {
                        appData.playJockeyRandomHistory = [];
                        return;
                    }
                }
                if (eligibleVideos.length > 0 && !nextVideoItem) {
                    const randomIndex = Math.floor(Math.random() * eligibleVideos.length);
                    nextVideoItem = eligibleVideos[randomIndex];
                }
            }

            if (nextVideoItem) {
                if (!appData.playJockeyRandomHistory.includes(nextVideoItem.id)) {
                     appData.playJockeyRandomHistory.push(nextVideoItem.id);
                }
                if (appData.playJockeyRepeatState === "playlist") {
                    const maxHistorySize = Math.max(0, activePlaylistVideos.length -1);
                    while (appData.playJockeyRandomHistory.length > maxHistorySize && maxHistorySize > 0 && appData.playJockeyRandomHistory.length >= activePlaylistVideos.length) {
                        appData.playJockeyRandomHistory.shift();
                    }
                }
            }

        } else {
            const currentIndex = activePlaylistVideos.findIndex(item => item.id === currentVideoUniqueId);
            if (currentIndex === -1) return;

            let nextIndex = currentIndex + 1;
            if (nextIndex >= activePlaylistVideos.length) {
                if (appData.playJockeyRepeatState === "playlist") {
                    nextIndex = 0;
                } else {
                    return;
                }
            }
            if (activePlaylistVideos[nextIndex]) {
                nextVideoItem = activePlaylistVideos[nextIndex];
            }
        }

        if (nextVideoItem && nextVideoItem.videoId) {
            playYouTubeVideoById(nextVideoItem.videoId, true, false);
        }
    }

    function updatePlayingClassInPlaylist(playingItemId) {
        const items = DOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item');
        items.forEach(item => {
            if (item.dataset.playlistItemId === playingItemId) {
                item.classList.add('playing');
            } else {
                item.classList.remove('playing');
            }
        });
    }


    function initPlayJockeyContextMenu() {
        DOM.pjContextRenameBtn.addEventListener('click', handlePjContextRename);
        DOM.pjContextRemoveBtn.addEventListener('click', handlePjContextRemove);
    }
    function initPlayJockeyTabContextMenu() {
        DOM.pjTabContextRenameBtn.addEventListener('click', openRenamePlaylistModalFromContextMenu);
        DOM.pjTabContextRemoveBtn.addEventListener('click', openConfirmRemovePlaylistModalFromContextMenu);
    }


    function showPjContextMenu(e) {
        e.preventDefault();
        hidePjContextMenu();
        hidePjTabContextMenu();

        const clickedPlaylistItem = e.target.closest('.playjockey-playlist-item');
        if (clickedPlaylistItem) {
            DOM.playJockeyContextMenu.style.display = 'block';
            let x = e.clientX;
            let y = e.clientY;
            const menuWidth = DOM.playJockeyContextMenu.offsetWidth;
            const menuHeight = DOM.playJockeyContextMenu.offsetHeight;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (x + menuWidth > viewportWidth) x = viewportWidth - menuWidth - 5;
            if (y + menuHeight > viewportHeight) y = viewportHeight - menuHeight - 5;
            x = Math.max(0, x); y = Math.max(0, y);


            DOM.playJockeyContextMenu.style.left = `${x}px`;
            DOM.playJockeyContextMenu.style.top = `${y}px`;
            DOM.playJockeyContextMenu.dataset.currentItemId = clickedPlaylistItem.dataset.playlistItemId;
        }
    }

    function hidePjContextMenu() {
        DOM.playJockeyContextMenu.style.display = 'none';
        delete DOM.playJockeyContextMenu.dataset.currentItemId;
    }

    function showPjTabContextMenu(e, playlistId) {
        e.preventDefault();
        hidePjContextMenu();
        hidePjTabContextMenu();

        DOM.playJockeyTabContextMenu.style.display = 'block';
        let x = e.clientX;
        let y = e.clientY;
        const menuWidth = DOM.playJockeyTabContextMenu.offsetWidth;
        const menuHeight = DOM.playJockeyTabContextMenu.offsetHeight;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        if (x + menuWidth > viewportWidth) x = viewportWidth - menuWidth - 5;
        if (y + menuHeight > viewportHeight) y = viewportHeight - menuHeight - 5;
        x = Math.max(0, x); y = Math.max(0, y);

        DOM.playJockeyTabContextMenu.style.left = `${x}px`;
        DOM.playJockeyTabContextMenu.style.top = `${y}px`;
        DOM.playJockeyTabContextMenu.dataset.playlistId = playlistId;
    }

    function hidePjTabContextMenu() {
        DOM.playJockeyTabContextMenu.style.display = 'none';
        delete DOM.playJockeyTabContextMenu.dataset.playlistId;
    }


    function handlePjContextRename() {
        const itemId = DOM.playJockeyContextMenu.dataset.currentItemId;
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!itemId || !currentPlaylist) {
            hidePjContextMenu();
            return;
        }

        const itemToRename = currentPlaylist.videos.find(video => video.id === itemId);
        if (itemToRename) {
            DOM.trackNewNameInput.value = decodeHtmlEntities(itemToRename.title) || '';
            DOM.trackNewArtistInput.value = decodeHtmlEntities(itemToRename.artist) || '';
            DOM.saveRenamedTrackBtn.dataset.itemId = itemId;
            openModal(MODAL_IDS.RENAME_TRACK);
            DOM.trackNewNameInput.focus();
        }
        hidePjContextMenu();
    }

    function handlePjContextRemove() {
        const itemId = DOM.playJockeyContextMenu.dataset.currentItemId;
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!itemId || !currentPlaylist) {
            hidePjContextMenu();
            return;
        }
        const itemToRemove = currentPlaylist.videos.find(video => video.id === itemId);
        if (itemToRemove) {
            DOM.confirmRemoveTrackMessage.textContent = `Are you sure you want to remove the track "${decodeHtmlEntities(itemToRemove.title)}"?`;
            DOM.confirmFinalTrackRemoveBtn.dataset.itemId = itemId;
            openModal(MODAL_IDS.CONFIRM_REMOVE_TRACK);
        }
        hidePjContextMenu();
    }

    function saveRenamedTrack() {
        const itemId = DOM.saveRenamedTrackBtn.dataset.itemId;
        const newName = DOM.trackNewNameInput.value.trim();
        const newArtist = DOM.trackNewArtistInput.value.trim();
        const currentPlaylist = getCurrentPlayJockeyPlaylist();

        if (!itemId || !currentPlaylist) {
            alert("Error: Could not find track or playlist.");
            closeModal(MODAL_IDS.RENAME_TRACK);
            return;
        }
        if (!newName) {
            alert("Track name cannot be empty.");
            return;
        }

        const itemToRename = currentPlaylist.videos.find(video => video.id === itemId);
        if (itemToRename) {
            itemToRename.title = newName;
            itemToRename.artist = newArtist;
            if(appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === itemId) {
                appData.playJockeyCurrentVideo.title = newName;
                appData.playJockeyCurrentVideo.artist = newArtist;
            }
            renderPlayJockeyPlaylist();
            saveData();
        }
        closeModal(MODAL_IDS.RENAME_TRACK);
        delete DOM.saveRenamedTrackBtn.dataset.itemId;
    }

    function executeTrackDeletion() {
        const itemId = DOM.confirmFinalTrackRemoveBtn.dataset.itemId;
        const currentPlaylist = getCurrentPlayJockeyPlaylist();

        if (!itemId || !currentPlaylist) {
            alert("Error: Could not find track or playlist for deletion.");
            closeModal(MODAL_IDS.CONFIRM_REMOVE_TRACK);
            return;
        }

        const itemIndex = currentPlaylist.videos.findIndex(video => video.id === itemId);
        if (itemIndex > -1) {
            const removedItem = currentPlaylist.videos.splice(itemIndex, 1)[0];

            const historyIndex = appData.playJockeyRandomHistory.indexOf(removedItem.id);
            if (historyIndex > -1) {
                appData.playJockeyRandomHistory.splice(historyIndex, 1);
            }

            if (appData.playJockeyCurrentVideo && appData.playJockeyCurrentVideo.id === removedItem.id) {
                if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                    ytPlayerInstance.stopVideo();
                }
                appData.playJockeyCurrentVideo = null;
                if (appData.playJockeyAutoPlayEnabled && currentPlaylist.videos.length > 0) {
                    playNextPjVideo();
                } else if (currentPlaylist.videos.length === 0) {
                     DOM.playJockeyPlayer.innerHTML = '';
                }
            }
            renderPlayJockeyPlaylist();
            saveData();
        }
        closeModal(MODAL_IDS.CONFIRM_REMOVE_TRACK);
        delete DOM.confirmFinalTrackRemoveBtn.dataset.itemId;
    }


    function openRenamePlaylistModalFromContextMenu() {
        const playlistId = DOM.playJockeyTabContextMenu.dataset.playlistId;
        if (!playlistId) return;
        const playlistToRename = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
        if (playlistToRename) {
            DOM.playlistNewNameInput.value = decodeHtmlEntities(playlistToRename.name);
            DOM.saveRenamedPlaylistBtn.dataset.playlistId = playlistId;
            openModal(MODAL_IDS.RENAME_PLAYLIST);
            DOM.playlistNewNameInput.focus();
        }
        hidePjTabContextMenu();
    }

    function saveRenamedPlaylist() {
        const playlistId = DOM.saveRenamedPlaylistBtn.dataset.playlistId;
        const newName = DOM.playlistNewNameInput.value.trim();

        if (!playlistId) { alert("Error: Playlist ID missing."); return;}
        if (!newName) { alert("Playlist name cannot be empty."); return; }

        const playlistToRename = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
        if (playlistToRename) {
            playlistToRename.name = newName;
            renderPlayJockeyTabs();
            saveData();
        }
        closeModal(MODAL_IDS.RENAME_PLAYLIST);
        delete DOM.saveRenamedPlaylistBtn.dataset.playlistId;
    }


    function openConfirmRemovePlaylistModalFromContextMenu() {
        const playlistId = DOM.playJockeyTabContextMenu.dataset.playlistId;
        if (!playlistId) return;
        const playlistToRemove = appData.playJockeyPlaylists.find(pl => pl.id === playlistId);
        if (playlistToRemove) {
            DOM.confirmRemovePlaylistMessage.textContent = `Are you sure you want to remove the playlist "${decodeHtmlEntities(playlistToRemove.name)}"? This action cannot be undone.`;
            DOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId = playlistId;
            openModal(MODAL_IDS.CONFIRM_REMOVE_PLAYLIST);
        }
        hidePjTabContextMenu();
    }

    function executePlaylistDeletion() {
        const playlistIdToRemove = DOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId;
        if (!playlistIdToRemove) return;

        const playlistIndex = appData.playJockeyPlaylists.findIndex(pl => pl.id === playlistIdToRemove);
        if (playlistIndex > -1) {
            appData.playJockeyPlaylists.splice(playlistIndex, 1);

            if (appData.playJockeyCurrentPlaylistId === playlistIdToRemove) {
                if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                    ytPlayerInstance.stopVideo();
                }
                appData.playJockeyCurrentVideo = null;
                appData.playJockeyRandomHistory = [];

                if (appData.playJockeyPlaylists.length > 0) {
                    appData.playJockeyCurrentPlaylistId = appData.playJockeyPlaylists[0].id;
                } else {
                    const defaultPlaylistId = 'playlist_default_' + Date.now();
                    appData.playJockeyPlaylists.push({id: defaultPlaylistId, name: "Playlist", videos: []});
                    appData.playJockeyCurrentPlaylistId = defaultPlaylistId;
                }
            }
        }
        if (appData.playJockeyPlaylists.length === 0) {
            const defaultPlaylistId = 'playlist_default_' + Date.now();
            appData.playJockeyPlaylists.push({id: defaultPlaylistId, name: "Playlist", videos: []});
            appData.playJockeyCurrentPlaylistId = defaultPlaylistId;
        }

        renderPlayJockeyTabs();
        renderPlayJockeyPlaylist();
        saveData();
        closeModal(MODAL_IDS.CONFIRM_REMOVE_PLAYLIST);
        delete DOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId;
    }


    function handlePjDragStart(e) {
        const target = e.target.closest('.playjockey-playlist-item');
        if (target) {
            pjDraggedItem = target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', target.dataset.playlistItemId);
            setTimeout(() => {
                target.classList.add('dragging');
            }, 0);
            hidePjContextMenu();
        }
    }

    function handlePjDragEnd(e) {
        if (pjDraggedItem) {
            pjDraggedItem.classList.remove('dragging');
        }
        DOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
        pjDraggedItem = null;
    }

    function clearPjDragOverHighlights() {
        DOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
    }

    function handlePjDragOver(e) {
        e.preventDefault();
        const targetItem = e.target.closest('.playjockey-playlist-item');

        clearPjDragOverHighlights();

        if (targetItem && pjDraggedItem && targetItem !== pjDraggedItem) {
            const rect = targetItem.getBoundingClientRect();
            const midpointY = rect.top + rect.height / 2;
            if (e.clientY < midpointY) {
                targetItem.classList.add('drag-over-target-before');
            } else {
                targetItem.classList.add('drag-over-target-after');
            }
        }
    }

    function handlePjDragLeave(e) {
        const relatedTargetIsChildOrSelf = DOM.playJockeyPlaylist.contains(e.relatedTarget);
        if (!relatedTargetIsChildOrSelf) {
             clearPjDragOverHighlights();
        } else {
            const targetItem = e.target.closest('.playjockey-playlist-item');
            if (targetItem) {
                 targetItem.classList.remove('drag-over-target-before', 'drag-over-target-after');
            }
        }
    }


    function handlePjDrop(e) {
        e.preventDefault();
        clearPjDragOverHighlights();
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!pjDraggedItem || !currentPlaylist) return;

        const draggedItemId = e.dataTransfer.getData('text/plain');
        const targetItemElement = e.target.closest('.playjockey-playlist-item');

        const draggedItemIndex = currentPlaylist.videos.findIndex(item => item.id === draggedItemId);
        if (draggedItemIndex === -1) return;

        const itemToMove = currentPlaylist.videos[draggedItemIndex];
        currentPlaylist.videos.splice(draggedItemIndex, 1);

        let targetIndex = -1;

        if (targetItemElement && targetItemElement.dataset.playlistItemId !== draggedItemId) {
            const targetItemId = targetItemElement.dataset.playlistItemId;
            targetIndex = currentPlaylist.videos.findIndex(item => item.id === targetItemId);

            if (targetIndex !== -1) {
                const rect = targetItemElement.getBoundingClientRect();
                const midpointY = rect.top + rect.height / 2;
                if (e.clientY >= midpointY) {
                    targetIndex++;
                }
            }
        }


        if (targetIndex !== -1 && targetIndex <= currentPlaylist.videos.length) {
            currentPlaylist.videos.splice(targetIndex, 0, itemToMove);
        } else {
            currentPlaylist.videos.push(itemToMove);
        }

        renderPlayJockeyPlaylist();
        saveData();
        pjDraggedItem = null;
    }


    function togglePlayJockeyAutoPlay() {
        appData.playJockeyAutoPlayEnabled = !appData.playJockeyAutoPlayEnabled;
        updatePlayJockeyAutoPlayButtonState();
        saveData();
    }

    function updatePlayJockeyAutoPlayButtonState() {
        DOM.playJockeyAutoPlayBtn.classList.toggle('autoplay-on', appData.playJockeyAutoPlayEnabled);
        DOM.playJockeyAutoPlayBtn.textContent = `Auto Play: ${appData.playJockeyAutoPlayEnabled ? 'On' : 'Off'}`;
    }

    function togglePlayJockeyRandom() {
        appData.playJockeyRandomEnabled = !appData.playJockeyRandomEnabled;
        appData.playJockeyRandomHistory = [];
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (appData.playJockeyRandomEnabled && appData.playJockeyCurrentVideo && currentPlaylist && currentPlaylist.videos.length > 0) {
             if (currentPlaylist.videos.length > 1 || appData.playJockeyRepeatState !== "off") {
                 appData.playJockeyRandomHistory.push(appData.playJockeyCurrentVideo.id);
            }
        }
        updatePlayJockeyRandomButtonState();
        saveData();
    }

    function updatePlayJockeyRandomButtonState() {
        DOM.playJockeyRandomBtn.classList.toggle('random-on', appData.playJockeyRandomEnabled);
        DOM.playJockeyRandomBtn.textContent = `Random: ${appData.playJockeyRandomEnabled ? 'On' : 'Off'}`;
    }

    function cyclePlayJockeyRepeat() {
        const states = ["off", "playlist", "song"];
        let currentIndex = states.indexOf(appData.playJockeyRepeatState);
        currentIndex = (currentIndex + 1) % states.length;
        appData.playJockeyRepeatState = states[currentIndex];

        appData.playJockeyRandomHistory = [];
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (appData.playJockeyRandomEnabled && appData.playJockeyCurrentVideo && currentPlaylist && currentPlaylist.videos.length > 0) {
             if (currentPlaylist.videos.length > 1 || appData.playJockeyRepeatState !== "off") {
                 appData.playJockeyRandomHistory.push(appData.playJockeyCurrentVideo.id);
            }
        }
        updatePlayJockeyRepeatButtonState();
        saveData();
    }

    function updatePlayJockeyRepeatButtonState() {
        DOM.playJockeyRepeatBtn.classList.remove('repeat-on');
        switch (appData.playJockeyRepeatState) {
            case "off":
                DOM.playJockeyRepeatBtn.textContent = 'Repeat: Off';
                break;
            case "playlist":
                DOM.playJockeyRepeatBtn.textContent = 'Repeat: List';
                DOM.playJockeyRepeatBtn.classList.add('repeat-on');
                break;
            case "song":
                DOM.playJockeyRepeatBtn.textContent = 'Repeat: One';
                DOM.playJockeyRepeatBtn.classList.add('repeat-on');
                break;
        }
    }

    // --- Gemini Chat Functions ---
    function renderGeminiChatHistory() {
        if (!DOM.geminiChatDisplayArea) return;
        DOM.geminiChatDisplayArea.innerHTML = '';

        const history = appData.geminiChatHistory || [];
        history.forEach(msg => {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('gemini-chat-message');

            const senderSpan = document.createElement('span');
            senderSpan.classList.add('message-sender');

            const contentSpan = document.createElement('span');
            contentSpan.classList.add('message-content');
            contentSpan.textContent = msg.content;

            const timestampSpan = document.createElement('span');
            timestampSpan.classList.add('message-timestamp');
            timestampSpan.textContent = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';


            if (msg.type === 'user') {
                messageDiv.classList.add('user-message');
                senderSpan.textContent = 'You';
            } else if (msg.type === 'gemini') {
                messageDiv.classList.add('gemini-message');
                senderSpan.textContent = 'Gemini';
                if (msg.isError) {
                    messageDiv.classList.add('error-message');
                }
            }

            messageDiv.appendChild(senderSpan);
            messageDiv.appendChild(contentSpan);
            messageDiv.appendChild(timestampSpan);
            DOM.geminiChatDisplayArea.appendChild(messageDiv);
        });

        DOM.geminiChatDisplayArea.scrollTop = DOM.geminiChatDisplayArea.scrollHeight;
    }

    function addMessageToGeminiChat(type, content, isError = false) {
        if (!appData.geminiChatHistory) {
            appData.geminiChatHistory = [];
        }
        appData.geminiChatHistory.push({
            type: type,
            content: content,
            isError: isError,
            timestamp: new Date().toISOString()
        });
        renderGeminiChatHistory();
        saveData();
    }

    function handleClearGeminiChatHistory() {
        openModal(MODAL_IDS.CONFIRM_CLEAR_CHAT);
    }

    function confirmClearChat() {
        appData.geminiChatHistory = [];
        renderGeminiChatHistory();
        saveData();
        closeModal(MODAL_IDS.CONFIRM_CLEAR_CHAT);
    }

    async function handleSendGeminiPrompt() {
        const promptText = DOM.geminiChatPromptInput.value.trim();
        if (!promptText) return;

        addMessageToGeminiChat('user', promptText);
        DOM.geminiChatPromptInput.value = '';
        DOM.geminiChatPromptInput.disabled = true;
        DOM.geminiChatSendBtn.disabled = true;


        if (!GEMINI_API_KEY) {
            addMessageToGeminiChat('gemini', "Error: Gemini API Key is not configured or could not be loaded. Please set it in Firebase Remote Config.", true);
            DOM.geminiChatPromptInput.disabled = false;
            DOM.geminiChatSendBtn.disabled = false;
            DOM.geminiChatPromptInput.focus();
            return;
        }

        const thinkingMsgId = `gemini-thinking-${Date.now()}`;
        const thinkingDiv = document.createElement('div');
        thinkingDiv.classList.add('gemini-chat-message', 'gemini-message');
        thinkingDiv.id = thinkingMsgId;
        thinkingDiv.innerHTML = `<span class="message-sender">Gemini</span><span class="message-content">Thinking...</span>`;
        DOM.geminiChatDisplayArea.appendChild(thinkingDiv);
        DOM.geminiChatDisplayArea.scrollTop = DOM.geminiChatDisplayArea.scrollHeight;


        try {
            const requestBody = {
                contents: [{
                    parts: [{ "text": promptText }]
                }]
            };
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            const existingThinkingDiv = getById(thinkingMsgId);
            if (existingThinkingDiv) existingThinkingDiv.remove();

            if (!response.ok) {
                const errorData = await response.json();
                console.error("Gemini API Error:", errorData);
                const errorMessage = errorData?.error?.message || `API request failed with status ${response.status}`;
                addMessageToGeminiChat('gemini', `Error: ${errorMessage}`, true);
            } else {
                const data = await response.json();
                if (data.candidates && data.candidates.length > 0 &&
                    data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
                    const geminiResponse = data.candidates[0].content.parts[0].text;
                    addMessageToGeminiChat('gemini', geminiResponse);
                } else if (data.promptFeedback && data.promptFeedback.blockReason) {
                     addMessageToGeminiChat('gemini', `Blocked: ${data.promptFeedback.blockReason}. ${data.promptFeedback.blockReasonMessage || ''}`, true);
                }
                 else {
                    addMessageToGeminiChat('gemini', "Received an empty or unexpected response from Gemini.", true);
                    console.warn("Unexpected Gemini API response structure:", data);
                }
            }
        } catch (error) {
            console.error("Error calling Gemini API:", error);
            const existingThinkingDiv = getById(thinkingMsgId);
            if (existingThinkingDiv) existingThinkingDiv.remove();
            addMessageToGeminiChat('gemini', `Error: Could not connect to Gemini. ${error.message}`, true);
        } finally {
            DOM.geminiChatPromptInput.disabled = false;
            DOM.geminiChatSendBtn.disabled = false;
            DOM.geminiChatPromptInput.focus();
        }
    }

    // --- Pixel App Functions ---
    function initPixelApp() {
        pixelCtx = DOM.pixelCanvas.getContext('2d');
        DOM.pixelCanvas.width = appData.pixelAppData.canvasWidth;
        DOM.pixelCanvas.height = appData.pixelAppData.canvasHeight;
        pixelCtx.fillStyle = 'white';
        pixelCtx.fillRect(0, 0, DOM.pixelCanvas.width, DOM.pixelCanvas.height);

        appData.pixelAppData.pencilSize = parseInt(appData.pixelAppData.pencilSize) || 2;
        if (appData.pixelAppData.pencilSize < 1) appData.pixelAppData.pencilSize = 1;
        if (appData.pixelAppData.pencilSize > 50) appData.pixelAppData.pencilSize = 50;

        DOM.pixelColorPicker.value = appData.pixelAppData.currentColor;
        DOM.pixelSizeInput.value = appData.pixelAppData.pencilSize;

        DOM.pixelColorPicker.addEventListener('input', (e) => {
            appData.pixelAppData.currentColor = e.target.value;
            saveData();
        });

        DOM.pixelSizeInput.addEventListener('input', (e) => {
            let newSize = parseInt(e.target.value);
            if (isNaN(newSize) || newSize < 1) newSize = 1;
            if (newSize > 50) newSize = 50;
            e.target.value = newSize;
            appData.pixelAppData.pencilSize = newSize;
            saveData();
        });
         DOM.pixelSizeInput.addEventListener('change', (e) => {
            let newSize = parseInt(e.target.value);
            if (isNaN(newSize) || newSize < 1) newSize = 1;
            if (newSize > 50) newSize = 50;
            e.target.value = newSize;
            appData.pixelAppData.pencilSize = newSize;
            saveData();
        });


        DOM.pixelPencilTool.addEventListener('click', () => setPixelTool('pencil'));
        DOM.pixelEraserTool.addEventListener('click', () => setPixelTool('eraser'));
        DOM.pixelBucketTool.addEventListener('click', () => setPixelTool('bucket'));

        DOM.pixelCanvas.addEventListener('mousedown', startPixelDrawing);
        DOM.pixelCanvas.addEventListener('mouseup', stopPixelDrawing);
        DOM.pixelCanvas.addEventListener('mouseout', stopPixelDrawing);
        DOM.pixelCanvas.addEventListener('mousemove', pixelDraw);
        DOM.pixelCanvas.addEventListener('click', pixelBucketFill);

        DOM.pixelFileSave.addEventListener('click', savePixelCanvas);
        DOM.pixelFileClearCanvas.addEventListener('click', clearPixelCanvas);


        let pixelActiveMenu = null;
        DOM.pixelMenuBar.querySelectorAll('.pixel-menu-bar > .pixel-menu-item').forEach(menuItem => {
            menuItem.addEventListener('click', (event) => {
                event.stopPropagation();
                if (pixelActiveMenu && pixelActiveMenu !== menuItem) {
                    pixelActiveMenu.classList.remove('open');
                }
                menuItem.classList.toggle('open');
                pixelActiveMenu = menuItem.classList.contains('open') ? menuItem : null;
            });
        });
        window.addEventListener('click', (event) => {
            if (pixelActiveMenu && !pixelActiveMenu.contains(event.target) && !event.target.closest('.pixel-menu-item')) {
                pixelActiveMenu.classList.remove('open');
                pixelActiveMenu = null;
            }
        });

        setPixelTool(appData.pixelAppData.currentTool);
    }

    function setPixelTool(tool) {
        appData.pixelAppData.currentTool = tool;
        DOM.pixelPencilTool.classList.remove('active');
        DOM.pixelEraserTool.classList.remove('active');
        DOM.pixelBucketTool.classList.remove('active');

        if (tool === 'pencil') {
            DOM.pixelPencilTool.classList.add('active');
            DOM.pixelCanvas.style.cursor = 'crosshair';
        } else if (tool === 'eraser') {
            DOM.pixelEraserTool.classList.add('active');
            DOM.pixelCanvas.style.cursor = 'crosshair';
        } else if (tool === 'bucket') {
            DOM.pixelBucketTool.classList.add('active');
            DOM.pixelCanvas.style.cursor = 'copy';
        }
        saveData();
    }

    function handlePixelWindowResize() {
        if (DOM.pixelWindow.classList.contains('minimized') || DOM.pixelWindow.style.display === 'none') return;

        const container = DOM.pixelCanvasContainer;
        const canvas = DOM.pixelCanvas;

        const padding = 10;
        const menuBarHeight = DOM.pixelMenuBar.offsetHeight;
        const toolbarHeight = DOM.pixelWindow.querySelector('.pixel-toolbar').offsetHeight;

        const availableWidth = container.clientWidth - padding;
        const availableHeight = DOM.pixelWindowBody.clientHeight - menuBarHeight - toolbarHeight - padding - 5;


        if (availableWidth > 0 && availableHeight > 0) {
            const aspectRatio = appData.pixelAppData.canvasWidth / appData.pixelAppData.canvasHeight;
            let newCanvasWidth = availableWidth;
            let newCanvasHeight = newCanvasWidth / aspectRatio;

            if (newCanvasHeight > availableHeight) {
                newCanvasHeight = availableHeight;
                newCanvasWidth = newCanvasHeight * aspectRatio;
            }

            canvas.style.width = Math.max(50, newCanvasWidth) + 'px';
            canvas.style.height = Math.max(50, newCanvasHeight) + 'px';
        }
    }


    function startPixelDrawing(e) {
        if (appData.pixelAppData.currentTool === 'bucket') return;
        pixelIsDrawing = true;
        [pixelLastX, pixelLastY] = [e.offsetX, e.offsetY];

        const scaleX = DOM.pixelCanvas.width / DOM.pixelCanvas.offsetWidth;
        const scaleY = DOM.pixelCanvas.height / DOM.pixelCanvas.offsetHeight;
        const canvasX = e.offsetX * scaleX;
        const canvasY = e.offsetY * scaleY;

        const size = parseInt(appData.pixelAppData.pencilSize);
        const drawX = Math.floor(canvasX - size / 2);
        const drawY = Math.floor(canvasY - size / 2);


        if (appData.pixelAppData.currentTool === 'pencil') {
            pixelCtx.fillStyle = appData.pixelAppData.currentColor;
            pixelCtx.globalCompositeOperation = 'source-over';
            pixelCtx.fillRect(drawX, drawY, size, size);
        } else if (appData.pixelAppData.currentTool === 'eraser') {
            pixelCtx.globalCompositeOperation = 'destination-out';
            pixelCtx.fillRect(drawX, drawY, size, size);
        }
    }

    function stopPixelDrawing() {
        pixelIsDrawing = false;
    }

    function pixelDraw(e) {
        if (!pixelIsDrawing || appData.pixelAppData.currentTool === 'bucket') return;

        const scaleX = DOM.pixelCanvas.width / DOM.pixelCanvas.offsetWidth;
        const scaleY = DOM.pixelCanvas.height / DOM.pixelCanvas.offsetHeight;

        const x1 = e.offsetX * scaleX;
        const y1 = e.offsetY * scaleY;
        const x0 = pixelLastX * scaleX;
        const y0 = pixelLastY * scaleY;


        const size = parseInt(appData.pixelAppData.pencilSize);

        const dx = x1 - x0;
        const dy = y1 - y0;
        const steps = Math.max(Math.abs(dx), Math.abs(dy));

        const xIncrement = steps === 0 ? 0 : dx / steps;
        const yIncrement = steps === 0 ? 0 : dy / steps;

        let currentX = x0;
        let currentY = y0;

        if (appData.pixelAppData.currentTool === 'pencil') {
            pixelCtx.fillStyle = appData.pixelAppData.currentColor;
            pixelCtx.globalCompositeOperation = 'source-over';
        } else if (appData.pixelAppData.currentTool === 'eraser') {
            pixelCtx.globalCompositeOperation = 'destination-out';
        }

        for (let i = 0; i <= steps; i++) {
            const drawX = Math.floor(currentX - size / 2);
            const drawY = Math.floor(currentY - size / 2);
            pixelCtx.fillRect(drawX, drawY, size, size);
            currentX += xIncrement;
            currentY += yIncrement;
        }

        [pixelLastX, pixelLastY] = [e.offsetX, e.offsetY];
    }


    function pixelBucketFill(e) {
        if (appData.pixelAppData.currentTool !== 'bucket') return;
        pixelCtx.globalCompositeOperation = 'source-over';

        const scaleX = DOM.pixelCanvas.width / DOM.pixelCanvas.offsetWidth;
        const scaleY = DOM.pixelCanvas.height / DOM.pixelCanvas.offsetHeight;
        const x = Math.floor(e.offsetX * scaleX);
        const y = Math.floor(e.offsetY * scaleY);


        const canvasWidth = DOM.pixelCanvas.width;
        const canvasHeight = DOM.pixelCanvas.height;
        const imageData = pixelCtx.getImageData(0, 0, canvasWidth, canvasHeight);
        const data = imageData.data;

        const startPixelIndex = (y * canvasWidth + x) * 4;
        const targetColor = [data[startPixelIndex], data[startPixelIndex + 1], data[startPixelIndex + 2], data[startPixelIndex + 3]];

        const fillColorHex = appData.pixelAppData.currentColor;
        const rFill = parseInt(fillColorHex.slice(1, 3), 16);
        const gFill = parseInt(fillColorHex.slice(3, 5), 16);
        const bFill = parseInt(fillColorHex.slice(5, 7), 16);
        const fillColor = [rFill, gFill, bFill, 255];

        if (targetColor[0] === fillColor[0] && targetColor[1] === fillColor[1] && targetColor[2] === fillColor[2] && targetColor[3] === fillColor[3]) {
            return;
        }

        const stack = [[x, y]];
        const visited = new Set();

        while (stack.length > 0) {
            const [currentX, currentY] = stack.pop();
            const pixelKey = `${currentX},${currentY}`;

            if (currentX < 0 || currentX >= canvasWidth || currentY < 0 || currentY >= canvasHeight || visited.has(pixelKey) ) {
                continue;
            }
            visited.add(pixelKey);

            const currentIndex = (currentY * canvasWidth + currentX) * 4;
            const currentColor = [data[currentIndex], data[currentIndex + 1], data[currentIndex + 2], data[currentIndex + 3]];

            if (currentColor[0] === targetColor[0] && currentColor[1] === targetColor[1] && currentColor[2] === targetColor[2] && currentColor[3] === targetColor[3]) {
                data[currentIndex]     = fillColor[0];
                data[currentIndex + 1] = fillColor[1];
                data[currentIndex + 2] = fillColor[2];
                data[currentIndex + 3] = fillColor[3];

                stack.push([currentX + 1, currentY]);
                stack.push([currentX - 1, currentY]);
                stack.push([currentX, currentY + 1]);
                stack.push([currentX, currentY - 1]);
            }
        }
        pixelCtx.putImageData(imageData, 0, 0);
    }


    function savePixelCanvas() {
        let filename = prompt("Filename for your masterpiece:", "pixel_art.png");
        if (filename) {
            if (!filename.toLowerCase().endsWith('.png')) {
                filename += '.png';
            }
            const dataURL = DOM.pixelCanvas.toDataURL('image/png');
            const downloadLink = document.createElement('a');
            downloadLink.href = dataURL;
            downloadLink.download = filename;
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }
        const pixelFileMenu = DOM.pixelFileSave.closest('.pixel-menu-item');
        if(pixelFileMenu && pixelFileMenu.classList.contains('open')) {
            pixelFileMenu.classList.remove('open');
        }
    }

    function clearPixelCanvas() {
        if (pixelCtx && DOM.pixelCanvas) {
            pixelCtx.fillStyle = 'white';
            pixelCtx.fillRect(0, 0, DOM.pixelCanvas.width, DOM.pixelCanvas.height);
        }
        const pixelFileMenu = DOM.pixelFileClearCanvas.closest('.pixel-menu-item');
        if(pixelFileMenu && pixelFileMenu.classList.contains('open')) {
            pixelFileMenu.classList.remove('open');
        }
    }

    function openPixelCanvasSizeModal() {
        DOM.pixelNewCanvasWidthInput.value = appData.pixelAppData.canvasWidth;
        DOM.pixelNewCanvasHeightInput.value = appData.pixelAppData.canvasHeight;
        openModal(MODAL_IDS.PIXEL_CANVAS_SIZE);
        const pixelFileMenu = DOM.pixelFileCanvasSize.closest('.pixel-menu-item');
         if(pixelFileMenu && pixelFileMenu.classList.contains('open')) {
            pixelFileMenu.classList.remove('open');
        }
    }

    function handleSavePixelCanvasSize() {
        const newWidth = parseInt(DOM.pixelNewCanvasWidthInput.value);
        const newHeight = parseInt(DOM.pixelNewCanvasHeightInput.value);

        if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 50 || newWidth > 2000 || newHeight < 50 || newHeight > 2000) {
            alert("Invalid canvas dimensions. Width and height must be between 50 and 2000 pixels.");
            return;
        }
        closeModal(MODAL_IDS.PIXEL_CANVAS_SIZE);
        openModal(MODAL_IDS.CONFIRM_PIXEL_RESIZE);
    }

    function executePixelCanvasResize() {
        const newWidth = parseInt(DOM.pixelNewCanvasWidthInput.value);
        const newHeight = parseInt(DOM.pixelNewCanvasHeightInput.value);

        if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 50 || newWidth > 2000 || newHeight < 50 || newHeight > 2000) {
            alert("Invalid canvas dimensions. Width and height must be between 50 and 2000 pixels.");
            closeModal(MODAL_IDS.CONFIRM_PIXEL_RESIZE);
            return;
        }

        appData.pixelAppData.canvasWidth = newWidth;
        appData.pixelAppData.canvasHeight = newHeight;

        DOM.pixelCanvas.width = newWidth;
        DOM.pixelCanvas.height = newHeight;

        clearPixelCanvas();
        handlePixelWindowResize();
        saveData();

        closeModal(MODAL_IDS.CONFIRM_PIXEL_RESIZE);
    }


    function openModal(modalId) {
        const modal = getById(modalId);
        if (modal) {
            modal.style.display = 'flex';
        } else {
            console.error(`Modal with ID "${modalId}" not found.`);
        }
    }

    function closeModal(modalId) {
        const modal = getById(modalId);
         if (modal) {
            modal.style.display = 'none';
        } else {
            console.error(`Modal with ID "${modalId}" not found for closing.`);
        }
    }

    async function fetchFirebaseConfigAndInit() {
        console.log("Attempting to fetch Firebase Remote Config...");
        try {
            await remoteConfig.fetchAndActivate();
            console.log("Firebase Remote Config fetched and activated successfully.");

            YOUTUBE_API_KEY = remoteConfig.getString('youtube_api_key');
            GEMINI_API_KEY = remoteConfig.getString('gemini_api_key');

            if (!YOUTUBE_API_KEY) {
                console.warn("YouTube API Key was not found or is empty in Firebase Remote Config.");
            } else {
                console.log("YouTube API Key loaded.");
            }

            if (!GEMINI_API_KEY) {
                console.warn("Gemini API Key was not found or is empty in Firebase Remote Config.");
            } else {
                console.log("Gemini API Key loaded.");
            }

        } catch (err) {
            console.error("Firebase Remote Config failed to load. Using default/empty keys.", err);
        } finally {
            init();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetchFirebaseConfigAndInit();
    });

</script>
</body>
</html>
