<style>
    :root {
        --bg-color: #ECE9D8;
        --surface-color: #F0F0F0;
        --border-color: #ACA899;
        --border-highlight-color: #7F7F7F;
        --header-bg-color: #D4D0C8;
        --button-bg-color: #ECE9D8;
        --button-text-color: #000000;
        --button-hover-border: #005CFE;
        --text-color: #000000;
        --primary-color: #005CFE;
        --today-highlight-bg: #005CFE;
        --today-highlight-text: #FFFFFF;
    }

    body {
        margin: 0;
        padding: 15px;
        font-family: "Tahoma", "Geneva", sans-serif;
        font-size: 12px;
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        box-sizing: border-box;
    }

    .moon-calendar-app {
        width: 100%;
        height: 100%;
        background-color: var(--bg-color);
        display: flex;
        flex-direction: column;
    }

    .controls-bar {
        display: flex;
        margin-bottom: 15px;
        padding: 8px;
        border: 1px solid var(--border-color);
        background-color: var(--surface-color);
        flex-shrink: 0;
    }

    .controls-bar.layout-single-row {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        flex-wrap: nowrap;
    }
    .controls-bar.layout-single-row > div {
        margin: 2px 5px;
        flex-shrink: 0;
    }
    .controls-bar.layout-multi-row {
        flex-direction: column;
        align-items: stretch;
    }
    .controls-bar.layout-multi-row > div {
        width: 100%;
        box-sizing: border-box;
        margin-bottom: 8px;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        padding: 5px 0;
    }
    .controls-bar.layout-multi-row > div:last-child {
        margin-bottom: 0;
    }
    .controls-bar.layout-multi-row .controls-group {
        text-align: center;
    }
    
    .date-navigation, .view-actions {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
        gap: 5px;
    }

    .controls-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 10px;
        text-align: center;
        gap: 5px;
    }

    .xp-button {
        background-color: var(--button-bg-color);
        border: 1px outset var(--border-highlight-color);
        padding: 5px 12px;
        min-width: 75px;
        text-align: center;
        cursor: pointer;
        font-family: inherit;
        font-size: 11px;
    }
    .xp-button:active, .xp-button.active {
        border-style: inset;
    }
    .xp-button:hover {
        border-color: var(--button-hover-border);
    }

    .view-title {
        font-weight: bold;
        font-size: 1.1em;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
    }

    .app-view-container {
        flex-grow: 1;
        overflow: auto;
        position: relative;
        border: 1px solid var(--border-highlight-color);
        background-color: var(--surface-color);
    }

    .app-view {
        display: none;
        width: 100%;
        height: 100%;
        padding: 3px;
        box-sizing: border-box;
    }

    .app-view.active {
        display: block;
    }

    .calendar-table {
        width: 100%;
        height: 100%;
        table-layout: fixed;
        border-collapse: collapse;
    }

    .calendar-table th, .calendar-table td {
        border: 1px solid var(--border-color);
        padding: 8px;
        text-align: center;
        vertical-align: top;
    }

    .calendar-table th {
        background-color: var(--header-bg-color);
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .cycle-day-cell, .quarter-day-cell {
        position: relative;
    }

    #quarter-view.active {
        display: flex;
        flex-direction: column;
    }

    .cycle-day-cell .moon-event-icon {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, 0vh);
        width: 100%;
    }

    .quarter-day-cell .moon-event-icon {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100%;
    }

    .day-number { font-weight: bold; font-size: 1.2em; margin-bottom: 5px;  }
    .cycle-day-cell.other-month { opacity: 0.5; background-color: #F5F5F5; }
    
    .cycle-day-cell .day-number,
    .quarter-day-header .day-number {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        padding: 2px;
        box-sizing: border-box;
    }

    .cycle-day-cell .day-number.today,
    .quarter-day-header.today .day-number {
        background-color: var(--today-highlight-bg);
        color: var(--today-highlight-text);
    }

    .moon-event-icon { font-size: 24px; text-align: center; align-items: center; vertical-align: center; }
    .moon-event-details { font-size: 0.9em; margin-top: 5px; }

    #quarter-grid-header-container {
        position: sticky;
        background: var(--surface-color);
        z-index: 9;
    }
    .quarter-header-table { width: 100%; border-collapse: collapse; table-layout: fixed; }
    .quarter-day-name { color: #555; }

    #day-view-content { height: 100%; overflow-y: auto; }
    .day-schedule-table { width: 100%; border-collapse: collapse; }
    .day-schedule-table td { border: none; border-bottom: 1px solid #E0E0E0; vertical-align: middle; }
    .time-label-cell { width: 80px; text-align: right; padding-right: 10px; color: #555; border-right: 1px solid var(--border-color); }
    .schedule-grid-cell { position: relative; height: 60px; }
    .moon-event {
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
        background-color: #6c5ce7;
        color: #fff;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        font-size: 24px;
        z-index: 5;
        display: flex;
        align-items: center;
        justify-content: center;
        border: 2px solid #fff;
    }

    /* New Weather Styles */
    .weather-info {
        font-size: 0.9em;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        margin-top: 4px;
    }
    .weather-temp {
        font-weight: bold;
    }
    .weather-emoji {
        font-size: 1.4em;
        line-height: 1;
    }
    #view-title-display .weather-info {
        flex-direction: row;
        gap: 8px;
        align-items: center;
        margin-top: 0;
    }

</style>

<div class="moon-calendar-app">
    <header class="controls-bar" id="controlsBar">
         <div class="date-navigation" id="date-nav-controls">
            </div>
        <div class="controls-group">
            <div class="view-title" id="view-title-display">Loading...</div>
        </div>
        <div class="view-actions" id="main-nav-buttons">
            <button class="xp-button active" data-view="day-view">Day</button>
            <button class="xp-button" data-view="quarter-view">Quarter</button>
            <button class="xp-button" data-view="cycle-view">Cycle</button>
        </div>
    </header>

    <div class="app-view-container">
        <div id="day-view" class="app-view active"></div>
        <div id="quarter-view" class="app-view"></div>
        <div id="cycle-view" class="app-view"></div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    const DAY_NAMES_SHORT = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const FULL_PHASE_NAMES = ["New Moon", "Waxing Crescent", "First Quarter", "Waxing Gibbous", "Full Moon", "Waning Gibbous", "Last Quarter", "Waning Crescent"];
    const PHASE_EMOJIS = ['üåë', 'üåí', 'üåì', 'üåî', 'üåï', 'üåñ', 'üåó', 'üåò'];
    const PRIMARY_PHASE_NAMES = ["New Moon", "First Quarter", "Full Moon", "Last Quarter"];
    const NEW_FULL_MOON_NAMES = ["New Moon", "Full Moon"];

    let viewDate = new Date();
    let currentView = 'day-view';
    let allMoonEvents = [];
    const moonDataCache = {};
    let isLoading = false;

    // --- New Weather Variables ---
    let openWeatherApiKey = null;
    let userLocation = null; // { latitude, longitude }
    const weatherDataCache = {};


    const controlsBar = document.getElementById('controlsBar');
    const mainNavButtons = document.getElementById('main-nav-buttons');
    const viewTitleDisplay = document.getElementById('view-title-display');
    const dateNavControls = document.getElementById('date-nav-controls');
    const views = {
        'day-view': document.getElementById('day-view'),
        'quarter-view': document.getElementById('quarter-view'),
        'cycle-view': document.getElementById('cycle-view')
    };
    
    // --- New Weather Functions ---

    /**
     * Requests the OpenWeather API key from the parent window (index.html).
     */
    function requestApiKey() {
        if (window.parent) {
            console.log("Requesting OpenWeather API key from parent...");
            window.parent.postMessage({ type: 'requestApiKey', appId: 'almanac', service: 'openWeather' }, '*');
        } else {
             console.error("Not in an iframe, cannot request API key.");
             viewTitleDisplay.innerHTML = "Weather unavailable: Cannot request API key.";
        }
    }

    /**
     * Handles receiving messages from the parent, specifically the API key.
     */
    window.addEventListener('message', (event) => {
        if (event.data.type === 'apiKeyResponse' && event.data.service === 'openWeather') {
            openWeatherApiKey = event.data.key;
            if (openWeatherApiKey) {
                console.log('OpenWeather API Key received.');
                initWeather();
            } else {
                console.error('OpenWeather API Key not received.');
                viewTitleDisplay.innerHTML = "Weather unavailable: API Key is missing.";
            }
        }
    });

    /**
     * Initializes weather functionality by getting user's location.
     */
    function initWeather() {
        if (!navigator.geolocation) {
            console.error("Geolocation is not supported by this browser.");
            viewTitleDisplay.innerHTML = "Weather unavailable: Geolocation not supported.";
            // Still render the rest of the app without weather
            updateAllViews();
            return;
        }

        navigator.geolocation.getCurrentPosition(
            (position) => {
                userLocation = {
                    latitude: position.coords.latitude,
                    longitude: position.coords.longitude
                };
                console.log('User location obtained:', userLocation);
                // Once location is known, update the views
                updateAllViews();
            },
            () => {
                 console.error("Geolocation access denied by user.");
                 viewTitleDisplay.innerHTML = "Weather unavailable: Geolocation access denied.";
                 // Still render the rest of the app without weather
                 updateAllViews();
            }
        );
    }
    
    /**
     * Gets a date string in YYYY-MM-DD format for cache keys.
     */
    function getYYYYMMDD(date) {
        const d = new Date(date);
        d.setMinutes(d.getMinutes() - d.getTimezoneOffset());
        return d.toISOString().split('T')[0];
    }

    /**
     * Fetches weather data for a specific location. Uses a cache to be efficient.
     * One API call fetches 8 days of forecast data.
     */
    async function fetchWeatherDataForDay(date) {
        if (!openWeatherApiKey || !userLocation) return null;

        const dateKey = getYYYYMMDD(date);
        if (weatherDataCache[dateKey]) {
            return weatherDataCache[dateKey];
        }

        // Only make a new API call if we don't have any cached data at all.
        // A single call will populate data for the next 8 days.
        if (Object.keys(weatherDataCache).length > 0) {
            // Check if ANY cached item is recent enough.
            const mostRecentCacheKey = Object.keys(weatherDataCache).sort().pop();
            const todayKey = getYYYYMMDD(new Date());
            if (mostRecentCacheKey >= todayKey) {
                return null; // We have future data, but not for this specific day. Don't re-fetch yet.
            }
        }

        const { latitude, longitude } = userLocation;
        const API_URL = `https://api.openweathermap.org/data/3.0/onecall?lat=${latitude}&lon=${longitude}&exclude=minutely,hourly,alerts&appid=${openWeatherApiKey}&units=metric`;

        try {
            const response = await fetch(API_URL);
            if (!response.ok) throw new Error(`Weather API Error: ${response.status}`);
            
            const data = await response.json();
            
            // Clear old cache and populate with new forecast
            Object.keys(weatherDataCache).forEach(key => delete weatherDataCache[key]);
            
            data.daily.forEach((dailyData, index) => {
                const forecastDate = new Date();
                forecastDate.setUTCHours(0,0,0,0);
                forecastDate.setUTCDate(forecastDate.getUTCDate() + index);
                const forecastDateKey = getYYYYMMDD(forecastDate);
                
                weatherDataCache[forecastDateKey] = {
                    currentTemp: (index === 0) ? data.current.temp : null,
                    min: dailyData.temp.min,
                    max: dailyData.temp.max,
                    main: dailyData.weather[0].main,
                };
            });
            
            console.log("Weather data fetched and cached for 8 days.");
            return weatherDataCache[dateKey] || null;

        } catch (error) {
            console.error(`Failed to fetch weather data:`, error);
            return null;
        }
    }

    /**
     * Returns an emoji for a given weather condition string.
     */
    function getWeatherEmoji(weatherMain) {
        if (!weatherMain) return '';
        const lowerCaseMain = weatherMain.toLowerCase();
        if (lowerCaseMain.includes('thunderstorm')) return '‚õàÔ∏è';
        if (lowerCaseMain.includes('drizzle')) return 'üíß';
        if (lowerCaseMain.includes('rain')) return 'üåßÔ∏è';
        if (lowerCaseMain.includes('snow')) return '‚ùÑÔ∏è';
        if (lowerCaseMain.includes('mist') || lowerCaseMain.includes('fog') || lowerCaseMain.includes('haze') || lowerCaseMain.includes('smoke')) return 'üå´Ô∏è';
        if (lowerCaseMain.includes('clear')) return '‚òÄÔ∏è';
        if (lowerCaseMain.includes('clouds')) return '‚òÅÔ∏è';
        return 'üå°Ô∏è';
    }


    async function fetchAndProcessMoonData(year) {
        if (moonDataCache[year]) {
            return moonDataCache[year];
        }
        const API_URL = `https://aa.usno.navy.mil/api/moon/phases/year?year=${year}`;
        try {
            const response = await fetch(API_URL);
            if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
            }
            const data = await response.json();
            
            const processedData = data.phasedata.map(evt => {
                const dateStr = `${evt.year}-${String(evt.month).padStart(2, '0')}-${String(evt.day).padStart(2, '0')}T${evt.time}:00Z`;
                return {
                    name: evt.phase,
                    date: new Date(dateStr),
                    emoji: PHASE_EMOJIS[PRIMARY_PHASE_NAMES.indexOf(evt.phase) * 2] || '‚ùì'
                };
            });
            
            moonDataCache[year] = processedData;
            return processedData;
        } catch (error) {
            console.error(`Failed to fetch moon data for ${year}:`, error);
            moonDataCache[year] = []; 
            return [];
        }
    }
    
    async function loadRequiredMoonData(date) {
        if (isLoading) return;
        isLoading = true;
        viewTitleDisplay.innerHTML = "Loading...";

        const year = date.getFullYear();
        const requiredYears = [year - 1, year, year + 1];
        
        const promises = requiredYears.map(y => fetchAndProcessMoonData(y));
        await Promise.all(promises);

        let combinedEvents = [];
        for (const y of requiredYears) {
            if(moonDataCache[y]) {
                combinedEvents.push(...moonDataCache[y]);
            }
        }
        
        const uniqueEvents = Array.from(new Map(combinedEvents.map(event => [event.date.toISOString(), event])).values());
        allMoonEvents = uniqueEvents.sort((a, b) => a.date - b.date);

        isLoading = false;
    }

    function getCycleBoundaries(date) {
        const time = date.getTime();
        const newMoons = allMoonEvents.filter(e => e.name === "New Moon");
        let startEvent, endEvent;
        for (let i = 0; i < newMoons.length - 1; i++) {
            if (time >= newMoons[i].date.getTime() && time < newMoons[i+1].date.getTime()) {
                startEvent = newMoons[i];
                endEvent = newMoons[i+1];
                break;
            }
        }
        return [startEvent, endEvent];
    }

    function getQuarterBoundaries(date) {
        const time = date.getTime();
        const majorEvents = allMoonEvents.filter(e => NEW_FULL_MOON_NAMES.includes(e.name));
        let startEvent, endEvent;
        for (let i = 0; i < majorEvents.length - 1; i++) {
             if (time >= majorEvents[i].date.getTime() && time < majorEvents[i+1].date.getTime()) {
                startEvent = majorEvents[i];
                endEvent = majorEvents[i+1];
                break;
            }
        }
        return [startEvent, endEvent];
    }
    
    function daysInMilliseconds(days) { return days * 24 * 60 * 60 * 1000; }
    
    function isSameDay(d1, d2) { if (!d1 || !d2) return false; return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth() && d1.getDate() === d2.getDate(); }
    function isSameUTCDay(d1, d2) {
        if (!d1 || !d2) return false;
        return d1.getUTCFullYear() === d2.getUTCFullYear() &&
               d1.getUTCMonth() === d2.getUTCMonth() &&
               d1.getUTCDate() === d2.getUTCDate();
    }
    function getMonthName(date) { return date.toLocaleDateString(undefined, { month: 'long', timeZone: 'UTC' }); }
    function formatQuarterTitleDate(date) { return `${getMonthName(date)} ${date.getUTCDate()}${getOrdinalSuffix(date.getUTCDate())}`; }
    function getOrdinalSuffix(i) {
        var j = i % 10, k = i % 100;
        if (j == 1 && k != 11) return "st";
        if (j == 2 && k != 12) return "nd";
        if (j == 3 && k != 13) return "rd";
        return "th";
    }

    function checkControlsBarLayout() {
        if (!controlsBar || !controlsBar.clientWidth) return;
        const children = [
            controlsBar.querySelector('.date-navigation'),
            controlsBar.querySelector('.controls-group'),
            controlsBar.querySelector('.view-actions')
        ].filter(el => el);
        if (children.length === 0) return;
        
        const originalClasses = controlsBar.className;
        controlsBar.className = 'controls-bar layout-single-row';
        let totalChildrenWidth = 0;
        children.forEach(child => {
            const childStyle = getComputedStyle(child);
            totalChildrenWidth += child.scrollWidth + parseFloat(childStyle.marginLeft) + parseFloat(childStyle.marginRight);
        });
        controlsBar.className = originalClasses;

        const controlsBarClientWidth = controlsBar.clientWidth - (parseFloat(getComputedStyle(controlsBar).paddingLeft) + parseFloat(getComputedStyle(controlsBar).paddingRight));

        if (totalChildrenWidth > controlsBarClientWidth && controlsBarClientWidth > 0) {
            controlsBar.classList.add('layout-multi-row');
            controlsBar.classList.remove('layout-single-row');
        } else {
            controlsBar.classList.add('layout-single-row');
            controlsBar.classList.remove('layout-multi-row');
        }
    }
    
    function updateControls() {
        dateNavControls.innerHTML = '';
        const addNavButton = (text, clickHandler) => {
            const button = document.createElement('button');
            button.className = 'xp-button';
            button.textContent = text;
            button.addEventListener('click', clickHandler);
            dateNavControls.appendChild(button);
        };

        const goBackToToday = () => { viewDate = new Date(); updateAllViews(); };

        if (currentView === 'day-view') {
            addNavButton('< Prev Day', () => { viewDate.setDate(viewDate.getDate() - 1); updateAllViews(); });
            addNavButton('Today', goBackToToday);
            addNavButton('Next Day >', () => { viewDate.setDate(viewDate.getDate() + 1); updateAllViews(); });
        } else if (currentView === 'quarter-view') {
            addNavButton('< Prev Quarter', () => { const b = getQuarterBoundaries(viewDate); if(b[0]) { viewDate = new Date(b[0].date.getTime() - daysInMilliseconds(1)); } updateAllViews(); });
            addNavButton('Current Quarter', goBackToToday);
            addNavButton('Next Quarter >', () => { const b = getQuarterBoundaries(viewDate); if(b[1]) { viewDate = new Date(b[1].date.getTime() + 1000); } updateAllViews(); });
        } else if (currentView === 'cycle-view') {
            addNavButton('< Prev Cycle', () => { const b = getCycleBoundaries(viewDate); if (b[0]) { viewDate = new Date(b[0].date.getTime() - daysInMilliseconds(1)); } updateAllViews(); });
            addNavButton('Current Cycle', goBackToToday);
            addNavButton('Next Cycle >', () => { const b = getCycleBoundaries(viewDate); if (b[1]) { viewDate = new Date(b[1].date.getTime() + 1000); } updateAllViews(); });
        }
         setTimeout(checkControlsBarLayout, 0);
    }

    async function renderDayView() {
        const todaysEvents = allMoonEvents.filter(evt => isSameDay(evt.date, viewDate));
        const primaryEventToday = todaysEvents.find(evt => PRIMARY_PHASE_NAMES.includes(evt.name));
        let emoji;
        if (primaryEventToday) {
            emoji = primaryEventToday.emoji;
        } else {
            const [startCycle, endCycle] = getCycleBoundaries(viewDate);
            if (startCycle && endCycle) {
                const cycleDuration = endCycle.date.getTime() - startCycle.date.getTime();
                const age = viewDate.getTime() - startCycle.date.getTime();
                const phaseIndex = Math.floor((age / cycleDuration) * 8) % 8;
                emoji = PHASE_EMOJIS[phaseIndex];
            } else {
                emoji = '‚ùì';
            }
        }
        viewTitleDisplay.innerHTML = `<span>${emoji}</span> <span>${viewDate.toLocaleDateString(undefined, { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</span>`;
        
        // Add weather to title
        const weatherData = await fetchWeatherDataForDay(viewDate);
        if (weatherData && weatherData.currentTemp) {
            const weatherEmoji = getWeatherEmoji(weatherData.main);
            const temp = Math.round(weatherData.currentTemp);
            const weatherTitleEl = document.createElement('div');
            weatherTitleEl.className = 'weather-info';
            weatherTitleEl.innerHTML = `<span class="weather-emoji" title="${weatherData.main}">${weatherEmoji}</span> <span class="weather-temp">${temp}¬∞C</span>`;
            viewTitleDisplay.appendChild(weatherTitleEl);
        }

        const viewContainer = views['day-view'];
        viewContainer.innerHTML = '';
        const table = document.createElement('table');
        table.className = 'day-schedule-table';
        const tbody = document.createElement('tbody');
        for (let i = 0; i < 24; i++) {
            const tr = document.createElement('tr');
            const timeLabel = `${i === 0 ? '12' : (i > 12 ? i - 12 : i)} ${i < 12 ? 'AM' : 'PM'}`;
            tr.innerHTML = `<td class="time-label-cell">${timeLabel}</td><td class="schedule-grid-cell"></td>`;
            tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        viewContainer.innerHTML = `<div id="day-view-content"></div>`;
        viewContainer.firstChild.appendChild(table);
        todaysEvents.forEach((evt) => {
            const eventEl = document.createElement('div');
            eventEl.className = 'moon-event';
            eventEl.title = `${evt.name} at ${evt.date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' })}`;
            eventEl.innerHTML = `<span>${evt.emoji}</span>`;
            eventEl.style.top = `${(evt.date.getHours() * 60 + evt.date.getMinutes()) / (24*60) * 100}%`;
            const targetCell = tbody.children[evt.date.getHours()]?.querySelector('.schedule-grid-cell');
            if (targetCell) {
                targetCell.appendChild(eventEl);
            }
        });
    }
    
    async function renderQuarterView() {
        const today = new Date();
        const boundaries = getQuarterBoundaries(viewDate);

        if (!boundaries || !boundaries[0] || !boundaries[1]) {
            views['quarter-view'].innerHTML = "Not enough quarter data available for this date.";
            viewTitleDisplay.innerHTML = "Quarter Data Unavailable";
            return;
        }

        const startEvent = boundaries[0];
        const endEvent = boundaries[1];
        const startDate = startEvent.date;
        const endDate = endEvent.date;

        const startTitle = formatQuarterTitleDate(startDate);
        const endTitle = formatQuarterTitleDate(endDate);
        viewTitleDisplay.innerHTML = `<span>${startEvent.emoji}</span> <span>${startTitle} - ${endTitle} Quarter</span> <span>${endEvent.emoji}</span>`;
        
        const viewContainer = views['quarter-view'];
        viewContainer.innerHTML = ''; 

        const daysInQuarter = [];
        let d = new Date(startDate);
        d.setUTCHours(0,0,0,0);
        
        let normalizedEndDate = new Date(endDate);
        normalizedEndDate.setUTCHours(0,0,0,0);
        
        while(d.getTime() < normalizedEndDate.getTime()) {
            daysInQuarter.push(new Date(d));
            d.setUTCDate(d.getUTCDate() + 1);
        }

        const headerContainer = document.createElement('div');
        headerContainer.id = 'quarter-grid-header-container';
        const headerTable = document.createElement('table');
        headerTable.className = 'quarter-header-table';
        const headerThead = document.createElement('thead');
        const headerTr = document.createElement('tr');
        daysInQuarter.forEach(day => {
            const th = document.createElement('th');
            th.className = 'quarter-day-header';
            if(isSameUTCDay(day, today)) th.classList.add('today');
            th.innerHTML = `<div class="quarter-day-name">${DAY_NAMES_SHORT[day.getUTCDay()]}</div><div class="day-number">${day.getUTCDate()}</div>`;
            headerTr.appendChild(th);
        });
        headerThead.appendChild(headerTr);
        headerTable.appendChild(headerThead);
        headerContainer.appendChild(headerTable);
        
        const contentTable = document.createElement('table');
        contentTable.className = 'calendar-table';
        const contentTbody = document.createElement('tbody');
        const contentTr = document.createElement('tr');

        for (const day of daysInQuarter) {
            const td = document.createElement('td');
            td.className = 'quarter-day-cell';
            const primaryEventOnDay = allMoonEvents.find(evt => isSameUTCDay(evt.date, day) && PRIMARY_PHASE_NAMES.includes(evt.name));
            let emoji, title;

            if (primaryEventOnDay) {
                emoji = primaryEventOnDay.emoji;
                title = `${primaryEventOnDay.name} at ${primaryEventOnDay.date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' })}`;
            } else {
                const [startCycle, endCycle] = getCycleBoundaries(day);
                if (startCycle && endCycle) {
                    const cycleDuration = endCycle.date.getTime() - startCycle.date.getTime();
                    const age = day.getTime() - startCycle.date.getTime();
                    const phaseIndex = Math.floor((age / cycleDuration) * 8) % 8;
                    emoji = PHASE_EMOJIS[phaseIndex];
                    title = FULL_PHASE_NAMES[phaseIndex];
                } else {
                    emoji = '';
                }
            }

            if (emoji) {
                td.innerHTML = `<div class="moon-event-icon" title="${title}">${emoji}</div>`;
            }

            const weatherData = await fetchWeatherDataForDay(day);
            if (weatherData) {
                const weatherEmoji = getWeatherEmoji(weatherData.main);
                const minTemp = Math.round(weatherData.min);
                const maxTemp = Math.round(weatherData.max);
                const weatherCellEl = document.createElement('div');
                weatherCellEl.className = 'weather-info';
                weatherCellEl.innerHTML = `
                    <span class="weather-emoji" title="${weatherData.main}">${weatherEmoji}</span>
                    <span class="weather-temp" title="Min/Max temperature">${minTemp}¬∞ / ${maxTemp}¬∞</span>
                `;
                td.appendChild(weatherCellEl);
            }

            contentTr.appendChild(td);
        }
        contentTbody.appendChild(contentTr);
        contentTable.appendChild(contentTbody);
        
        viewContainer.appendChild(headerContainer);
        viewContainer.appendChild(contentTable);
    }

    async function renderCycleView() {
        const today = new Date();
        const [startEvent, endEvent] = getCycleBoundaries(viewDate);

        if (!startEvent || !endEvent) {
            views['cycle-view'].innerHTML = "Cycle Data Unavailable"; 
            viewTitleDisplay.innerHTML = "Cycle Data Unavailable";
            return;
        }

        const startDate = startEvent.date;
        const endDate = endEvent.date;

        const startMonth = getMonthName(startDate);
        const endMonth = getMonthName(endDate);
        const titleYear = startDate.getUTCFullYear();
        const titleText = startMonth === endMonth ? `${startMonth} ${titleYear} Cycle` : `${startMonth} - ${endMonth} ${titleYear} Cycle`;
        viewTitleDisplay.innerHTML = `<span>${titleText}</span>`;
        
        const viewContainer = views['cycle-view'];
        viewContainer.innerHTML = '';
        const table = document.createElement('table');
        table.className = 'calendar-table';
        
        const thead = table.createTHead();
        const headerTr = thead.insertRow();
        DAY_NAMES_SHORT.forEach(name => { headerTr.innerHTML += `<th>${name}</th>`; });
        
        const tbody = table.createTBody();
        let currentTr = tbody.insertRow();

        for (let i = 0; i < startDate.getUTCDay(); i++) {
            const cell = currentTr.insertCell();
            cell.className = 'cycle-day-cell other-month';
        }
        
        let d = new Date(startDate.getTime());
        d.setUTCHours(0,0,0,0); 

        let normalizedEndDate = new Date(endDate.getTime());
        normalizedEndDate.setUTCHours(0,0,0,0);

        while (d.getTime() < normalizedEndDate.getTime()) {
            if (d.getUTCDay() === 0 && currentTr.cells.length > 0) {
                currentTr = tbody.insertRow();
            }

            const td = currentTr.insertCell();
            td.className = 'cycle-day-cell';

            let dayNumberHTML = `<div class="day-number">${d.getUTCDate()}</div>`;
            if (isSameUTCDay(d, today)) {
                dayNumberHTML = `<div class="day-number today">${d.getUTCDate()}</div>`;
            }

            const primaryEventOnDay = allMoonEvents.find(evt => isSameUTCDay(evt.date, d) && PRIMARY_PHASE_NAMES.includes(evt.name));
            let emoji, title;

            if (primaryEventOnDay) {
                emoji = primaryEventOnDay.emoji;
                title = `${primaryEventOnDay.name} at ${primaryEventOnDay.date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' })}`;
            } else {
                const cycleDuration = endEvent.date.getTime() - startEvent.date.getTime();
                const age = d.getTime() - startEvent.date.getTime();
                const currentAge = Math.max(0, age);
                const phaseIndex = Math.floor((currentAge / cycleDuration) * 8) % 8;
                emoji = PHASE_EMOJIS[phaseIndex];
                title = FULL_PHASE_NAMES[phaseIndex];
            }
            
            let moonIconHTML = '';
            if (emoji) {
                moonIconHTML = `<div class="moon-event-icon" title="${title}">${emoji}</div>`;
            }
            
            td.innerHTML = dayNumberHTML + moonIconHTML;

            // Add weather for cycle view as well
            const weatherData = await fetchWeatherDataForDay(d);
            if (weatherData) {
                const weatherEmoji = getWeatherEmoji(weatherData.main);
                const minTemp = Math.round(weatherData.min);
                const maxTemp = Math.round(weatherData.max);
                const weatherCellEl = document.createElement('div');
                weatherCellEl.className = 'weather-info';
                weatherCellEl.innerHTML = `
                    <span class="weather-emoji" title="${weatherData.main}">${weatherEmoji}</span>
                    <span class="weather-temp" title="Min/Max temperature">${minTemp}¬∞ / ${maxTemp}¬∞</span>
                `;
                td.appendChild(weatherCellEl);
            }

            d.setUTCDate(d.getUTCDate() + 1);
        }
        
        while (currentTr.cells.length > 0 && currentTr.cells.length < 7) {
            const cell = currentTr.insertCell();
            cell.className = 'cycle-day-cell other-month';
        }

        viewContainer.appendChild(table);
    }

    async function switchView(viewId) {
        currentView = viewId;
        document.querySelectorAll('#main-nav-buttons .xp-button').forEach(button => {
            button.classList.toggle('active', button.dataset.view === viewId);
        });
        for (const key in views) {
            views[key].classList.toggle('active', key === viewId);
        }
        await updateAllViews();
    }

    async function updateAllViews() {
        await loadRequiredMoonData(viewDate);
        updateControls();
        const renderFunction = {
            'day-view': renderDayView,
            'quarter-view': renderQuarterView,
            'cycle-view': renderCycleView
        }[currentView];

        if(renderFunction) await renderFunction();
    }

    mainNavButtons.addEventListener('click', (event) => {
        if (event.target.matches('.xp-button')) {
            const viewId = event.target.dataset.view;
            if(viewId) switchView(viewId);
        }
    });
    
    async function init() {
        // Set the default view visually first
        views[currentView].classList.add('active');
        document.querySelector(`#main-nav-buttons .xp-button[data-view="${currentView}"]`).classList.add('active');
        
        // Start the data loading chain by requesting the API key.
        // The rest of the initialization (getting location, updating views)
        // will proceed via callbacks and event listeners.
        requestApiKey();

        checkControlsBarLayout();
        window.addEventListener('resize', checkControlsBarLayout);
    }

    init();
});
</script>