<template id="geminiChatIconTemplate">
    <div id="geminiChatIcon" class="desktop-icon" data-window-id="geminiChatWindow" style="left: 10px; top: 310px;">
        <div class="icon-image">âœ¨</div>
        <div class="icon-label">Gemini Chat</div>
    </div>
</template>

<template id="geminiChatWindowTemplate">
    <div class="xp-window" id="geminiChatWindow" style="display: none;">
        <div class="title-bar" id="geminiChatWindowTitleBar">
            <span class="title-bar-text">Gemini Chat</span>
            <div class="title-bar-controls">
                <button id="geminiChatMinimizeBtn" title="Minimize">0</button>
                <button id="geminiChatMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="geminiChatCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="geminiChatWindowBody">
            </div>
        <div class="resize-handle" id="geminiChatResizeHandle"></div>
    </div>
</template>

<template id="geminiChatBodyContentTemplate">
    <div class="gemini-chat-body-container">
        <div class="gemini-chat-controls-bar">
            <button id="geminiChatClearHistoryBtn" class="xp-button xp-button-small">Clear History</button>
        </div>
        <div class="gemini-chat-display-area" id="geminiChatDisplayArea">
            </div>
        <div class="gemini-chat-input-area">
            <textarea id="geminiChatPromptInput" placeholder="Type your message to Gemini..." rows="2"></textarea>
            <button id="geminiChatSendBtn" class="xp-button">Send</button>
        </div>
    </div>
</template>

<template id="geminiChatModalsTemplate">
    <div id="confirmClearChatModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Clear History</span>
                <span class="close-button" data-modal-id="confirmClearChatModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to clear the entire chat history? This action cannot be undone.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmClearChatBtn" class="xp-button">Clear History</button>
                <button class="xp-button" data-modal-id="confirmClearChatModal">Cancel</button>
            </div>
        </div>
    </div>
</template>

<style>
    /* Gemini Chat Specific Styles */
    #geminiChatWindow .window-body {
        padding: 0; /* Window body itself has no padding */
        display: flex; /* To make body-container fill it */
    }
    .gemini-chat-body-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        background-color: #ECE9D8; /* Standard XP background */
        padding: 0; /* Container itself has no padding, sub-elements will */
        box-sizing: border-box;
    }
    .gemini-chat-controls-bar {
        display: flex;
        justify-content: flex-end;
        padding: 3px 5px 0px 5px; /* Minimal padding */
        background-color: #ECE9D8;
        flex-shrink: 0;
        border-bottom: 1px solid #ACA899; /* Separator */
    }
    #geminiChatClearHistoryBtn {
        min-width: auto;
        padding: 2px 8px;
        margin-bottom: 3px; /* Space from border */
    }
    .gemini-chat-display-area {
        flex-grow: 1;
        border: 1px inset #7F7F7F; /* XP style inset border */
        background-color: #FFFFFF; /* White background for chat */
        padding: 8px;
        margin: 5px; /* Margin around the display area */
        margin-top: 2px; /* Reduced top margin */
        overflow-y: auto;
        font-family: "Tahoma", "Geneva", sans-serif;
        font-size: 11px;
        line-height: 1.4;
    }
    .gemini-chat-message {
        margin-bottom: 8px;
        padding: 6px 10px; /* Slightly more padding */
        border-radius: 5px; /* Rounded corners for messages */
        word-wrap: break-word;
        white-space: pre-wrap; /* Preserve whitespace and newlines */
        max-width: 90%; /* Messages don't take full width */
        box-sizing: border-box;
        border: 1px solid transparent; /* Base border */
    }
    .gemini-chat-message .message-sender {
        font-weight: bold;
        display: block;
        margin-bottom: 3px;
        font-size: 10px;
    }
    .gemini-chat-message .message-content {
      /* Styles for content if needed */
    }
     .gemini-chat-message .message-timestamp {
        font-size: 9px;
        color: #555;
        display: block;
        margin-top: 4px;
        text-align: inherit; /* Inherit from parent message alignment */
    }
    .gemini-chat-message.user-message {
        background-color: #E1EEF7; /* Lighter blue for user */
        text-align: left; /* Or right for classic chat */
        margin-left: auto; /* Align to right */
        margin-right: 0;
        border-color: #C0D9EC;
    }
    .gemini-chat-message.user-message .message-sender {
        color: #0039A9; /* XP Dark Blue */
    }
    .gemini-chat-message.gemini-message {
        background-color: #F0F0F0; /* Light grey for Gemini */
        text-align: left;
        margin-right: auto; /* Align to left */
        margin-left: 0;
        border-color: #DCDCDC;
    }
    .gemini-chat-message.gemini-message .message-sender {
        color: #006400; /* Dark Green */
    }
    .gemini-chat-message.gemini-message.error-message {
        background-color: #FFDDDD; /* Light red for errors */
        color: #D8000C; /* Dark red text */
        border-color: #FFB8B8;
    }
    .gemini-chat-message.gemini-message.error-message .message-sender {
        color: #990000; /* Darker red for sender in error */
    }
    @keyframes thinking { /* Simple thinking animation */
        0% { content: 'Thinking.'; }
        25% { content: 'Thinking..'; }
        50% { content: 'Thinking...'; }
        75% { content: 'Thinking..'; }
        100% { content: 'Thinking.'; }
    }
    .gemini-thinking-animation::after { /* Used for the placeholder message */
        content: 'Thinking...'; 
        animation: thinking 1.5s infinite;
        display: inline-block; 
    }
    .gemini-chat-input-area {
        display: flex;
        flex-shrink: 0;
        padding: 8px 5px 5px 5px;
        border-top: 1px solid #ACA899;
        background-color: #ECE9D8;
    }
    #geminiChatPromptInput {
        flex-grow: 1;
        margin-right: 5px;
        border: 1px inset #7F7F7F;
        padding: 6px;
        font-family: "Tahoma", "Geneva", sans-serif;
        font-size: 11px;
        background-color: #FFFFFF;
        resize: none; /* Prevent manual resize */
        height: 44px; /* Default height for approx 2 lines */
        box-sizing: border-box;
    }
    #geminiChatSendBtn {
        min-width: 60px;
        padding: 3px 8px;
        font-size: 11px;
        height: 44px; /* Match textarea height */
        box-sizing: border-box;
    }
    .xp-button-small { /* Ensure this is available if used by chat */
        padding: 2px 5px;
        font-size: 10px;
        min-width: auto;
        margin: 0 2px;
    }
</style>

<script>
(function() {
    const APP_ID = 'geminiChatWindow';
    const MIN_WIDTH = 375;
    const MIN_HEIGHT = 250;
    const DEFAULT_WIDTH = 450;
    const DEFAULT_HEIGHT = 705;
    const MAX_GEMINI_HISTORY_MESSAGES = 20; // Max messages to keep in history and send to API

    let geminiChatDOM = {};
    
    const getById = window.getById;
    const GEMINI_API_KEY = window.GEMINI_API_KEY; // Access global API key

    function populateGeminiChatDOM() {
        geminiChatDOM = {
            geminiChatWindow: getById('geminiChatWindow'),
            geminiChatWindowBody: getById('geminiChatWindowBody'),
            geminiChatClearHistoryBtn: getById('geminiChatClearHistoryBtn'),
            geminiChatDisplayArea: getById('geminiChatDisplayArea'),
            geminiChatPromptInput: getById('geminiChatPromptInput'),
            geminiChatSendBtn: getById('geminiChatSendBtn'),
            confirmClearChatModal: getById('confirmClearChatModal'),
            confirmClearChatBtn: getById('confirmClearChatBtn'),
        };
    }

    function getGeminiChatData() {
        if (!window.appData.geminiChat) {
            window.appData.geminiChat = {
                history: [], // Stores {id?, type: 'user'|'gemini', content: string, isError?: boolean, timestamp: string}
            };
        }
        return window.appData.geminiChat;
    }

    function initGeminiChatApp() {
        getGeminiChatData(); // Initialize data structure
        populateGeminiChatDOM();

        addGeminiChatEventListeners();
        renderGeminiChatHistory();

        const appWindow = getById(APP_ID);
        if (appWindow) {
            appWindow.addEventListener('appresize', handleGeminiChatWindowResize);
            appWindow.addEventListener('appopen', (event) => {
                if (event.detail && event.detail.windowId === APP_ID) {
                    renderGeminiChatHistory(); // Refresh view on open
                    geminiChatDOM.geminiChatPromptInput.focus();
                }
            });
        }
    }
    
    function handleGeminiChatWindowResize() {
        // Chat display area and input area should resize naturally with flexbox.
        // No specific JS needed for resizing internal elements here.
    }

    function addGeminiChatEventListeners() {
        geminiChatDOM.geminiChatSendBtn.addEventListener('click', handleSendGeminiPrompt);
        geminiChatDOM.geminiChatPromptInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleSendGeminiPrompt();
            }
        });
        geminiChatDOM.geminiChatClearHistoryBtn.addEventListener('click', handleClearGeminiChatHistory);
        geminiChatDOM.confirmClearChatBtn.addEventListener('click', confirmClearChat);
        
        const appWindow = getById(APP_ID);
        if (appWindow) {
            const closeButton = appWindow.querySelector('#geminiChatCloseBtn');
            if (closeButton) closeButton.addEventListener('click', () => {
                let state = window.appData.windowStates[APP_ID];
                if (state) state.hiddenByUser = true;
                window.saveWindowState(APP_ID);
                appWindow.style.display = 'none';
            });
            const minimizeButton = appWindow.querySelector('#geminiChatMinimizeBtn');
            if(minimizeButton) minimizeButton.addEventListener('click', () => window.minimizeWindow(APP_ID));

            const maximizeButton = appWindow.querySelector('#geminiChatMaximizeBtn');
            if(maximizeButton) maximizeButton.addEventListener('click', () => window.maximizeWindow(APP_ID));
        }
    }

    function renderGeminiChatHistory() {
        const chatData = getGeminiChatData();
        if (!geminiChatDOM.geminiChatDisplayArea) return;

        geminiChatDOM.geminiChatDisplayArea.innerHTML = '';
        const historyToRender = chatData.history || [];

        historyToRender.forEach(msg => {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('gemini-chat-message');

            const senderSpan = document.createElement('span');
            senderSpan.classList.add('message-sender');

            const contentSpan = document.createElement('span');
            contentSpan.classList.add('message-content');

            if (msg.id && msg.id.startsWith('gemini-thinking-')) { 
                contentSpan.classList.add('gemini-thinking-animation'); 
                contentSpan.textContent = ''; // Animation is done via CSS pseudo-element
            } else {
                contentSpan.textContent = msg.content;
            }

            const timestampSpan = document.createElement('span');
            timestampSpan.classList.add('message-timestamp');
            timestampSpan.textContent = msg.timestamp ? new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '';

            if (msg.type === 'user') {
                messageDiv.classList.add('user-message');
                senderSpan.textContent = 'You';
            } else if (msg.type === 'gemini') {
                messageDiv.classList.add('gemini-message');
                senderSpan.textContent = 'Gemini';
                if (msg.isError) {
                    messageDiv.classList.add('error-message');
                }
            }
            
            if (msg.id) { // Assign ID to the div if present (for updating thinking message)
                messageDiv.id = msg.id;
            }

            messageDiv.appendChild(senderSpan);
            messageDiv.appendChild(contentSpan);
            messageDiv.appendChild(timestampSpan);
            geminiChatDOM.geminiChatDisplayArea.appendChild(messageDiv);
        });
        geminiChatDOM.geminiChatDisplayArea.scrollTop = geminiChatDOM.geminiChatDisplayArea.scrollHeight;
    }

    function addMessageToGeminiChat(type, content, isError = false, messageId = null) {
        const chatData = getGeminiChatData();
        if (!chatData.history) chatData.history = [];

        const newMessage = {
            type: type,
            content: content,
            isError: isError,
            timestamp: new Date().toISOString()
        };
        if (messageId) { // Used for the "thinking" message to update it later
            newMessage.id = messageId;
        }

        chatData.history.push(newMessage);
        // Optional: Trim history if it gets too long (for performance or API limits)
        // if (chatData.history.length > MAX_GEMINI_HISTORY_MESSAGES_LOCAL_STORAGE) {
        //    chatData.history.splice(0, chatData.history.length - MAX_GEMINI_HISTORY_MESSAGES_LOCAL_STORAGE);
        // }
        renderGeminiChatHistory();
        window.saveData();
    }
    
    function updateGeminiChatMessage(messageId, newContent, isError = false) {
        const chatData = getGeminiChatData();
        if (!chatData.history) return;

        const messageIndex = chatData.history.findIndex(msg => msg.id === messageId);
        if (messageIndex !== -1) {
            chatData.history[messageIndex].content = newContent;
            chatData.history[messageIndex].isError = isError;
            // If it was a 'thinking' message, remove the temporary ID property
            // so it doesn't get treated as special on subsequent renders.
            if (messageId.startsWith('gemini-thinking-')) {
                 delete chatData.history[messageIndex].id; 
            }
            renderGeminiChatHistory();
            window.saveData();
        }
    }

    function handleClearGeminiChatHistory() {
        window.openModal('confirmClearChatModal');
    }

    function confirmClearChat() {
        const chatData = getGeminiChatData();
        chatData.history = [];
        renderGeminiChatHistory();
        window.saveData();
        window.closeModal('confirmClearChatModal');
    }

    async function handleSendGeminiPrompt() {
        const promptText = geminiChatDOM.geminiChatPromptInput.value.trim();
        if (!promptText) return;

        addMessageToGeminiChat('user', promptText);
        geminiChatDOM.geminiChatPromptInput.value = '';
        geminiChatDOM.geminiChatPromptInput.disabled = true;
        geminiChatDOM.geminiChatSendBtn.disabled = true;

        if (!window.GEMINI_API_KEY) { // Use global key
            addMessageToGeminiChat('gemini', "Error: Gemini API Key is not configured.", true);
            geminiChatDOM.geminiChatPromptInput.disabled = false;
            geminiChatDOM.geminiChatSendBtn.disabled = false;
            geminiChatDOM.geminiChatPromptInput.focus();
            return;
        }
        
        const thinkingMsgId = `gemini-thinking-${Date.now()}`;
        addMessageToGeminiChat('gemini', '', false, thinkingMsgId); // Add placeholder

        const chatData = getGeminiChatData();
        const messagesToSend = [];
        // Prepare history for API: take last N messages, ensure no errors or placeholders
        const recentHistory = chatData.history.slice(-MAX_GEMINI_HISTORY_MESSAGES -1); // Get a bit more to filter out thinking msg
        
        recentHistory.forEach(msg => {
            if (!msg.isError && msg.id !== thinkingMsgId && msg.content.trim() !== '') { // Exclude thinking message itself and empty content
                messagesToSend.push({
                    role: msg.type === 'user' ? 'user' : 'model',
                    parts: [{ text: msg.content }]
                });
            }
        });
        // Ensure the last message is the current user prompt if it wasn't captured above
        if (messagesToSend.length === 0 || messagesToSend[messagesToSend.length -1].parts[0].text !== promptText) {
             if (messagesToSend.length > 0 && messagesToSend[messagesToSend.length -1].role === 'user') {
                messagesToSend.pop(); // Remove previous user message if it's immediately followed by another user message
             }
             messagesToSend.push({
                role: 'user',
                parts: [{ text: promptText }]
            });
        }


        try {
            const requestBody = {
                contents: messagesToSend 
            };
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${window.GEMINI_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
                const errorData = await response.json();
                const errorMessage = errorData?.error?.message || `API request failed with status ${response.status}`;
                updateGeminiChatMessage(thinkingMsgId, `Error: ${errorMessage}`, true);
            } else {
                const data = await response.json();
                if (data.candidates && data.candidates.length > 0 &&
                    data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
                    const geminiResponse = data.candidates[0].content.parts[0].text;
                    updateGeminiChatMessage(thinkingMsgId, geminiResponse, false);
                } else if (data.promptFeedback && data.promptFeedback.blockReason) {
                     updateGeminiChatMessage(thinkingMsgId, `Blocked: ${data.promptFeedback.blockReason}. ${data.promptFeedback.blockReasonMessage || ''}`, true);
                } else {
                    updateGeminiChatMessage(thinkingMsgId, "Received an empty or unexpected response from Gemini.", true);
                }
            }
        } catch (error) {
            updateGeminiChatMessage(thinkingMsgId, `Error: Could not connect to Gemini. ${error.message}`, true);
        } finally {
            geminiChatDOM.geminiChatPromptInput.disabled = false;
            geminiChatDOM.geminiChatSendBtn.disabled = false;
            geminiChatDOM.geminiChatPromptInput.focus();
        }
    }

    function setupGeminiChatApp() {
        const windowBody = getById('geminiChatWindowBody');
        const bodyContentTemplate = document.getElementById('geminiChatBodyContentTemplate');

        if (windowBody && bodyContentTemplate) {
            windowBody.innerHTML = '';
            windowBody.appendChild(bodyContentTemplate.content.cloneNode(true));
        } else {
            console.error("Gemini Chat window body or content template not found.");
            return;
        }
        
        if (!window.appRegistry) window.appRegistry = {};
        window.appRegistry[APP_ID] = {
            minWidth: MIN_WIDTH,
            minHeight: MIN_HEIGHT,
            defaultWidth: DEFAULT_WIDTH,
            defaultHeight: DEFAULT_HEIGHT,
            appName: "Gemini Chat"
        };
        
        initGeminiChatApp();
    }

    window.setupGeminiChatApp = setupGeminiChatApp;

})();
</script>
