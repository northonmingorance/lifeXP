<template id="playJockeyIconTemplate">
    <div id="playJockeyIcon" class="desktop-icon" data-window-id="playJockeyWindow" style="left: 10px; top: 210px;">
        <div class="icon-image-pJ">⏯️</div>
        <div class="icon-image-pJ2">⏯️</div>
        <div class="icon-label-pJ">Play Jockey</div>
    </div>
</template>

<template id="playJockeyWindowTemplate">
    <div class="xp-window" id="playJockeyWindow" style="display: none;">
        <div class="title-bar" id="playJockeyTitleBar">
            <span class="title-bar-text">Play Jockey</span>
            <div class="title-bar-controls">
                <button id="playJockeyMinimizeBtn" title="Minimize">0</button>
                <button id="playJockeyMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="playJockeyCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="playJockeyWindowBody">
            </div>
        <div class="resize-handle" id="playJockeyResizeHandle"></div>
    </div>
</template>

<template id="playJockeyBodyContentTemplate">
    <div class="playjockey-body-container">
        <div class="playjockey-input-bar">
            <input type="text" id="playJockeyLinkInput" placeholder="Paste YouTube Link or Search Query">
            <button id="playJockeyAddBtn" class="xp-button">Add</button>
        </div>
        <div class="playjockey-player-area">
            <div id="playJockeyPlayer"></div>
        </div>
        <div class="playjockey-tabs-bar" id="playJockeyTabsBar">
            </div>
        <div class="playjockey-playlist-area" id="playJockeyPlaylist">
            </div>
        <div class="playjockey-controls-bar">
            <button id="playJockeyRandomBtn" class="xp-button">Random: Off</button>
            <button id="playJockeyAutoPlayBtn" class="xp-button">Auto Play: On</button>
            <button id="playJockeyRepeatBtn" class="xp-button">Repeat: Off</button>
        </div>
    </div>
</template>

<template id="playJockeyModalsTemplate">
    <div id="playJockeyContextMenu" class="context-modal">
        <div class="context-modal-item" id="pjContextRename">Rename Track</div>
        <div class="context-modal-item" id="pjContextRemove">Remove Track</div>
    </div>
    <div id="playJockeyTabContextMenu" class="context-modal">
        <div class="context-modal-item" id="pjTabContextRename">Rename Playlist</div>
        <div class="context-modal-item" id="pjTabContextRemove">Remove Playlist</div>
    </div>
    <div id="renamePlaylistModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Rename Playlist</span>
                <span class="close-button" data-modal-id="renamePlaylistModal">r</span>
            </div>
            <div class="modal-body">
                <label for="playlistNewNameInput">New playlist name:</label>
                <input type="text" id="playlistNewNameInput" placeholder="Enter playlist name">
            </div>
            <div class="modal-footer">
                <button id="saveRenamedPlaylistBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="renamePlaylistModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmRemovePlaylistModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Playlist Deletion</span>
                <span class="close-button" data-modal-id="confirmRemovePlaylistModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemovePlaylistMessage">Are you sure you want to remove this playlist?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmFinalPlaylistRemoveBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmRemovePlaylistModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="youtubeSearchModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-title-bar">
                <span>Youtube Results</span>
                <span class="close-button" data-modal-id="youtubeSearchModal">r</span>
            </div>
            <div class="modal-body" id="youtubeSearchResultsBody">
                <p id="youtubeSearchStatus" style="text-align: center; display: none;"></p>
            </div>
            <div class="modal-footer">
                <button class="xp-button" data-modal-id="youtubeSearchModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="renameTrackModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Rename Track</span>
                <span class="close-button" data-modal-id="renameTrackModal">r</span>
            </div>
            <div class="modal-body">
                <label for="trackNewNameInput">New track name:</label>
                <input type="text" id="trackNewNameInput" placeholder="Enter track name">
                <label for="trackNewArtistInput" style="margin-top:10px;">New artist name (optional):</label>
                <input type="text" id="trackNewArtistInput" placeholder="Enter artist name">
            </div>
            <div class="modal-footer">
                <button id="saveRenamedTrackBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="renameTrackModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmRemoveTrackModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-title-bar">
                <span>Confirm Track Deletion</span>
                <span class="close-button" data-modal-id="confirmRemoveTrackModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemoveTrackMessage">Are you sure you want to remove this track from the playlist?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmFinalTrackRemoveBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmRemoveTrackModal">Cancel</button>
            </div>
        </div>
    </div>
</template>

<style>
    /* Play Jockey Specific Styles */
    #playJockeyWindow .window-body {
        padding: 0; /* Window body itself has no padding */
        display: flex; /* To make body-container fill it */
    }
    .icon-image-pJ { /* Specific for Play Jockey icon parts */
        font-size: 48px;
        line-height: 1;
        margin-bottom: 8px;
        filter: hue-rotate(140deg) saturate(1000%) brightness(70%);
    }
    .icon-image-pJ2 {
        font-size: 48px;
        line-height: 1;
        text-shadow: none;
        margin-bottom: 8px;
        position: relative;
        top: -66px; /* Adjust based on your icon label height */
        filter: hue-rotate(140deg) saturate(1000%);
        mix-blend-mode: luminosity;
         /* No width/height here, desktop-icon class handles it */
        text-align: center;
        color: white;
        cursor: grab;
        user-select: none;
        -webkit-user-select: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        box-sizing: border-box;
    }
    .icon-label-pJ {
        font-size: 12px;
        font-weight: normal;
        word-wrap: break-word;
        max-width: 100%;
        position: relative;
        top: -66px; /* Adjust to align with the bottom of the icon visual */
    }
    .playjockey-body-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
        background-color: #D4D0C8;
        padding: 5px;
        box-sizing: border-box;
    }
    .playjockey-input-bar {
        display: flex;
        margin-bottom: 5px;
        padding: 5px;
        background-color: #C0C0C0;
        border: 1px outset #FFFFFF;
        border-right-color: #808080;
        border-bottom-color: #808080;
        flex-shrink: 0;
    }
    #playJockeyLinkInput {
        flex-grow: 1;
        margin-right: 5px;
        border: 1px inset #7F7F7F;
        padding: 4px;
        font-family: "Tahoma", "Geneva", sans-serif;
        font-size: 11px;
        background-color: #FFFFFF;
    }
    #playJockeyAddBtn {
        min-width: 60px;
        padding: 3px 8px;
        font-size: 11px;
    }
    .playjockey-player-area {
        flex-grow: 1;
        margin-bottom: 5px;
        border: 2px inset #808080;
        background-color: black;
        min-height: 150px; /* Ensure player area has some height */
        overflow: hidden; /* Important for iframe */
        position: relative; /* For potential overlays or messages */
    }
    #playJockeyPlayer { /* The div that will contain the YouTube iframe */
        width: 100%;
        height: 100%;
    }
    .playjockey-tabs-bar {
        display: flex;
        flex-wrap: nowrap;
        overflow-x: auto; /* Allow horizontal scrolling for many tabs */
        background-color: #C0C0C0;
        padding: 3px 3px 0 3px;
        border-bottom: 1px solid #808080;
        flex-shrink: 0;
        gap: 2px;
    }
    .playjockey-tab {
        padding: 6px 10px;
        border: 1px outset #FFFFFF; /* Simpler outset */
        border-bottom: none;
        background-color: #D4D0C8;
        cursor: default;
        font-size: 10px;
        white-space: nowrap;
        border-top-left-radius: 3px;
        border-top-right-radius: 3px;
    }
    .playjockey-tab:hover {
        background-color: #E0E0E0;
    }
    .playjockey-tab.active {
        background-color: #F0F0F0; /* Lighter for active tab */
        border-style: inset;
        border-bottom: 1px solid #F0F0F0; /* Make bottom border match background */
        position: relative;
        z-index: 1; /* To make bottom border overlap container's border */
        font-weight: bold;
    }
    .playjockey-add-tab-btn {
        padding: 6px 8px;
        margin-left: 0px; /* No extra margin needed with gap */
        font-weight: bold;
    }
    .playjockey-controls-bar {
        display: flex;
        justify-content: center;
        padding: 5px 0px 5px 0px;
        flex-shrink: 0;
        gap: 5px;
        border-top: 1px solid #ACA899;
        background-color: #F0F0F0;
    }
    #playJockeyRandomBtn,
    #playJockeyAutoPlayBtn,
    #playJockeyRepeatBtn {
        min-width: 90px;
        padding: 3px 8px;
        font-size: 11px;
    }
    #playJockeyRandomBtn.random-on,
    #playJockeyAutoPlayBtn.autoplay-on,
    #playJockeyRepeatBtn.repeat-on {
        border-style: inset;
        font-weight: bold;
    }
    .playjockey-playlist-area {
        height: 100px; /* Or make it flex-grow if player area has fixed height */
        overflow-y: auto;
        border: 1px inset #7F7F7F;
        background-color: #FFFFFF;
        padding: 3px;
        flex-shrink: 0;
        border-top: none; /* Tabs bar provides top border */
        position: relative; /* For z-index with tabs */
        z-index: 0;
    }
    .playjockey-playlist-item {
        padding: 4px 6px;
        cursor: grab;
        border-bottom: 1px solid #ECE9D8;
        font-size: 10px;
        color: #000080; /* Dark blue for links */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        user-select: none; /* Prevent text selection during drag */
    }
    .playjockey-playlist-item:hover {
        background-color: #000080;
        color: white;
    }
    .playjockey-playlist-item.playing {
        background-color: #005CFE; /* XP Blue for playing */
        color: white;
        font-weight: bold;
    }
    .playjockey-playlist-item:last-child {
        border-bottom: none;
    }
    .playjockey-playlist-item.dragging { /* Style for the item being dragged */
        opacity: 0.5;
        background-color: #AED6F1; /* Light blue */
    }
    .playjockey-playlist-item.drag-over-target-before {
        border-top: 2px dashed #005CFE;
    }
    .playjockey-playlist-item.drag-over-target-after {
        border-bottom: 2px dashed #005CFE;
    }

    /* Context Menu Styles (re-use from OS or define here if specific) */
    .context-modal {
        display: none;
        position: fixed; /* Use fixed to position relative to viewport */
        background-color: #ECE9D8;
        border: 1px solid #000;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
        z-index: 2000; /* High z-index */
        padding: 3px 0;
        min-width: 120px;
        font-family: "Tahoma", "Geneva", sans-serif;
        font-size: 11px;
    }
    .context-modal-item {
        padding: 5px 12px;
        cursor: default;
        color: black;
    }
    .context-modal-item:hover {
        background-color: #005CFE; /* XP Blue */
        color: white;
    }
    /* YouTube Search Results Modal Styles */
    #youtubeSearchResultsBody {
        max-height: 400px; /* Or adjust as needed */
        overflow-y: auto;
    }
    .Youtube-result-item {
        display: flex;
        align-items: center;
        padding: 8px;
        border-bottom: 1px solid #ACA899;
        cursor: pointer;
        background-color: #FFFFFF;
    }
    .Youtube-result-item:hover {
        background-color: #E0E0E0;
    }
    .Youtube-result-item:last-child {
        border-bottom: none;
    }
    .Youtube-result-item img {
        width: 120px; /* Standard YouTube thumbnail aspect ratio */
        height: 90px;
        margin-right: 10px;
        border: 1px solid #ACA899;
        object-fit: cover;
    }
    .Youtube-result-item-details {
        display: flex;
        flex-direction: column;
    }
    .Youtube-result-item-title {
        font-weight: bold;
        color: #0039A9; /* XP Dark Blue */
        font-size: 12px;
        margin-bottom: 3px;
    }
    .Youtube-result-item-channel {
        font-size: 10px;
        color: #555;
    }
    #youtubeSearchStatus { /* For loading/error messages in search modal */
        padding: 15px;
        font-size: 12px;
    }
</style>

<script>
(function() {
    const APP_ID = 'playJockeyWindow';
    const MIN_WIDTH = 375;
    const MIN_HEIGHT = 350; // Increased due to player + playlist + controls
    const DEFAULT_WIDTH = 480;
    const DEFAULT_HEIGHT = 705;

    let playJockeyDOM = {};
    let ytPlayerInstance = null;
    let isYouTubeApiReady = false;
    let pendingVideoToLoad = null;
    let pjDraggedItem = null; // For drag-and-drop

    // Use global helpers
    const getById = window.getById;
    const YOUTUBE_API_KEY = window.YOUTUBE_API_KEY; // Access global API key

    function decodeHtmlEntities(text) {
        if (typeof text !== 'string') return text;
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }

    function populatePlayJockeyDOM() {
        playJockeyDOM = {
            playJockeyWindow: getById('playJockeyWindow'),
            playJockeyWindowBody: getById('playJockeyWindowBody'),
            playJockeyLinkInput: getById('playJockeyLinkInput'),
            playJockeyAddBtn: getById('playJockeyAddBtn'),
            playJockeyPlayer: getById('playJockeyPlayer'),
            playJockeyTabsBar: getById('playJockeyTabsBar'),
            playJockeyPlaylist: getById('playJockeyPlaylist'),
            playJockeyRandomBtn: getById('playJockeyRandomBtn'),
            playJockeyAutoPlayBtn: getById('playJockeyAutoPlayBtn'),
            playJockeyRepeatBtn: getById('playJockeyRepeatBtn'),
            // Context Menus
            playJockeyContextMenu: getById('playJockeyContextMenu'),
            pjContextRenameBtn: getById('pjContextRename'),
            pjContextRemoveBtn: getById('pjContextRemove'),
            playJockeyTabContextMenu: getById('playJockeyTabContextMenu'),
            pjTabContextRenameBtn: getById('pjTabContextRename'),
            pjTabContextRemoveBtn: getById('pjTabContextRemove'),
            // Modals
            renamePlaylistModal: getById('renamePlaylistModal'),
            playlistNewNameInput: getById('playlistNewNameInput'),
            saveRenamedPlaylistBtn: getById('saveRenamedPlaylistBtn'),
            confirmRemovePlaylistModal: getById('confirmRemovePlaylistModal'),
            confirmRemovePlaylistMessage: getById('confirmRemovePlaylistMessage'),
            confirmFinalPlaylistRemoveBtn: getById('confirmFinalPlaylistRemoveBtn'),
            youtubeSearchModal: getById('youtubeSearchModal'),
            youtubeSearchResultsBody: getById('youtubeSearchResultsBody'),
            youtubeSearchStatus: getById('youtubeSearchStatus'),
            renameTrackModal: getById('renameTrackModal'),
            trackNewNameInput: getById('trackNewNameInput'),
            trackNewArtistInput: getById('trackNewArtistInput'),
            saveRenamedTrackBtn: getById('saveRenamedTrackBtn'),
            confirmRemoveTrackModal: getById('confirmRemoveTrackModal'),
            confirmRemoveTrackMessage: getById('confirmRemoveTrackMessage'),
            confirmFinalTrackRemoveBtn: getById('confirmFinalTrackRemoveBtn'),
        };
    }

    function getPlayJockeyData() {
        if (!window.appData.playJockey) {
            const defaultPlaylistId = 'playlist_default_' + Date.now();
            window.appData.playJockey = {
                playlists: [{id: defaultPlaylistId, name: "Playlist 1", videos: []}],
                currentPlaylistId: defaultPlaylistId,
                currentVideo: null, // Stores {id, videoId, title, artist} of current video
                autoPlayEnabled: true,
                randomEnabled: false,
                repeatState: "off", // "off", "playlist", "song"
                randomHistory: [], // To avoid immediate repeats in random mode
            };
        }
        return window.appData.playJockey;
    }
    
    function initPlayJockeyApp() {
        const pjData = getPlayJockeyData(); // Initialize data structure
        populatePlayJockeyDOM();

        // Load YouTube API if not already loaded by another app (idempotent)
        if (!document.getElementById('youtube-iframe-api')) {
            const tag = document.createElement('script');
            tag.id = 'youtube-iframe-api';
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }
        // The global onYouTubeIframeAPIReady function will be called by the API
        // We need to ensure our app-specific part is also triggered
        const originalOnYouTubeReady = window.onYouTubeIframeAPIReady;
        window.onYouTubeIframeAPIReady = function() {
            if (originalOnYouTubeReady) originalOnYouTubeReady(); // Call previous if exists
            isYouTubeApiReady = true;
            console.log("Play Jockey: YouTube API Ready.");
            checkPendingVideoLoad();
        };
        if (typeof YT !== 'undefined' && YT.Player) { // API might be ready synchronously
             isYouTubeApiReady = true;
             console.log("Play Jockey: YouTube API was already ready.");
        }


        addPlayJockeyEventListeners();
        renderPlayJockeyTabs();
        renderPlayJockeyPlaylist();
        updatePlayJockeyAutoPlayButtonState();
        updatePlayJockeyRandomButtonState();
        updatePlayJockeyRepeatButtonState();
        checkPendingVideoLoad(); // In case API was ready before listeners

        const appWindow = getById(APP_ID);
        if (appWindow) {
            appWindow.addEventListener('appresize', handlePlayJockeyWindowResize);
            appWindow.addEventListener('appopen', (event) => {
                if (event.detail && event.detail.windowId === APP_ID) {
                    console.log("Play Jockey opened/restored");
                    checkPendingVideoLoad(); // Attempt to load video if one was pending
                    if (pjData.currentVideo && !ytPlayerInstance && isYouTubeApiReady) {
                         playYouTubeVideoById(pjData.currentVideo.videoId, false); // Don't autoplay on restore unless it was playing
                    }
                }
            });
            appWindow.addEventListener('appminimize', () => {
                // Optionally pause video on minimize
                // if (ytPlayerInstance && typeof ytPlayerInstance.pauseVideo === 'function') {
                //     ytPlayerInstance.pauseVideo();
                // }
            });
        }
    }

    function checkPendingVideoLoad() {
        const pjData = getPlayJockeyData();
        if (pendingVideoToLoad && isYouTubeApiReady) {
            playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
            pendingVideoToLoad = null;
        } else if (pjData.currentVideo && !ytPlayerInstance && isYouTubeApiReady) {
            // If there's a current video in state but no player, try to load it (e.g., after page refresh)
            // Only if window is visible
            const win = getById(APP_ID);
            if (win && win.style.display !== 'none' && !win.classList.contains('minimized')) {
                playYouTubeVideoById(pjData.currentVideo.videoId, false); // Don't autoplay on initial load unless intended
            } else if (win && (win.style.display === 'none' || win.classList.contains('minimized'))) {
                pendingVideoToLoad = { videoId: pjData.currentVideo.videoId, autoplayIntent: false };
            }
        }
    }
    
    function handlePlayJockeyWindowResize() {
        // If player exists, tell it to resize (YouTube API handles this internally if size changes)
        // No specific logic needed here for simple iframe unless complex layouts are involved.
    }

    function addPlayJockeyEventListeners() {
        playJockeyDOM.playJockeyAddBtn.addEventListener('click', handlePlayJockeyInput);
        playJockeyDOM.playJockeyLinkInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handlePlayJockeyInput();
        });

        playJockeyDOM.playJockeyPlaylist.addEventListener('dragstart', handlePjDragStart);
        playJockeyDOM.playJockeyPlaylist.addEventListener('dragend', handlePjDragEnd);
        playJockeyDOM.playJockeyPlaylist.addEventListener('dragover', handlePjDragOver);
        playJockeyDOM.playJockeyPlaylist.addEventListener('dragleave', handlePjDragLeave);
        playJockeyDOM.playJockeyPlaylist.addEventListener('drop', handlePjDrop);
        playJockeyDOM.playJockeyPlaylist.addEventListener('contextmenu', showPjContextMenu);

        playJockeyDOM.playJockeyRandomBtn.addEventListener('click', togglePlayJockeyRandom);
        playJockeyDOM.playJockeyAutoPlayBtn.addEventListener('click', togglePlayJockeyAutoPlay);
        playJockeyDOM.playJockeyRepeatBtn.addEventListener('click', cyclePlayJockeyRepeat);

        // Context Menu Actions
        playJockeyDOM.pjContextRenameBtn.addEventListener('click', handlePjContextRename);
        playJockeyDOM.pjContextRemoveBtn.addEventListener('click', handlePjContextRemove);
        playJockeyDOM.pjTabContextRenameBtn.addEventListener('click', openRenamePlaylistModalFromContextMenu);
        playJockeyDOM.pjTabContextRemoveBtn.addEventListener('click', openConfirmRemovePlaylistModalFromContextMenu);
        
        // Modal Actions
        playJockeyDOM.saveRenamedPlaylistBtn.addEventListener('click', saveRenamedPlaylist);
        playJockeyDOM.playlistNewNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') saveRenamedPlaylist(); });
        playJockeyDOM.confirmFinalPlaylistRemoveBtn.addEventListener('click', executePlaylistDeletion);
        playJockeyDOM.saveRenamedTrackBtn.addEventListener('click', saveRenamedTrack);
        playJockeyDOM.trackNewNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') playJockeyDOM.saveRenamedTrackBtn.click();});
        playJockeyDOM.trackNewArtistInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') playJockeyDOM.saveRenamedTrackBtn.click();});
        playJockeyDOM.confirmFinalTrackRemoveBtn.addEventListener('click', executeTrackDeletion);

        // Close context menus on outside click
        document.addEventListener('click', (e) => {
            if (playJockeyDOM.playJockeyContextMenu.style.display === 'block' && !playJockeyDOM.playJockeyContextMenu.contains(e.target) && !e.target.closest('.playjockey-playlist-item')) {
                hidePjContextMenu();
            }
            if (playJockeyDOM.playJockeyTabContextMenu.style.display === 'block' && !playJockeyDOM.playJockeyTabContextMenu.contains(e.target) && !e.target.closest('.playjockey-tab')) {
                hidePjTabContextMenu();
            }
        });
        
        const appWindow = getById(APP_ID);
        if (appWindow) {
            const closeButton = appWindow.querySelector('#playJockeyCloseBtn');
            if (closeButton) closeButton.addEventListener('click', () => {
                if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
                    ytPlayerInstance.stopVideo();
                }
                let state = window.appData.windowStates[APP_ID];
                if (state) state.hiddenByUser = true;
                window.saveWindowState(APP_ID);
                appWindow.style.display = 'none';
            });
            const minimizeButton = appWindow.querySelector('#playJockeyMinimizeBtn');
            if(minimizeButton) minimizeButton.addEventListener('click', () => window.minimizeWindow(APP_ID));

            const maximizeButton = appWindow.querySelector('#playJockeyMaximizeBtn');
            if(maximizeButton) maximizeButton.addEventListener('click', () => window.maximizeWindow(APP_ID));
        }
    }

    function getCurrentPlayJockeyPlaylist() {
        const pjData = getPlayJockeyData();
        if (!pjData.currentPlaylistId || !pjData.playlists) {
            if (pjData.playlists && pjData.playlists.length > 0) {
                pjData.currentPlaylistId = pjData.playlists[0].id;
            } else {
                return null; // Should not happen if getPlayJockeyData initializes correctly
            }
        }
        return pjData.playlists.find(p => p.id === pjData.currentPlaylistId);
    }

    function extractYouTubeVideoId(url) {
        if (!url) return null;
        const regex = /(?:youtube\.com\/(?:[^\/\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }
    function isValidYouTubeUrl(url) {
        if (!url) return false;
        const regex = /^(https?:\/\/)?(www\.)?(youtube\.com\/(watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})([&?].*)?$/;
        return regex.test(url);
    }

    async function handlePlayJockeyInput() {
        const input = playJockeyDOM.playJockeyLinkInput.value.trim();
        if (!input) {
            alert("Please enter a YouTube link or search query.");
            return;
        }
        const apiKeyMissing = (!window.YOUTUBE_API_KEY); // Use global key
        if (isValidYouTubeUrl(input)) {
            addYouTubeLinkToPlayJockey(input);
        } else {
            if (apiKeyMissing) {
                alert("YouTube API Key is not configured. Video search is disabled. You can only add direct YouTube video links.");
                return;
            }
            searchYouTubeVideos(input);
        }
    }
    async function searchYouTubeVideos(query) {
        playJockeyDOM.youtubeSearchResultsBody.innerHTML = '';
        playJockeyDOM.youtubeSearchStatus.textContent = 'Searching...';
        playJockeyDOM.youtubeSearchStatus.style.display = 'block';
        window.openModal('youtubeSearchModal'); // Use global modal opener

        const maxResults = 10;
        const apiUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&key=${window.YOUTUBE_API_KEY}&maxResults=${maxResults}`;
        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                const errorData = await response.json();
                let errorMessage = `Error searching videos: ${response.statusText}`;
                if (errorData.error && errorData.error.message) errorMessage += ` - ${errorData.error.message}`;
                playJockeyDOM.youtubeSearchStatus.textContent = errorMessage;
                return;
            }
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                playJockeyDOM.youtubeSearchStatus.style.display = 'none';
                renderYouTubeSearchResults(data.items);
            } else {
                playJockeyDOM.youtubeSearchStatus.textContent = 'No videos found for your search query.';
            }
        } catch (error) {
            playJockeyDOM.youtubeSearchStatus.textContent = 'Failed to search videos. Check console for details.';
        }
    }

    function renderYouTubeSearchResults(items) {
        playJockeyDOM.youtubeSearchResultsBody.innerHTML = ''; // Clear previous results
        items.forEach(item => {
            const videoId = item.id.videoId;
            const title = decodeHtmlEntities(item.snippet.title);
            const channelTitle = decodeHtmlEntities(item.snippet.channelTitle);
            const thumbnailUrl = item.snippet.thumbnails.default.url;

            const resultDiv = document.createElement('div');
            resultDiv.className = 'Youtube-result-item';
            resultDiv.dataset.videoId = videoId;

            const img = document.createElement('img');
            img.src = thumbnailUrl;
            img.alt = title;

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'Youtube-result-item-details';
            const titleDiv = document.createElement('div');
            titleDiv.className = 'Youtube-result-item-title';
            titleDiv.textContent = title;
            titleDiv.title = title; // Full title on hover
            const channelDiv = document.createElement('div');
            channelDiv.className = 'Youtube-result-item-channel';
            channelDiv.textContent = channelTitle;
            channelDiv.title = channelTitle;

            detailsDiv.appendChild(titleDiv);
            detailsDiv.appendChild(channelDiv);
            resultDiv.appendChild(img);
            resultDiv.appendChild(detailsDiv);

            resultDiv.addEventListener('click', () => {
                addVideoFromSearchResult(videoId, title, channelTitle);
                window.closeModal('youtubeSearchModal');
            });
            playJockeyDOM.youtubeSearchResultsBody.appendChild(resultDiv);
        });
    }
    function addVideoFromSearchResult(videoId, title, artist) {
        const pjData = getPlayJockeyData();
        let currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist) {
            addNewPlayJockeyPlaylist(); // This will also switch to the new playlist
            currentPlaylist = getCurrentPlayJockeyPlaylist();
            if (!currentPlaylist) { alert("Error: Could not create or find a playlist."); return; }
        }
        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            playJockeyDOM.playJockeyLinkInput.value = '';
            return;
        }
        const videoEntry = {
            id: 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7),
            originalUrl: `https://www.youtube.com/watch?v=$$$$$$$$${videoId}`, // Placeholder
            videoId: videoId,
            title: title,
            artist: artist.replace(/\s-\sTopic$/, '').trim() // Remove "- Topic" from artist if present
        };
        currentPlaylist.videos.push(videoEntry);
        renderPlayJockeyPlaylist();
        playJockeyDOM.playJockeyLinkInput.value = '';
        if (!ytPlayerInstance || !pjData.currentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true); // Autoplay if it's the first video or no player active
        }
        window.saveData();
    }

    function addYouTubeLinkToPlayJockey(link) {
        const pjData = getPlayJockeyData();
        if (!link) { alert("Please enter a YouTube link."); return; }
        const videoId = extractYouTubeVideoId(link);
        if (!videoId) { alert("Invalid YouTube link."); return; }

        let currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist) {
            addNewPlayJockeyPlaylist();
            currentPlaylist = getCurrentPlayJockeyPlaylist();
            if (!currentPlaylist) { console.error("Failed to create/get playlist."); return; }
        }
        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            playJockeyDOM.playJockeyLinkInput.value = '';
            return;
        }
        const tempId = 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7);
        const videoEntry = {
            id: tempId,
            originalUrl: link,
            videoId: videoId,
            title: "Loading title...", // Placeholder
            artist: ""
        };
        currentPlaylist.videos.push(videoEntry);
        renderPlayJockeyPlaylist(); // Show immediately with "Loading..."
        playJockeyDOM.playJockeyLinkInput.value = '';
        fetchYouTubeTitle(videoEntry, currentPlaylist.id); // Fetch title in background
        if (!ytPlayerInstance || !pjData.currentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true);
        }
        window.saveData();
    }

    async function fetchYouTubeTitle(videoEntryToUpdate, playlistId) {
        try {
            let newTitle = "Unknown Title";
            let newArtist = "";
            if (window.YOUTUBE_API_KEY) { // Use global key
                 const apiUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoEntryToUpdate.videoId}&key=${window.YOUTUBE_API_KEY}`;
                 const response = await fetch(apiUrl);
                 if (response.ok) {
                     const data = await response.json();
                     if (data.items && data.items.length > 0) {
                         newTitle = decodeHtmlEntities(data.items[0].snippet.title);
                         newArtist = decodeHtmlEntities(data.items[0].snippet.channelTitle).replace(/\s-\sTopic$/, '').trim();
                     } else { newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl); }
                 } else { newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl); }
            } else { // Fallback to oEmbed if no API key
                try {
                    const oEmbedUrl = `https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=$$$$$$$$${videoEntryToUpdate.videoId}&format=json`;
                    const oEmbedResponse = await fetch(oEmbedUrl);
                    if (oEmbedResponse.ok) {
                        const oEmbedData = await oEmbedResponse.json();
                        newTitle = decodeHtmlEntities(oEmbedData.title);
                        newArtist = decodeHtmlEntities(oEmbedData.author_name).replace(/\s-\sTopic$/, '').trim();
                    } else { newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl); }
                } catch (oEmbedError) { newTitle = decodeHtmlEntities(videoEntryToUpdate.originalUrl); }
            }
            const pjData = getPlayJockeyData();
            const targetPlaylist = pjData.playlists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const itemInPlaylist = targetPlaylist.videos.find(item => item.id === videoEntryToUpdate.id);
                if (itemInPlaylist) {
                    itemInPlaylist.title = newTitle;
                    itemInPlaylist.artist = newArtist;
                    if (pjData.currentPlaylistId === playlistId) renderPlayJockeyPlaylist();
                    if(pjData.currentVideo && pjData.currentVideo.id === itemInPlaylist.id) {
                        pjData.currentVideo.title = newTitle;
                        pjData.currentVideo.artist = newArtist;
                    }
                    window.saveData();
                }
            }
        } catch (error) {
            // Handle error, maybe set title to original URL if all fails
        }
    }

    function renderPlayJockeyTabs() {
        const pjData = getPlayJockeyData();
        playJockeyDOM.playJockeyTabsBar.innerHTML = ''; // Clear existing tabs
        pjData.playlists.forEach(playlist => {
            const tab = document.createElement('div');
            tab.className = 'playjockey-tab';
            const displayName = decodeHtmlEntities(playlist.name);
            tab.textContent = displayName;
            tab.title = displayName;
            tab.dataset.playlistId = playlist.id;
            if (playlist.id === pjData.currentPlaylistId) {
                tab.classList.add('active');
            }
            tab.addEventListener('click', () => switchPlayJockeyPlaylist(playlist.id));
            tab.addEventListener('contextmenu', (e) => showPjTabContextMenu(e, playlist.id));
            playJockeyDOM.playJockeyTabsBar.appendChild(tab);
        });
        const addTabBtn = document.createElement('button');
        addTabBtn.className = 'playjockey-tab playjockey-add-tab-btn xp-button xp-button-small';
        addTabBtn.textContent = '+';
        addTabBtn.title = "New Playlist";
        addTabBtn.addEventListener('click', addNewPlayJockeyPlaylist);
        playJockeyDOM.playJockeyTabsBar.appendChild(addTabBtn);
    }

    function addNewPlayJockeyPlaylist() {
        const pjData = getPlayJockeyData();
        let newPlaylistName = "Playlist";
        let counter = pjData.playlists.length + 1;
        const existingNames = pjData.playlists.map(p => p.name.toLowerCase());
        let potentialName = `${newPlaylistName} ${counter}`.toLowerCase();
        while (existingNames.includes(potentialName)) {
            counter++;
            potentialName = `${newPlaylistName} ${counter}`.toLowerCase();
        }
        newPlaylistName = `${newPlaylistName} ${counter}`;
        
        const newPlaylistId = 'playlist_' + Date.now() + '_' + Math.random().toString(36).substring(2,9);
        pjData.playlists.push({ id: newPlaylistId, name: newPlaylistName, videos: [] });
        switchPlayJockeyPlaylist(newPlaylistId); // Also saves data
    }

    function switchPlayJockeyPlaylist(playlistId) {
        const pjData = getPlayJockeyData();
        if (pjData.currentPlaylistId === playlistId) return;
        pjData.currentPlaylistId = playlistId;
        pjData.currentVideo = null;
        pjData.randomHistory = [];
        if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
            ytPlayerInstance.stopVideo();
            playJockeyDOM.playJockeyPlayer.innerHTML = ''; // Clear player content
            ytPlayerInstance = null; // Reset player instance
        }
        renderPlayJockeyTabs();
        renderPlayJockeyPlaylist();
        window.saveData();
    }

    function renderPlayJockeyPlaylist() {
        const pjData = getPlayJockeyData();
        playJockeyDOM.playJockeyPlaylist.innerHTML = '';
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist || currentPlaylist.videos.length === 0) {
            const emptyMsg = document.createElement('div');
            emptyMsg.textContent = "Playlist is empty. Add YouTube links or search!";
            emptyMsg.style.padding = "10px";
            emptyMsg.style.textAlign = "center";
            emptyMsg.style.color = "#555";
            playJockeyDOM.playJockeyPlaylist.appendChild(emptyMsg);
            updatePlayingClassInPlaylist(null);
            return;
        }
        currentPlaylist.videos.forEach(video => {
            const item = document.createElement('div');
            item.className = 'playjockey-playlist-item';
            let cleanTitle = decodeHtmlEntities(video.title);
            let cleanArtist = decodeHtmlEntities(video.artist);
            let displayTitle = cleanTitle;
            if (cleanTitle === "Loading title..." || cleanTitle === video.originalUrl || !cleanTitle.trim()) {
                const decodedOriginalUrl = decodeHtmlEntities(video.originalUrl);
                displayTitle = decodedOriginalUrl.length > 40 ? decodedOriginalUrl.substring(0, 37) + '...' : decodedOriginalUrl;
            } else {
                 displayTitle = cleanTitle.length > 40 ? cleanTitle.substring(0, 37) + '...' : cleanTitle;
            }
            let itemText = displayTitle;
            let itemTooltip = (cleanTitle !== "Loading title..." && cleanTitle.trim()) ? cleanTitle : decodeHtmlEntities(video.originalUrl);
            if (cleanArtist && cleanArtist.trim() !== "") {
                const artistShort = cleanArtist.length > 20 ? cleanArtist.substring(0, 17) + '...' : cleanArtist;
                itemText = `${displayTitle} - ${artistShort}`;
                itemTooltip = `${itemTooltip} by ${cleanArtist}`;
            }
            item.textContent = itemText;
            item.title = itemTooltip;
            item.dataset.videoId = video.videoId;
            item.dataset.playlistItemId = video.id;
            item.draggable = true;
            if (pjData.currentVideo && pjData.currentVideo.id === video.id) {
                item.classList.add('playing');
            }
            item.addEventListener('click', (event) => {
                if (event.target.closest('.context-modal')) return;
                if (item.classList.contains('dragging')) return;
                const clickedItem = event.currentTarget;
                if (clickedItem && clickedItem.dataset.videoId) {
                    playYouTubeVideoById(clickedItem.dataset.videoId, true, true);
                }
            });
            playJockeyDOM.playJockeyPlaylist.appendChild(item);
        });
    }

    function playYouTubeVideoById(videoId, autoplayIntent = true, isManualPlay = false) {
        const pjData = getPlayJockeyData();
        if (!videoId) return;
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!currentPlaylist) return;
        const videoToPlay = currentPlaylist.videos.find(v => v.videoId === videoId);
        if (!videoToPlay) {
            pjData.currentVideo = null;
            updatePlayingClassInPlaylist(null);
            if(ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') ytPlayerInstance.stopVideo();
            return;
        }
        if ( isManualPlay && videoToPlay && pjData.randomEnabled &&
             pjData.autoPlayEnabled && pjData.repeatState === "off" &&
             currentPlaylist.videos.length > 0 ) {
            const uniqueVideoIdsInPlaylist = new Set(currentPlaylist.videos.map(v => v.id));
            if (new Set(pjData.randomHistory).size >= uniqueVideoIdsInPlaylist.size) {
                 pjData.randomHistory = [videoToPlay.id];
            } else if (!pjData.randomHistory.includes(videoToPlay.id)) {
                 pjData.randomHistory.push(videoToPlay.id);
            }
        }
        pjData.currentVideo = { ...videoToPlay }; // Store a copy
        updatePlayingClassInPlaylist(videoToPlay.id);
        window.saveData();

        if (!isYouTubeApiReady) {
            pendingVideoToLoad = { videoId, autoplayIntent };
            return;
        }
        if (ytPlayerInstance && typeof ytPlayerInstance.loadVideoById === 'function') {
            ytPlayerInstance.loadVideoById({ 'videoId': videoId });
            if (autoplayIntent && typeof ytPlayerInstance.playVideo === 'function') ytPlayerInstance.playVideo();
        } else {
            if (playJockeyDOM.playJockeyPlayer.firstChild && playJockeyDOM.playJockeyPlayer.firstChild.tagName === 'IFRAME') {
                 playJockeyDOM.playJockeyPlayer.innerHTML = ''; // Clear old player if any
            }
            ytPlayerInstance = new YT.Player('playJockeyPlayer', {
                height: '100%', width: '100%', videoId: videoId,
                playerVars: { 'autoplay': autoplayIntent ? 1 : 0, 'controls': 1, 'enablejsapi': 1, 
                              'origin': window.location.origin, 'modestbranding': 1, 'rel': 0 },
                events: { 'onReady': (event) => { if (autoplayIntent) event.target.playVideo(); },
                          'onStateChange': onPlayerStateChange }
            });
        }
    }

    function onPlayerStateChange(event) {
        const pjData = getPlayJockeyData();
        if (event.data === YT.PlayerState.ENDED && pjData.autoPlayEnabled) {
            playNextPjVideo();
        }
    }

    function playNextPjVideo() {
        const pjData = getPlayJockeyData();
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!ytPlayerInstance || !pjData.currentVideo || !currentPlaylist || currentPlaylist.videos.length === 0) return;

        let nextVideoItem = null;
        const currentVideoUniqueId = pjData.currentVideo.id;
        const activePlaylistVideos = currentPlaylist.videos;

        if (pjData.repeatState === "song") {
            nextVideoItem = activePlaylistVideos.find(item => item.id === currentVideoUniqueId);
        } else if (pjData.randomEnabled) {
            if (activePlaylistVideos.length === 0) return;
            if (activePlaylistVideos.length === 1) {
                if (pjData.repeatState === "off") {
                     if (pjData.randomHistory.includes(currentVideoUniqueId)) return; // Already played the only song
                     nextVideoItem = activePlaylistVideos[0];
                } else { // Repeat playlist or song (song is handled above)
                    nextVideoItem = activePlaylistVideos[0];
                }
            } else { // More than one video
                let eligibleVideos = activePlaylistVideos.filter(video => !pjData.randomHistory.includes(video.id) || video.id === currentVideoUniqueId);
                
                // If only current video is eligible and we are not repeating song, try to pick another one
                if (eligibleVideos.length === 1 && eligibleVideos[0].id === currentVideoUniqueId && pjData.repeatState !== "song") {
                     eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                     if (eligibleVideos.length === 0 && pjData.repeatState === "playlist") { // All others played, reset history
                        pjData.randomHistory = [currentVideoUniqueId]; // Keep current out for now
                        eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                     }
                } else if (eligibleVideos.length === 0 && pjData.repeatState === "playlist") { // All played, reset history
                    pjData.randomHistory = [currentVideoUniqueId]; // Keep current out for now
                    eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                }

                if (eligibleVideos.length === 0) { // If still no eligible videos
                    if (pjData.repeatState === "playlist") { // If repeating playlist, fully reset and pick any
                        pjData.randomHistory = [];
                        eligibleVideos = [...activePlaylistVideos];
                        if(activePlaylistVideos.length === 1) nextVideoItem = activePlaylistVideos[0];
                    } else { // Not repeating playlist, and all unique videos played
                        pjData.randomHistory = []; // Clear history as we are done with this random sequence
                        return; // Stop if not repeating and all unique played
                    }
                }
                if (eligibleVideos.length > 0 && !nextVideoItem) {
                    const randomIndex = Math.floor(Math.random() * eligibleVideos.length);
                    nextVideoItem = eligibleVideos[randomIndex];
                }
            }
            if (nextVideoItem) {
                if (!pjData.randomHistory.includes(nextVideoItem.id)) {
                     pjData.randomHistory.push(nextVideoItem.id);
                }
                // Manage history size if repeating playlist
                if (pjData.repeatState === "playlist") {
                    const maxHistorySize = Math.max(0, activePlaylistVideos.length -1); // Keep all but current for next random pick
                    while (pjData.randomHistory.length > maxHistorySize && maxHistorySize > 0 && pjData.randomHistory.length >= activePlaylistVideos.length) {
                        pjData.randomHistory.shift();
                    }
                }
            }
        } else { // Sequential playback
            const currentIndex = activePlaylistVideos.findIndex(item => item.id === currentVideoUniqueId);
            if (currentIndex === -1) return; // Should not happen
            let nextIndex = currentIndex + 1;
            if (nextIndex >= activePlaylistVideos.length) {
                if (pjData.repeatState === "playlist") {
                    nextIndex = 0;
                } else {
                    return; // End of playlist, no repeat
                }
            }
            if (activePlaylistVideos[nextIndex]) {
                nextVideoItem = activePlaylistVideos[nextIndex];
            }
        }

        if (nextVideoItem && nextVideoItem.videoId) {
            playYouTubeVideoById(nextVideoItem.videoId, true, false); // Autoplay next, not manual
        }
    }


    function updatePlayingClassInPlaylist(playingItemId) {
        const items = playJockeyDOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item');
        items.forEach(item => {
            if (item.dataset.playlistItemId === playingItemId) {
                item.classList.add('playing');
            } else {
                item.classList.remove('playing');
            }
        });
    }
    
    // Context Menu Logic
    function showPjContextMenu(e) {
        e.preventDefault();
        hidePjContextMenu(); hidePjTabContextMenu(); // Close other context menus
        const clickedPlaylistItem = e.target.closest('.playjockey-playlist-item');
        if (clickedPlaylistItem) {
            playJockeyDOM.playJockeyContextMenu.style.display = 'block';
            positionContextMenu(e, playJockeyDOM.playJockeyContextMenu);
            playJockeyDOM.playJockeyContextMenu.dataset.currentItemId = clickedPlaylistItem.dataset.playlistItemId;
        }
    }
    function hidePjContextMenu() {
        playJockeyDOM.playJockeyContextMenu.style.display = 'none';
        delete playJockeyDOM.playJockeyContextMenu.dataset.currentItemId;
    }
    function showPjTabContextMenu(e, playlistId) {
        e.preventDefault();
        hidePjContextMenu(); hidePjTabContextMenu();
        playJockeyDOM.playJockeyTabContextMenu.style.display = 'block';
        positionContextMenu(e, playJockeyDOM.playJockeyTabContextMenu);
        playJockeyDOM.playJockeyTabContextMenu.dataset.playlistId = playlistId;
    }
    function hidePjTabContextMenu() {
        playJockeyDOM.playJockeyTabContextMenu.style.display = 'none';
        delete playJockeyDOM.playJockeyTabContextMenu.dataset.playlistId;
    }
    function positionContextMenu(event, menuElement) {
        let x = event.clientX;
        let y = event.clientY;
        const menuWidth = menuElement.offsetWidth;
        const menuHeight = menuElement.offsetHeight;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        if (x + menuWidth > viewportWidth) x = viewportWidth - menuWidth - 5;
        if (y + menuHeight > viewportHeight) y = viewportHeight - menuHeight - 5;
        x = Math.max(0, x); y = Math.max(0, y);
        menuElement.style.left = `${x}px`;
        menuElement.style.top = `${y}px`;
    }

    function handlePjContextRename() {
        const itemId = playJockeyDOM.playJockeyContextMenu.dataset.currentItemId;
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!itemId || !currentPlaylist) { hidePjContextMenu(); return; }
        const itemToRename = currentPlaylist.videos.find(video => video.id === itemId);
        if (itemToRename) {
            playJockeyDOM.trackNewNameInput.value = decodeHtmlEntities(itemToRename.title) || '';
            playJockeyDOM.trackNewArtistInput.value = decodeHtmlEntities(itemToRename.artist) || '';
            playJockeyDOM.saveRenamedTrackBtn.dataset.itemId = itemId;
            window.openModal('renameTrackModal');
            playJockeyDOM.trackNewNameInput.focus();
        }
        hidePjContextMenu();
    }
    function handlePjContextRemove() {
        const itemId = playJockeyDOM.playJockeyContextMenu.dataset.currentItemId;
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!itemId || !currentPlaylist) { hidePjContextMenu(); return; }
        const itemToRemove = currentPlaylist.videos.find(video => video.id === itemId);
        if (itemToRemove) {
            playJockeyDOM.confirmRemoveTrackMessage.textContent = `Are you sure you want to remove the track "${decodeHtmlEntities(itemToRemove.title)}"?`;
            playJockeyDOM.confirmFinalTrackRemoveBtn.dataset.itemId = itemId;
            window.openModal('confirmRemoveTrackModal');
        }
        hidePjContextMenu();
    }
    function saveRenamedTrack() {
        const itemId = playJockeyDOM.saveRenamedTrackBtn.dataset.itemId;
        const newName = playJockeyDOM.trackNewNameInput.value.trim();
        const newArtist = playJockeyDOM.trackNewArtistInput.value.trim();
        const pjData = getPlayJockeyData();
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!itemId || !currentPlaylist) { window.closeModal('renameTrackModal'); return; }
        if (!newName) { alert("Track name cannot be empty."); return; }
        const itemToRename = currentPlaylist.videos.find(video => video.id === itemId);
        if (itemToRename) {
            itemToRename.title = newName;
            itemToRename.artist = newArtist;
            if(pjData.currentVideo && pjData.currentVideo.id === itemId) {
                pjData.currentVideo.title = newName;
                pjData.currentVideo.artist = newArtist;
            }
            renderPlayJockeyPlaylist();
            window.saveData();
        }
        window.closeModal('renameTrackModal');
        delete playJockeyDOM.saveRenamedTrackBtn.dataset.itemId;
    }
    function executeTrackDeletion() {
        const itemId = playJockeyDOM.confirmFinalTrackRemoveBtn.dataset.itemId;
        const pjData = getPlayJockeyData();
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!itemId || !currentPlaylist) { window.closeModal('confirmRemoveTrackModal'); return; }
        const itemIndex = currentPlaylist.videos.findIndex(video => video.id === itemId);
        if (itemIndex > -1) {
            const removedItem = currentPlaylist.videos.splice(itemIndex, 1)[0];
            const historyIndex = pjData.randomHistory.indexOf(removedItem.id);
            if (historyIndex > -1) pjData.randomHistory.splice(historyIndex, 1);
            if (pjData.currentVideo && pjData.currentVideo.id === removedItem.id) {
                if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') ytPlayerInstance.stopVideo();
                pjData.currentVideo = null;
                if (pjData.autoPlayEnabled && currentPlaylist.videos.length > 0) playNextPjVideo();
                else if (currentPlaylist.videos.length === 0) playJockeyDOM.playJockeyPlayer.innerHTML = '';
            }
            renderPlayJockeyPlaylist();
            window.saveData();
        }
        window.closeModal('confirmRemoveTrackModal');
        delete playJockeyDOM.confirmFinalTrackRemoveBtn.dataset.itemId;
    }
    function openRenamePlaylistModalFromContextMenu() {
        const playlistId = playJockeyDOM.playJockeyTabContextMenu.dataset.playlistId;
        if (!playlistId) return;
        const pjData = getPlayJockeyData();
        const playlistToRename = pjData.playlists.find(pl => pl.id === playlistId);
        if (playlistToRename) {
            playJockeyDOM.playlistNewNameInput.value = decodeHtmlEntities(playlistToRename.name);
            playJockeyDOM.saveRenamedPlaylistBtn.dataset.playlistId = playlistId;
            window.openModal('renamePlaylistModal');
            playJockeyDOM.playlistNewNameInput.focus();
        }
        hidePjTabContextMenu();
    }
    function saveRenamedPlaylist() {
        const playlistId = playJockeyDOM.saveRenamedPlaylistBtn.dataset.playlistId;
        const newName = playJockeyDOM.playlistNewNameInput.value.trim();
        if (!playlistId || !newName) { 
            if(!newName) alert("Playlist name cannot be empty.");
            window.closeModal('renamePlaylistModal'); 
            return;
        }
        const pjData = getPlayJockeyData();
        const playlistToRename = pjData.playlists.find(pl => pl.id === playlistId);
        if (playlistToRename) {
            playlistToRename.name = newName;
            renderPlayJockeyTabs();
            window.saveData();
        }
        window.closeModal('renamePlaylistModal');
        delete playJockeyDOM.saveRenamedPlaylistBtn.dataset.playlistId;
    }
    function openConfirmRemovePlaylistModalFromContextMenu() {
        const playlistId = playJockeyDOM.playJockeyTabContextMenu.dataset.playlistId;
        if (!playlistId) return;
        const pjData = getPlayJockeyData();
        const playlistToRemove = pjData.playlists.find(pl => pl.id === playlistId);
        if (playlistToRemove) {
            playJockeyDOM.confirmRemovePlaylistMessage.textContent = `Are you sure you want to remove the playlist "${decodeHtmlEntities(playlistToRemove.name)}"?`;
            playJockeyDOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId = playlistId;
            window.openModal('confirmRemovePlaylistModal');
        }
        hidePjTabContextMenu();
    }
    function executePlaylistDeletion() {
        const playlistIdToRemove = playJockeyDOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId;
        if (!playlistIdToRemove) { window.closeModal('confirmRemovePlaylistModal'); return; }
        const pjData = getPlayJockeyData();
        const playlistIndex = pjData.playlists.findIndex(pl => pl.id === playlistIdToRemove);
        if (playlistIndex > -1) {
            pjData.playlists.splice(playlistIndex, 1);
            if (pjData.currentPlaylistId === playlistIdToRemove) {
                if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') ytPlayerInstance.stopVideo();
                pjData.currentVideo = null;
                pjData.randomHistory = [];
                if (pjData.playlists.length > 0) {
                    pjData.currentPlaylistId = pjData.playlists[0].id;
                } else { // No playlists left, create a default one
                    const defaultPlaylistId = 'playlist_default_' + Date.now();
                    pjData.playlists.push({id: defaultPlaylistId, name: "Playlist 1", videos: []});
                    pjData.currentPlaylistId = defaultPlaylistId;
                }
            }
        }
        if (pjData.playlists.length === 0) { // Should be handled above, but as a safeguard
            const defaultPlaylistId = 'playlist_default_' + Date.now();
            pjData.playlists.push({id: defaultPlaylistId, name: "Playlist 1", videos: []});
            pjData.currentPlaylistId = defaultPlaylistId;
        }
        renderPlayJockeyTabs();
        renderPlayJockeyPlaylist(); // Will update based on new current playlist
        window.saveData();
        window.closeModal('confirmRemovePlaylistModal');
        delete playJockeyDOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId;
    }

    // Drag and Drop for Playlist Items
    function handlePjDragStart(e) {
        const target = e.target.closest('.playjockey-playlist-item');
        if (target) {
            pjDraggedItem = target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', target.dataset.playlistItemId); // Store unique ID
            setTimeout(() => target.classList.add('dragging'), 0);
            hidePjContextMenu(); // Close context menu if open
        }
    }
    function handlePjDragEnd(e) {
        if (pjDraggedItem) pjDraggedItem.classList.remove('dragging');
        playJockeyDOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
        pjDraggedItem = null;
    }
    function clearPjDragOverHighlights() {
        playJockeyDOM.playJockeyPlaylist.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
    }
    function handlePjDragOver(e) {
        e.preventDefault();
        const targetItem = e.target.closest('.playjockey-playlist-item');
        clearPjDragOverHighlights();
        if (targetItem && pjDraggedItem && targetItem !== pjDraggedItem) {
            const rect = targetItem.getBoundingClientRect();
            const midpointY = rect.top + rect.height / 2;
            if (e.clientY < midpointY) {
                targetItem.classList.add('drag-over-target-before');
            } else {
                targetItem.classList.add('drag-over-target-after');
            }
        }
    }
    function handlePjDragLeave(e) {
        const relatedTargetIsChildOrSelf = playJockeyDOM.playJockeyPlaylist.contains(e.relatedTarget);
        if (!relatedTargetIsChildOrSelf) {
             clearPjDragOverHighlights();
        } else {
            const targetItem = e.target.closest('.playjockey-playlist-item');
            if (targetItem) targetItem.classList.remove('drag-over-target-before', 'drag-over-target-after');
        }
    }
    function handlePjDrop(e) {
        e.preventDefault();
        clearPjDragOverHighlights();
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (!pjDraggedItem || !currentPlaylist) return;

        const draggedItemId = e.dataTransfer.getData('text/plain');
        const targetItemElement = e.target.closest('.playjockey-playlist-item');
        
        const draggedItemIndex = currentPlaylist.videos.findIndex(item => item.id === draggedItemId);
        if (draggedItemIndex === -1) return;

        const itemToMove = currentPlaylist.videos[draggedItemIndex];
        currentPlaylist.videos.splice(draggedItemIndex, 1); // Remove from old position

        let targetIndex = -1;
        if (targetItemElement && targetItemElement.dataset.playlistItemId !== draggedItemId) {
            const targetItemId = targetItemElement.dataset.playlistItemId;
            targetIndex = currentPlaylist.videos.findIndex(item => item.id === targetItemId);
            if (targetIndex !== -1) {
                const rect = targetItemElement.getBoundingClientRect();
                const midpointY = rect.top + rect.height / 2;
                if (e.clientY >= midpointY) targetIndex++; // Insert after if dropped on lower half
            }
        }

        if (targetIndex !== -1 && targetIndex <= currentPlaylist.videos.length) {
            currentPlaylist.videos.splice(targetIndex, 0, itemToMove);
        } else { // Dropped in empty space or on itself (effectively to end)
            currentPlaylist.videos.push(itemToMove);
        }
        renderPlayJockeyPlaylist();
        window.saveData();
        pjDraggedItem = null;
    }

    // Playback Controls
    function togglePlayJockeyAutoPlay() {
        const pjData = getPlayJockeyData();
        pjData.autoPlayEnabled = !pjData.autoPlayEnabled;
        updatePlayJockeyAutoPlayButtonState();
        window.saveData();
    }
    function updatePlayJockeyAutoPlayButtonState() {
        const pjData = getPlayJockeyData();
        playJockeyDOM.playJockeyAutoPlayBtn.classList.toggle('autoplay-on', pjData.autoPlayEnabled);
        playJockeyDOM.playJockeyAutoPlayBtn.textContent = `Auto Play: ${pjData.autoPlayEnabled ? 'On' : 'Off'}`;
    }
    function togglePlayJockeyRandom() {
        const pjData = getPlayJockeyData();
        pjData.randomEnabled = !pjData.randomEnabled;
        pjData.randomHistory = []; // Reset history on toggle
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (pjData.randomEnabled && pjData.currentVideo && currentPlaylist && currentPlaylist.videos.length > 0) {
             if (currentPlaylist.videos.length > 1 || pjData.repeatState !== "off") {
                 pjData.randomHistory.push(pjData.currentVideo.id);
            }
        }
        updatePlayJockeyRandomButtonState();
        window.saveData();
    }
    function updatePlayJockeyRandomButtonState() {
        const pjData = getPlayJockeyData();
        playJockeyDOM.playJockeyRandomBtn.classList.toggle('random-on', pjData.randomEnabled);
        playJockeyDOM.playJockeyRandomBtn.textContent = `Random: ${pjData.randomEnabled ? 'On' : 'Off'}`;
    }
    function cyclePlayJockeyRepeat() {
        const pjData = getPlayJockeyData();
        const states = ["off", "playlist", "song"];
        let currentIndex = states.indexOf(pjData.repeatState);
        currentIndex = (currentIndex + 1) % states.length;
        pjData.repeatState = states[currentIndex];
        pjData.randomHistory = []; // Reset history as repeat state affects random logic
        const currentPlaylist = getCurrentPlayJockeyPlaylist();
        if (pjData.randomEnabled && pjData.currentVideo && currentPlaylist && currentPlaylist.videos.length > 0) {
             if (currentPlaylist.videos.length > 1 || pjData.repeatState !== "off") {
                 pjData.randomHistory.push(pjData.currentVideo.id);
            }
        }
        updatePlayJockeyRepeatButtonState();
        window.saveData();
    }
    function updatePlayJockeyRepeatButtonState() {
        const pjData = getPlayJockeyData();
        playJockeyDOM.playJockeyRepeatBtn.classList.remove('repeat-on'); // Remove first
        switch (pjData.repeatState) {
            case "off":      playJockeyDOM.playJockeyRepeatBtn.textContent = 'Repeat: Off'; break;
            case "playlist": playJockeyDOM.playJockeyRepeatBtn.textContent = 'Repeat: List'; playJockeyDOM.playJockeyRepeatBtn.classList.add('repeat-on'); break;
            case "song":     playJockeyDOM.playJockeyRepeatBtn.textContent = 'Repeat: One';  playJockeyDOM.playJockeyRepeatBtn.classList.add('repeat-on'); break;
        }
    }

    function setupPlayJockeyApp() {
        const windowBody = getById('playJockeyWindowBody');
        const bodyContentTemplate = document.getElementById('playJockeyBodyContentTemplate');

        if (windowBody && bodyContentTemplate) {
            windowBody.innerHTML = '';
            windowBody.appendChild(bodyContentTemplate.content.cloneNode(true));
        } else {
            console.error("Play Jockey window body or content template not found.");
            return;
        }
        
        if (!window.appRegistry) window.appRegistry = {};
        window.appRegistry[APP_ID] = {
            minWidth: MIN_WIDTH,
            minHeight: MIN_HEIGHT,
            defaultWidth: DEFAULT_WIDTH,
            defaultHeight: DEFAULT_HEIGHT,
            appName: "Play Jockey"
        };
        
        initPlayJockeyApp();
    }

    window.setupPlayJockeyApp = setupPlayJockeyApp;

})();
</script>
