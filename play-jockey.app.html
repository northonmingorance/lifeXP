<body data-app-id="playJockey">

    <template id="playJockey-icon-template">
        <div style="font-size: 48px; line-height: 1; margin-bottom: 8px; filter: hue-rotate(140deg) saturate(1000%) brightness(70%);">⏯️</div>
        <div style="position: absolute; width: 90px; height: 100px; text-align: center; color: white; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 10px; box-sizing: border-box; z-index: 5; font-size: 48px; line-height: 1; text-shadow: none; margin-bottom: 8px; top: -66px; filter: hue-rotate(140deg) saturate(1000%); mix-blend-mode: luminosity;">⏯️</div>
        <div style="font-size: 12px; font-weight: normal; word-wrap: break-word; max-width: 100%; position: relative; top: -66px;">Play Jockey</div>
    </template>

    <template id="playJockey-window-template">
        <div class="xp-window" id="playJockeyWindow" style="display:none;">
            <div class="title-bar">
                <span class="title-bar-text">Play Jockey</span>
                <div class="title-bar-controls">
                    <button data-app-action="minimize" title="Minimize">0</button>
                    <button data-app-action="maximize" title="Maximize">1</button>
                    <button data-app-action="close" title="Close">r</button>
                </div>
            </div>
            <div class="window-body" id="playJockeyWindowBody" style="padding:0;">
                <div style="display: flex; flex-direction: column; width: 100%; height: 100%; background-color: #D4D0C8; padding: 5px; box-sizing: border-box;">
                    <div style="display: flex; margin-bottom: 5px; padding: 5px; background-color: #C0C0C0; border: 1px outset #FFFFFF; border-right-color: #808080; border-bottom-color: #808080; flex-shrink: 0;">
                        <input type="text" id="playJockeyLinkInput" placeholder="Paste YouTube Link or Search Query" style="flex-grow: 1; margin-right: 5px; border: 1px inset #7F7F7F; padding: 4px; font-family: 'Tahoma', sans-serif; font-size: 11px; background-color: #FFFFFF;">
                        <button id="playJockeyAddBtn" class="xp-button" style="min-width: 60px; padding: 3px 8px; font-size: 11px;">Add</button>
                    </div>
                    <div style="flex-grow: 1; margin-bottom: 5px; border: 2px inset #808080; background-color: black; min-height: 150px; overflow: hidden;">
                        <div id="playJockeyPlayer" style="width: 100%; height: 100%;"></div>
                    </div>
                     <div id="playJockeyTabsBar" style="display: flex; flex-wrap: nowrap; overflow-x: auto; background-color: #C0C0C0; padding: 3px 3px 0 3px; border-bottom: 1px solid #808080; flex-shrink: 0; gap: 2px;"></div>
                    <div id="playJockeyPlaylist" style="height: 100px; overflow-y: auto; border: 1px inset #7F7F7F; background-color: #FFFFFF; padding: 3px; flex-shrink: 0; border-top: none; position: relative; z-index: 0;"></div>
                    <div style="display: flex; justify-content: center; padding: 5px 0px; flex-shrink: 0; gap: 5px; border-top: 1px solid #ACA899; background-color: #F0F0F0;">
                        <button id="playJockeyRandomBtn" class="xp-button" style="min-width: 90px; padding: 3px 8px; font-size: 11px;">Random: Off</button>
                        <button id="playJockeyAutoPlayBtn" class="xp-button" style="min-width: 90px; padding: 3px 8px; font-size: 11px;">Auto Play: On</button>
                        <button id="playJockeyRepeatBtn" class="xp-button" style="min-width: 90px; padding: 3px 8px; font-size: 11px;">Repeat: Off</button>
                    </div>
                </div>
            </div>
            <div class="resize-handle"></div>
            
            <div id="playJockeyContextMenu" class="context-modal" style="display: none; position: fixed; background-color: #ECE9D8; border: 1px solid #000; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); z-index: 2000; padding: 3px 0; min-width: 120px; font-family: 'Tahoma', sans-serif; font-size: 11px;">
                <div class="context-modal-item" id="pjContextRename" style="padding: 5px 12px; cursor: default; color: black;">Rename Track</div>
                <div class="context-modal-item" id="pjContextRemove" style="padding: 5px 12px; cursor: default; color: black;">Remove Track</div>
            </div>
            <div id="playJockeyTabContextMenu" class="context-modal" style="display: none; position: fixed; background-color: #ECE9D8; border: 1px solid #000; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); z-index: 2000; padding: 3px 0; min-width: 120px; font-family: 'Tahoma', sans-serif; font-size: 11px;">
                <div class="context-modal-item" id="pjTabContextRename" style="padding: 5px 12px; cursor: default; color: black;">Rename Playlist</div>
                <div class="context-modal-item" id="pjTabContextRemove" style="padding: 5px 12px; cursor: default; color: black;">Remove Playlist</div>
            </div>
            <div id="pjRenamePlaylistModal" class="modal"><div class="modal-content" style="max-width:400px"><div class="modal-title-bar"><span>Rename Playlist</span><span class="close-button" data-modal-id="pjRenamePlaylistModal">r</span></div><div class="modal-body"><label for="pjPlaylistNewNameInput">New name:</label><input type="text" id="pjPlaylistNewNameInput"></div><div class="modal-footer"><button id="pjSaveRenamedPlaylistBtn" class="xp-button">Save</button><button class="xp-button" data-modal-id="pjRenamePlaylistModal">Cancel</button></div></div></div>
            <div id="pjConfirmRemovePlaylistModal" class="modal"><div class="modal-content" style="max-width:400px"><div class="modal-title-bar"><span>Confirm Deletion</span><span class="close-button" data-modal-id="pjConfirmRemovePlaylistModal">r</span></div><div class="modal-body"><p id="pjConfirmRemovePlaylistMessage">Are you sure?</p></div><div class="modal-footer"><button id="pjConfirmFinalPlaylistRemoveBtn" class="xp-button">Delete</button><button class="xp-button" data-modal-id="pjConfirmRemovePlaylistModal">Cancel</button></div></div></div>
            <div id="pjYoutubeSearchModal" class="modal"><div class="modal-content" style="max-width:600px"><div class="modal-title-bar"><span>Youtube Results</span><span class="close-button" data-modal-id="pjYoutubeSearchModal">r</span></div><div class="modal-body" id="pjYoutubeSearchResultsBody" style="max-height:400px;overflow-y:auto;"><p id="pjYoutubeSearchStatus" style="text-align:center;display:none;"></p></div><div class="modal-footer"><button class="xp-button" data-modal-id="pjYoutubeSearchModal">Cancel</button></div></div></div>
            <div id="pjRenameTrackModal" class="modal"><div class="modal-content" style="max-width:400px"><div class="modal-title-bar"><span>Rename Track</span><span class="close-button" data-modal-id="pjRenameTrackModal">r</span></div><div class="modal-body"><label for="pjTrackNewNameInput">New name:</label><input type="text" id="pjTrackNewNameInput"><label for="pjTrackNewArtistInput" style="margin-top:10px;">Artist (optional):</label><input type="text" id="pjTrackNewArtistInput"></div><div class="modal-footer"><button id="pjSaveRenamedTrackBtn" class="xp-button">Save</button><button class="xp-button" data-modal-id="pjRenameTrackModal">Cancel</button></div></div></div>
            <div id="pjConfirmRemoveTrackModal" class="modal"><div class="modal-content" style="max-width:400px"><div class="modal-title-bar"><span>Confirm Deletion</span><span class="close-button" data-modal-id="pjConfirmRemoveTrackModal">r</span></div><div class="modal-body"><p id="pjConfirmRemoveTrackMessage">Are you sure?</p></div><div class="modal-footer"><button id="pjConfirmFinalTrackRemoveBtn" class="xp-button">Delete</button><button class="xp-button" data-modal-id="pjConfirmRemoveTrackModal">Cancel</button></div></div></div>
        </div>
    </template>

    <script type="application/json" id="playJockey-config">
    {
        "minWidth": 375,
        "minHeight": 350,
        "defaultWidth": 480,
        "defaultHeight": 705,
        "defaultOffsetX": 120,
        "defaultOffsetY": 120
    }
    </script>
    
    <script id="playJockey-script">
    const appWindow = this.appWindow;
    const appData = this.appData; // app-specific data managed by OS
    const os = this.os; // OS API

    let YOUTUBE_API_KEY = os.getGlobalConfig('YOUTUBE_API_KEY');
    let ytPlayerInstance = null;
    let isYouTubeApiReady = false;
    let pendingVideoToLoad = null;
    let pjDraggedItem = null;

    const DOM = {
        linkInput: appWindow.querySelector('#playJockeyLinkInput'),
        addBtn: appWindow.querySelector('#playJockeyAddBtn'),
        playerContainer: appWindow.querySelector('#playJockeyPlayer'),
        tabsBar: appWindow.querySelector('#playJockeyTabsBar'),
        playlistArea: appWindow.querySelector('#playJockeyPlaylist'),
        randomBtn: appWindow.querySelector('#playJockeyRandomBtn'),
        autoPlayBtn: appWindow.querySelector('#playJockeyAutoPlayBtn'),
        repeatBtn: appWindow.querySelector('#playJockeyRepeatBtn'),
        contextMenu: appWindow.querySelector('#playJockeyContextMenu'),
        contextRenameBtn: appWindow.querySelector('#pjContextRename'),
        contextRemoveBtn: appWindow.querySelector('#pjContextRemove'),
        tabContextMenu: appWindow.querySelector('#playJockeyTabContextMenu'),
        tabContextRenameBtn: appWindow.querySelector('#pjTabContextRename'),
        tabContextRemoveBtn: appWindow.querySelector('#pjTabContextRemove'),
        renamePlaylistModal: appWindow.querySelector('#pjRenamePlaylistModal'),
        playlistNewNameInput: appWindow.querySelector('#pjPlaylistNewNameInput'),
        saveRenamedPlaylistBtn: appWindow.querySelector('#pjSaveRenamedPlaylistBtn'),
        confirmRemovePlaylistModal: appWindow.querySelector('#pjConfirmRemovePlaylistModal'),
        confirmRemovePlaylistMessage: appWindow.querySelector('#pjConfirmRemovePlaylistMessage'),
        confirmFinalPlaylistRemoveBtn: appWindow.querySelector('#pjConfirmFinalPlaylistRemoveBtn'),
        youtubeSearchModal: appWindow.querySelector('#pjYoutubeSearchModal'),
        youtubeSearchResultsBody: appWindow.querySelector('#pjYoutubeSearchResultsBody'),
        youtubeSearchStatus: appWindow.querySelector('#pjYoutubeSearchStatus'),
        renameTrackModal: appWindow.querySelector('#pjRenameTrackModal'),
        trackNewNameInput: appWindow.querySelector('#pjTrackNewNameInput'),
        trackNewArtistInput: appWindow.querySelector('#pjTrackNewArtistInput'),
        saveRenamedTrackBtn: appWindow.querySelector('#pjSaveRenamedTrackBtn'),
        confirmRemoveTrackModal: appWindow.querySelector('#pjConfirmRemoveTrackModal'),
        confirmRemoveTrackMessage: appWindow.querySelector('#pjConfirmRemoveTrackMessage'),
        confirmFinalTrackRemoveBtn: appWindow.querySelector('#pjConfirmFinalTrackRemoveBtn'),
    };

    function initializeDefaultAppData() {
        const defaultPlaylistId = 'playlist_default_0';
        if (!appData.playlists) appData.playlists = [{id: defaultPlaylistId, name: "Playlist", videos: []}];
        if (!appData.currentPlaylistId) appData.currentPlaylistId = appData.playlists[0]?.id || defaultPlaylistId;
        if (appData.autoPlayEnabled === undefined) appData.autoPlayEnabled = true;
        if (appData.randomEnabled === undefined) appData.randomEnabled = false;
        if (!appData.repeatState) appData.repeatState = "off";
        if (!appData.randomHistory) appData.randomHistory = [];
        if (appData.playlists.length === 0) { // Ensure at least one playlist exists
             appData.playlists.push({id: defaultPlaylistId, name: "Playlist", videos: []});
             appData.currentPlaylistId = defaultPlaylistId;
        }
    }
    initializeDefaultAppData();
    
    function getCurrentPlaylist() {
        if (!appData.currentPlaylistId || !appData.playlists) return appData.playlists[0] || null;
        return appData.playlists.find(p => p.id === appData.currentPlaylistId) || appData.playlists[0] || null;
    }

    function onYouTubeIframeAPIReadyInternal() { // Renamed to avoid conflict with global
        isYouTubeApiReady = true;
        const currentPlaylist = getCurrentPlaylist();
        const currentVideoInPlaylist = currentPlaylist?.videos.find(v => v.id === appData.currentVideo?.id);

        if (pendingVideoToLoad && currentVideoInPlaylist) {
            playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
            pendingVideoToLoad = null;
        } else if (appData.currentVideo && currentVideoInPlaylist && !ytPlayerInstance && appWindow.style.display !== 'none' && !appWindow.classList.contains('minimized')) {
            playYouTubeVideoById(appData.currentVideo.videoId, appData.autoPlayEnabled);
        }
    }
    if (typeof YT === 'undefined' || typeof YT.Player === 'undefined') {
        const tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        const firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReadyInternal;
    } else {
        onYouTubeIframeAPIReadyInternal();
    }


    function extractYouTubeVideoId(url) {
        if (!url) return null;
        const regex = /(?:youtube\.com\/(?:[^\/\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }
    function isValidYouTubeUrl(url) {
        if (!url) return false;
        const regex = /^(https?:\/\/)?(www\.)?(youtube\.com\/(watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})([&?].*)?$/;
        return regex.test(url);
    }

    async function handleInput() {
        const input = DOM.linkInput.value.trim();
        if (!input) { alert("Please enter a YouTube link or search query."); return; }
        if (isValidYouTubeUrl(input)) {
            addYouTubeLinkToPlaylist(input);
        } else {
            if (!YOUTUBE_API_KEY) {
                alert("YouTube API Key not configured. Search is disabled. Add direct links."); return;
            }
            searchYouTubeVideos(input);
        }
    }
    async function searchYouTubeVideos(query) {
        DOM.youtubeSearchResultsBody.innerHTML = '';
        DOM.youtubeSearchStatus.textContent = 'Searching...';
        DOM.youtubeSearchStatus.style.display = 'block';
        os.openModal(DOM.youtubeSearchModal);
        const apiUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&key=${YOUTUBE_API_KEY}&maxResults=10`;
        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                const errorData = await response.json();
                DOM.youtubeSearchStatus.textContent = `Error: ${errorData.error.message}`; return;
            }
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                DOM.youtubeSearchStatus.style.display = 'none';
                renderYouTubeSearchResults(data.items);
            } else {
                DOM.youtubeSearchStatus.textContent = 'No videos found.';
            }
        } catch (error) {
            DOM.youtubeSearchStatus.textContent = 'Failed to search videos.';
        }
    }
    function renderYouTubeSearchResults(items) {
        DOM.youtubeSearchResultsBody.innerHTML = '';
        items.forEach(item => {
            const videoId = item.id.videoId;
            const title = os.decodeHtmlEntities(item.snippet.title);
            const channelTitle = os.decodeHtmlEntities(item.snippet.channelTitle);
            const thumbnailUrl = item.snippet.thumbnails.default.url;
            const resultDiv = document.createElement('div');
            resultDiv.className = 'Youtube-result-item'; // Use a generic class if needed or prefix
            resultDiv.style.cssText = "display: flex; align-items: center; padding: 8px; border-bottom: 1px solid #ACA899; cursor: pointer; background-color: #FFFFFF;";
            resultDiv.innerHTML = `<img src="${thumbnailUrl}" alt="${title}" style="width:120px;height:90px;margin-right:10px;border:1px solid #ACA899;object-fit:cover;"><div style="display:flex;flex-direction:column;"><div style="font-weight:bold;color:#0039A9;font-size:12px;margin-bottom:3px;" title="${title}">${title}</div><div style="font-size:10px;color:#555;" title="${channelTitle}">${channelTitle}</div></div>`;
            resultDiv.addEventListener('click', () => {
                addVideoFromSearchResult(videoId, title, channelTitle);
                os.closeModal(DOM.youtubeSearchModal);
            });
            DOM.youtubeSearchResultsBody.appendChild(resultDiv);
        });
    }
    function addVideoFromSearchResult(videoId, title, artist) {
        let currentPlaylist = getCurrentPlaylist();
        if (!currentPlaylist) { addNewPlaylist(); currentPlaylist = getCurrentPlaylist(); if (!currentPlaylist) return; }
        if (currentPlaylist.videos.some(v => v.videoId === videoId)) { alert("Video already in playlist."); DOM.linkInput.value = ''; return; }
        const videoEntry = {
            id: 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7),
            originalUrl: `https://www.youtube.com/watch?v=${videoId}`, videoId, title,
            artist: artist.replace(/\s-\sTopic$/, '').trim()
        };
        currentPlaylist.videos.push(videoEntry);
        renderPlaylist(); DOM.linkInput.value = '';
        if (!ytPlayerInstance || !appData.currentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true);
        }
        os.saveAppData();
    }
    function addYouTubeLinkToPlaylist(link) {
        const videoId = extractYouTubeVideoId(link);
        if (!videoId) { alert("Invalid YouTube link."); return; }
        let currentPlaylist = getCurrentPlaylist();
        if (!currentPlaylist) { addNewPlaylist(); currentPlaylist = getCurrentPlaylist(); if (!currentPlaylist) return; }
        if (currentPlaylist.videos.some(v => v.videoId === videoId)) { alert("Video already in playlist."); DOM.linkInput.value = ''; return; }
        const tempId = 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7);
        const videoEntry = { id: tempId, originalUrl: link, videoId, title: "Loading title...", artist: "" };
        currentPlaylist.videos.push(videoEntry);
        renderPlaylist(); DOM.linkInput.value = '';
        fetchYouTubeTitle(videoEntry, currentPlaylist.id);
        if (!ytPlayerInstance || !appData.currentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true);
        }
        os.saveAppData();
    }
    async function fetchYouTubeTitle(videoEntry, playlistId) {
        try {
            let newTitle = "Unknown Title", newArtist = "";
            if (YOUTUBE_API_KEY) {
                 const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoEntry.videoId}&key=${YOUTUBE_API_KEY}`);
                 if (response.ok) {
                     const data = await response.json();
                     if (data.items && data.items.length > 0) {
                         newTitle = os.decodeHtmlEntities(data.items[0].snippet.title);
                         newArtist = os.decodeHtmlEntities(data.items[0].snippet.channelTitle).replace(/\s-\sTopic$/, '').trim();
                     } else newTitle = os.decodeHtmlEntities(videoEntry.originalUrl);
                 } else newTitle = os.decodeHtmlEntities(videoEntry.originalUrl);
            } else {
                const oEmbedResponse = await fetch(`https://www.youtube.com/oembed?url=http://www.youtube.com/watch?v=${videoEntry.videoId}&format=json`);
                if (oEmbedResponse.ok) {
                    const data = await oEmbedResponse.json();
                    newTitle = os.decodeHtmlEntities(data.title);
                    newArtist = os.decodeHtmlEntities(data.author_name).replace(/\s-\sTopic$/, '').trim();
                } else newTitle = os.decodeHtmlEntities(videoEntry.originalUrl);
            }
            const targetPlaylist = appData.playlists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const item = targetPlaylist.videos.find(v => v.id === videoEntry.id);
                if (item) {
                    item.title = newTitle; item.artist = newArtist;
                    if (appData.currentPlaylistId === playlistId) renderPlaylist();
                    if(appData.currentVideo && appData.currentVideo.id === item.id) {
                        appData.currentVideo.title = newTitle; appData.currentVideo.artist = newArtist;
                    }
                    os.saveAppData();
                }
            }
        } catch (error) { /* Use original URL as fallback already handled */ }
    }

    function renderTabs() {
        DOM.tabsBar.innerHTML = '';
        appData.playlists.forEach(playlist => {
            const tab = document.createElement('div');
            tab.className = 'playjockey-tab'; // Use a generic class or prefix
            tab.style.cssText = "padding: 6px 10px; border: 1px inset #FFFFFF; border-bottom: none; background-color: #D4D0C8; cursor: default; font-size: 10px; white-space: nowrap; border-top-left-radius: 3px; border-top-right-radius: 3px;";
            const displayName = os.decodeHtmlEntities(playlist.name);
            tab.textContent = displayName; tab.title = displayName; tab.dataset.playlistId = playlist.id;
            if (playlist.id === appData.currentPlaylistId) {
                tab.classList.add('active');
                tab.style.backgroundColor = "#F0F0F0"; tab.style.borderStyle = "inset"; tab.style.borderBottom = "1px solid #F0F0F0"; tab.style.fontWeight = "bold";
            }
            tab.addEventListener('click', () => switchPlaylist(playlist.id));
            tab.addEventListener('contextmenu', (e) => showTabContextMenu(e, playlist.id));
            DOM.tabsBar.appendChild(tab);
        });
        const addTabBtn = document.createElement('button');
        addTabBtn.className = 'xp-button xp-button-small';
        addTabBtn.textContent = '+'; addTabBtn.title = "New Playlist";
        addTabBtn.style.padding = "3px 6px"; addTabBtn.style.fontSize="10px";
        addTabBtn.addEventListener('click', addNewPlaylist);
        DOM.tabsBar.appendChild(addTabBtn);
    }
    function addNewPlaylist() {
        let newName = "Playlist", counter = 1;
        const existing = appData.playlists.map(p => p.name.toLowerCase());
        while (existing.includes(newName.toLowerCase() + (counter > 1 ? ` ${counter-1}`: ''))) counter++;
        if (counter > 1) newName = `${newName} ${counter-1}`;
        const newId = 'playlist_' + Date.now() + '_' + Math.random().toString(36).substring(2,9);
        appData.playlists.push({ id: newId, name: newName, videos: [] });
        switchPlaylist(newId);
    }
    function switchPlaylist(playlistId) {
        if (appData.currentPlaylistId === playlistId) return;
        appData.currentPlaylistId = playlistId;
        appData.currentVideo = null; appData.randomHistory = [];
        if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') ytPlayerInstance.stopVideo();
        renderTabs(); renderPlaylist(); os.saveAppData();
    }
    function renderPlaylist() {
        DOM.playlistArea.innerHTML = '';
        const currentPlaylist = getCurrentPlaylist();
        if (!currentPlaylist || currentPlaylist.videos.length === 0) {
            DOM.playlistArea.innerHTML = `<div style="padding:10px;text-align:center;color:#555;">Playlist empty.</div>`;
            updatePlayingClass(null); return;
        }
        currentPlaylist.videos.forEach(video => {
            const item = document.createElement('div');
            item.className = 'playjockey-playlist-item'; // Generic or prefixed
            item.style.cssText = "padding: 4px 6px; cursor: grab; border-bottom: 1px solid #ECE9D8; font-size: 10px; color: #000080; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; user-select: none;";
            let cleanTitle = os.decodeHtmlEntities(video.title);
            let cleanArtist = os.decodeHtmlEntities(video.artist);
            let displayTitle = (cleanTitle === "Loading title..." || cleanTitle === video.originalUrl || !cleanTitle.trim()) ? (os.decodeHtmlEntities(video.originalUrl).substring(0,37) + '...') : (cleanTitle.substring(0,37) + '...');
            let itemText = displayTitle;
            let itemTooltip = (cleanTitle !== "Loading title..." && cleanTitle.trim()) ? cleanTitle : os.decodeHtmlEntities(video.originalUrl);
            if (cleanArtist && cleanArtist.trim() !== "") {
                itemText = `${displayTitle} - ${(cleanArtist.substring(0,17) + '...')}`;
                itemTooltip = `${itemTooltip} by ${cleanArtist}`;
            }
            item.textContent = itemText; item.title = itemTooltip;
            item.dataset.videoId = video.videoId; item.dataset.playlistItemId = video.id;
            item.draggable = true;
            if (appData.currentVideo && appData.currentVideo.id === video.id) item.classList.add('playing'); // Style with .playing
            item.addEventListener('click', (e) => {
                if (e.target.closest('.context-modal') || item.classList.contains('dragging')) return;
                if (e.currentTarget.dataset.videoId) playYouTubeVideoById(e.currentTarget.dataset.videoId, true, true);
            });
            DOM.playlistArea.appendChild(item);
        });
    }
    function playYouTubeVideoById(videoId, autoplay = true, manualPlay = false) {
        if (!videoId) return;
        const currentPlaylist = getCurrentPlaylist();
        if (!currentPlaylist) return;
        const videoToPlay = currentPlaylist.videos.find(v => v.videoId === videoId);
        if (!videoToPlay) { appData.currentVideo = null; updatePlayingClass(null); if(ytPlayerInstance) ytPlayerInstance.stopVideo(); return; }
        if (manualPlay && videoToPlay && appData.randomEnabled && appData.autoPlayEnabled && appData.repeatState === "off" && currentPlaylist.videos.length > 0) {
            const uniqueIds = new Set(currentPlaylist.videos.map(v => v.id));
            if (new Set(appData.randomHistory).size >= uniqueIds.size) appData.randomHistory = [videoToPlay.id];
            else if (!appData.randomHistory.includes(videoToPlay.id)) appData.randomHistory.push(videoToPlay.id);
        }
        appData.currentVideo = { ...videoToPlay };
        updatePlayingClass(videoToPlay.id); os.saveAppData();
        if (!isYouTubeApiReady) { pendingVideoToLoad = { videoId, autoplayIntent: autoplay }; return; }
        if (ytPlayerInstance && typeof ytPlayerInstance.loadVideoById === 'function') {
            ytPlayerInstance.loadVideoById({ videoId });
            if (autoplay) ytPlayerInstance.playVideo();
        } else {
            if (DOM.playerContainer.firstChild && DOM.playerContainer.firstChild.tagName === 'IFRAME') DOM.playerContainer.innerHTML = '';
            ytPlayerInstance = new YT.Player(DOM.playerContainer.id, {
                height: '100%', width: '100%', videoId,
                playerVars: { autoplay: autoplay ? 1:0, controls:1, enablejsapi:1, origin:window.location.origin, modestbranding:1, rel:0 },
                events: { 'onReady': (e) => { if (autoplay) e.target.playVideo(); }, 'onStateChange': onPlayerStateChange }
            });
        }
    }
    function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.ENDED && appData.autoPlayEnabled) playNextVideo();
    }
    function playNextVideo() {
        const currentPlaylist = getCurrentPlaylist();
        if (!ytPlayerInstance || !appData.currentVideo || !currentPlaylist || currentPlaylist.videos.length === 0) return;
        let nextVideo = null;
        const currentId = appData.currentVideo.id;
        const videos = currentPlaylist.videos;
        if (appData.repeatState === "song") nextVideo = videos.find(v => v.id === currentId);
        else if (appData.randomEnabled) {
            if (videos.length === 0) return;
            if (videos.length === 1) {
                if (appData.repeatState === "off" && appData.randomHistory.includes(currentId)) return;
                nextVideo = videos[0];
            } else {
                let eligible = videos.filter(v => !appData.randomHistory.includes(v.id) || v.id === currentId);
                if (eligible.length === 1 && eligible[0].id === currentId && appData.repeatState !== "song") {
                     eligible = videos.filter(v => v.id !== currentId);
                     if (eligible.length === 0 && appData.repeatState === "playlist") {
                        appData.randomHistory = [currentId]; eligible = videos.filter(v => v.id !== currentId);
                     }
                } else if (eligible.length === 0 && appData.repeatState === "playlist") {
                    appData.randomHistory = [currentId]; eligible = videos.filter(v => v.id !== currentId);
                }
                if (eligible.length === 0) {
                    if (appData.repeatState === "playlist") { appData.randomHistory = []; eligible = [...videos]; if(videos.length === 1) nextVideo = videos[0];}
                    else { appData.randomHistory = []; return; }
                }
                if (eligible.length > 0 && !nextVideo) nextVideo = eligible[Math.floor(Math.random() * eligible.length)];
            }
            if (nextVideo && !appData.randomHistory.includes(nextVideo.id)) appData.randomHistory.push(nextVideo.id);
            if (appData.repeatState === "playlist") {
                const maxHist = Math.max(0, videos.length -1);
                while (appData.randomHistory.length > maxHist && maxHist > 0 && appData.randomHistory.length >= videos.length) appData.randomHistory.shift();
            }
        } else {
            const currentIndex = videos.findIndex(v => v.id === currentId);
            if (currentIndex === -1) return;
            let nextIndex = currentIndex + 1;
            if (nextIndex >= videos.length) {
                if (appData.repeatState === "playlist") nextIndex = 0; else return;
            }
            if (videos[nextIndex]) nextVideo = videos[nextIndex];
        }
        if (nextVideo && nextVideo.videoId) playYouTubeVideoById(nextVideo.videoId, true, false);
    }
    function updatePlayingClass(playingItemId) {
        DOM.playlistArea.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.toggle('playing', item.dataset.playlistItemId === playingItemId);
            if (item.dataset.playlistItemId === playingItemId) item.style.backgroundColor = "#005CFE"; else item.style.backgroundColor = "";
        });
    }

    function showContextMenu(e, menuElement, targetSelector, idDatasetName) {
        e.preventDefault();
        hideAllContextMenus();
        const target = e.target.closest(targetSelector);
        if (target) {
            menuElement.style.display = 'block';
            let x = e.clientX, y = e.clientY;
            const menuWidth = menuElement.offsetWidth, menuHeight = menuElement.offsetHeight;
            const vpWidth = window.innerWidth, vpHeight = window.innerHeight;
            if (x + menuWidth > vpWidth) x = vpWidth - menuWidth - 5;
            if (y + menuHeight > vpHeight) y = vpHeight - menuHeight - 5;
            menuElement.style.left = `${Math.max(0,x)}px`; menuElement.style.top = `${Math.max(0,y)}px`;
            menuElement.dataset[idDatasetName] = target.dataset[idDatasetName] || target.dataset.playlistId;
        }
    }
    function hideAllContextMenus() {
        DOM.contextMenu.style.display = 'none'; delete DOM.contextMenu.dataset.currentItemId;
        DOM.tabContextMenu.style.display = 'none'; delete DOM.tabContextMenu.dataset.playlistId;
    }
    DOM.playlistArea.addEventListener('contextmenu', (e) => showContextMenu(e, DOM.contextMenu, '.playjockey-playlist-item', 'playlistItemId'));
    function showTabContextMenu(e, playlistId) { // Special handling for tabs as they are dynamically generated
        e.preventDefault();
        hideAllContextMenus();
        DOM.tabContextMenu.style.display = 'block';
        let x = e.clientX, y = e.clientY;
        const menuWidth = DOM.tabContextMenu.offsetWidth, menuHeight = DOM.tabContextMenu.offsetHeight;
        const vpWidth = window.innerWidth, vpHeight = window.innerHeight;
        if (x + menuWidth > vpWidth) x = vpWidth - menuWidth - 5;
        if (y + menuHeight > vpHeight) y = vpHeight - menuHeight - 5;
        DOM.tabContextMenu.style.left = `${Math.max(0,x)}px`; DOM.tabContextMenu.style.top = `${Math.max(0,y)}px`;
        DOM.tabContextMenu.dataset.playlistId = playlistId;
    }

    DOM.contextRenameBtn.addEventListener('click', () => {
        const itemId = DOM.contextMenu.dataset.currentItemId;
        const currentPlaylist = getCurrentPlaylist();
        if (!itemId || !currentPlaylist) { hideAllContextMenus(); return; }
        const item = currentPlaylist.videos.find(v => v.id === itemId);
        if (item) {
            DOM.trackNewNameInput.value = os.decodeHtmlEntities(item.title) || '';
            DOM.trackNewArtistInput.value = os.decodeHtmlEntities(item.artist) || '';
            DOM.saveRenamedTrackBtn.dataset.itemId = itemId;
            os.openModal(DOM.renameTrackModal); DOM.trackNewNameInput.focus();
        }
        hideAllContextMenus();
    });
    DOM.contextRemoveBtn.addEventListener('click', () => {
        const itemId = DOM.contextMenu.dataset.currentItemId;
        const currentPlaylist = getCurrentPlaylist();
        if (!itemId || !currentPlaylist) { hideAllContextMenus(); return; }
        const item = currentPlaylist.videos.find(v => v.id === itemId);
        if (item) {
            DOM.confirmRemoveTrackMessage.textContent = `Remove track "${os.decodeHtmlEntities(item.title)}"?`;
            DOM.confirmFinalTrackRemoveBtn.dataset.itemId = itemId;
            os.openModal(DOM.confirmRemoveTrackModal);
        }
        hideAllContextMenus();
    });
    DOM.saveRenamedTrackBtn.addEventListener('click', () => {
        const itemId = DOM.saveRenamedTrackBtn.dataset.itemId;
        const newName = DOM.trackNewNameInput.value.trim();
        const newArtist = DOM.trackNewArtistInput.value.trim();
        const currentPlaylist = getCurrentPlaylist();
        if (!itemId || !currentPlaylist || !newName) { alert("Error or empty name."); os.closeModal(DOM.renameTrackModal); return; }
        const item = currentPlaylist.videos.find(v => v.id === itemId);
        if (item) {
            item.title = newName; item.artist = newArtist;
            if(appData.currentVideo && appData.currentVideo.id === itemId) { appData.currentVideo.title = newName; appData.currentVideo.artist = newArtist; }
            renderPlaylist(); os.saveAppData();
        }
        os.closeModal(DOM.renameTrackModal); delete DOM.saveRenamedTrackBtn.dataset.itemId;
    });
    DOM.confirmFinalTrackRemoveBtn.addEventListener('click', () => {
        const itemId = DOM.confirmFinalTrackRemoveBtn.dataset.itemId;
        const currentPlaylist = getCurrentPlaylist();
        if (!itemId || !currentPlaylist) { os.closeModal(DOM.confirmRemoveTrackModal); return; }
        const itemIndex = currentPlaylist.videos.findIndex(v => v.id === itemId);
        if (itemIndex > -1) {
            const removed = currentPlaylist.videos.splice(itemIndex, 1)[0];
            const histIndex = appData.randomHistory.indexOf(removed.id);
            if (histIndex > -1) appData.randomHistory.splice(histIndex, 1);
            if (appData.currentVideo && appData.currentVideo.id === removed.id) {
                if (ytPlayerInstance) ytPlayerInstance.stopVideo();
                appData.currentVideo = null;
                if (appData.autoPlayEnabled && currentPlaylist.videos.length > 0) playNextVideo();
                else if (currentPlaylist.videos.length === 0) DOM.playerContainer.innerHTML = '';
            }
            renderPlaylist(); os.saveAppData();
        }
        os.closeModal(DOM.confirmRemoveTrackModal); delete DOM.confirmFinalTrackRemoveBtn.dataset.itemId;
    });

    DOM.tabContextRenameBtn.addEventListener('click', () => {
        const playlistId = DOM.tabContextMenu.dataset.playlistId;
        if (!playlistId) return;
        const playlist = appData.playlists.find(pl => pl.id === playlistId);
        if (playlist) {
            DOM.playlistNewNameInput.value = os.decodeHtmlEntities(playlist.name);
            DOM.saveRenamedPlaylistBtn.dataset.playlistId = playlistId;
            os.openModal(DOM.renamePlaylistModal); DOM.playlistNewNameInput.focus();
        }
        hideAllContextMenus();
    });
    DOM.saveRenamedPlaylistBtn.addEventListener('click', () => {
        const playlistId = DOM.saveRenamedPlaylistBtn.dataset.playlistId;
        const newName = DOM.playlistNewNameInput.value.trim();
        if (!playlistId || !newName) { alert("Error or empty name."); os.closeModal(DOM.renamePlaylistModal); return; }
        const playlist = appData.playlists.find(pl => pl.id === playlistId);
        if (playlist) { playlist.name = newName; renderTabs(); os.saveAppData(); }
        os.closeModal(DOM.renamePlaylistModal); delete DOM.saveRenamedPlaylistBtn.dataset.playlistId;
    });
    DOM.tabContextRemoveBtn.addEventListener('click', () => {
        const playlistId = DOM.tabContextMenu.dataset.playlistId;
        if (!playlistId) return;
        const playlist = appData.playlists.find(pl => pl.id === playlistId);
        if (playlist) {
            DOM.confirmRemovePlaylistMessage.textContent = `Remove playlist "${os.decodeHtmlEntities(playlist.name)}"?`;
            DOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId = playlistId;
            os.openModal(DOM.confirmRemovePlaylistModal);
        }
        hideAllContextMenus();
    });
    DOM.confirmFinalPlaylistRemoveBtn.addEventListener('click', () => {
        const playlistId = DOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId;
        if (!playlistId) { os.closeModal(DOM.confirmRemovePlaylistModal); return; }
        const index = appData.playlists.findIndex(pl => pl.id === playlistId);
        if (index > -1) {
            appData.playlists.splice(index, 1);
            if (appData.currentPlaylistId === playlistId) {
                if (ytPlayerInstance) ytPlayerInstance.stopVideo();
                appData.currentVideo = null; appData.randomHistory = [];
                if (appData.playlists.length > 0) appData.currentPlaylistId = appData.playlists[0].id;
                else { const newDefId = 'playlist_default_0'; appData.playlists.push({id:newDefId, name:"Playlist", videos:[]}); appData.currentPlaylistId = newDefId; }
            }
        }
        if (appData.playlists.length === 0) { const newDefId = 'playlist_default_0'; appData.playlists.push({id:newDefId, name:"Playlist", videos:[]}); appData.currentPlaylistId = newDefId; }
        renderTabs(); renderPlaylist(); os.saveAppData();
        os.closeModal(DOM.confirmRemovePlaylistModal); delete DOM.confirmFinalPlaylistRemoveBtn.dataset.playlistId;
    });
    
    DOM.playlistArea.addEventListener('dragstart', (e) => {
        const target = e.target.closest('.playjockey-playlist-item');
        if (target) {
            pjDraggedItem = target; e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', target.dataset.playlistItemId);
            setTimeout(() => target.classList.add('dragging'), 0); // Style with .dragging
            hideAllContextMenus();
        }
    });
    DOM.playlistArea.addEventListener('dragend', () => {
        if (pjDraggedItem) pjDraggedItem.classList.remove('dragging');
        DOM.playlistArea.querySelectorAll('.playjockey-playlist-item').forEach(i => i.classList.remove('drag-over-target-before', 'drag-over-target-after'));
        pjDraggedItem = null;
    });
    DOM.playlistArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        const target = e.target.closest('.playjockey-playlist-item');
        DOM.playlistArea.querySelectorAll('.playjockey-playlist-item').forEach(i => i.classList.remove('drag-over-target-before', 'drag-over-target-after'));
        if (target && pjDraggedItem && target !== pjDraggedItem) {
            const rect = target.getBoundingClientRect();
            target.classList.add(e.clientY < rect.top + rect.height / 2 ? 'drag-over-target-before' : 'drag-over-target-after');
        }
    });
    DOM.playlistArea.addEventListener('dragleave', (e) => {
        if (!DOM.playlistArea.contains(e.relatedTarget)) {
             DOM.playlistArea.querySelectorAll('.playjockey-playlist-item').forEach(i => i.classList.remove('drag-over-target-before', 'drag-over-target-after'));
        } else {
            const target = e.target.closest('.playjockey-playlist-item');
            if(target) target.classList.remove('drag-over-target-before', 'drag-over-target-after');
        }
    });
    DOM.playlistArea.addEventListener('drop', (e) => {
        e.preventDefault();
        DOM.playlistArea.querySelectorAll('.playjockey-playlist-item').forEach(i => i.classList.remove('drag-over-target-before', 'drag-over-target-after'));
        const currentPlaylist = getCurrentPlaylist();
        if (!pjDraggedItem || !currentPlaylist) return;
        const draggedId = e.dataTransfer.getData('text/plain');
        const targetEl = e.target.closest('.playjockey-playlist-item');
        const draggedIndex = currentPlaylist.videos.findIndex(v => v.id === draggedId);
        if (draggedIndex === -1) return;
        const itemToMove = currentPlaylist.videos.splice(draggedIndex, 1)[0];
        let targetIndex = -1;
        if (targetEl && targetEl.dataset.playlistItemId !== draggedId) {
            targetIndex = currentPlaylist.videos.findIndex(v => v.id === targetEl.dataset.playlistItemId);
            if (targetIndex !== -1) {
                const rect = targetEl.getBoundingClientRect();
                if (e.clientY >= rect.top + rect.height / 2) targetIndex++;
            }
        }
        if (targetIndex !== -1 && targetIndex <= currentPlaylist.videos.length) currentPlaylist.videos.splice(targetIndex, 0, itemToMove);
        else currentPlaylist.videos.push(itemToMove);
        renderPlaylist(); os.saveAppData(); pjDraggedItem = null;
    });

    DOM.addBtn.addEventListener('click', handleInput);
    DOM.linkInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleInput(); });
    DOM.randomBtn.addEventListener('click', () => { appData.randomEnabled = !appData.randomEnabled; appData.randomHistory = []; if(appData.randomEnabled && appData.currentVideo && getCurrentPlaylist()?.videos.length > 0) appData.randomHistory.push(appData.currentVideo.id); updateControlButtons(); os.saveAppData(); });
    DOM.autoPlayBtn.addEventListener('click', () => { appData.autoPlayEnabled = !appData.autoPlayEnabled; updateControlButtons(); os.saveAppData(); });
    DOM.repeatBtn.addEventListener('click', () => { const states = ["off", "playlist", "song"]; appData.repeatState = states[(states.indexOf(appData.repeatState) + 1) % states.length]; appData.randomHistory = []; if(appData.randomEnabled && appData.currentVideo && getCurrentPlaylist()?.videos.length > 0) appData.randomHistory.push(appData.currentVideo.id); updateControlButtons(); os.saveAppData(); });
    
    appWindow.querySelectorAll('.modal .close-button, .modal .xp-button[data-modal-id]').forEach(button => {
        button.addEventListener('click', (event) => {
            const modalId = event.target.dataset.modalId || event.target.closest('.modal').id;
            if (modalId) os.closeModal(appWindow.querySelector('#'+modalId));
        });
    });
    document.addEventListener('click', (e) => { // Global click to hide context menus
        if (DOM.contextMenu.style.display === 'block' && !DOM.contextMenu.contains(e.target) && !e.target.closest('.playjockey-playlist-item')) hideAllContextMenus();
        if (DOM.tabContextMenu.style.display === 'block' && !DOM.tabContextMenu.contains(e.target) && !e.target.closest('.playjockey-tab')) hideAllContextMenus();
    });


    function updateControlButtons() {
        DOM.randomBtn.classList.toggle('random-on', appData.randomEnabled); // Style with .random-on
        DOM.randomBtn.textContent = `Random: ${appData.randomEnabled ? 'On' : 'Off'}`;
        DOM.autoPlayBtn.classList.toggle('autoplay-on', appData.autoPlayEnabled); // Style with .autoplay-on
        DOM.autoPlayBtn.textContent = `Auto Play: ${appData.autoPlayEnabled ? 'On' : 'Off'}`;
        DOM.repeatBtn.classList.remove('repeat-on'); // Style with .repeat-on
        switch (appData.repeatState) {
            case "off": DOM.repeatBtn.textContent = 'Repeat: Off'; break;
            case "playlist": DOM.repeatBtn.textContent = 'Repeat: List'; DOM.repeatBtn.classList.add('repeat-on'); break;
            case "song": DOM.repeatBtn.textContent = 'Repeat: One'; DOM.repeatBtn.classList.add('repeat-on'); break;
        }
    }
    
    this.onOpen = (win) => {
        YOUTUBE_API_KEY = os.getGlobalConfig('YOUTUBE_API_KEY'); // Refresh API key on open
        renderTabs();
        renderPlaylist();
        updateControlButtons();
        if (appData.currentVideo && !ytPlayerInstance && isYouTubeApiReady) {
             const currentPlaylist = getCurrentPlaylist();
             const currentVideoInPlaylist = currentPlaylist?.videos.find(v => v.id === appData.currentVideo.id);
             if (currentVideoInPlaylist) playYouTubeVideoById(appData.currentVideo.videoId, false); // Don't autoplay on reopen unless intended
        } else if (pendingVideoToLoad && isYouTubeApiReady) {
            playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
            pendingVideoToLoad = null;
        }
    };
    this.onClose = (win) => {
        if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
            ytPlayerInstance.stopVideo();
        }
    };
    this.onMinimize = (win) => {
         if (ytPlayerInstance && typeof ytPlayerInstance.pauseVideo === 'function') {
            ytPlayerInstance.pauseVideo();
        }
    };
     this.onRestore = (win) => {
        if (ytPlayerInstance && typeof ytPlayerInstance.playVideo === 'function' && appData.currentVideo && appData.autoPlayEnabled) {
            // Only play if it was likely playing before minimize. This might need more state.
            // For now, let's not auto-play on restore unless specifically desired.
        }
    };

    renderTabs();
    renderPlaylist();
    updateControlButtons();

    </script>
</body>
