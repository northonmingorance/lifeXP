<style>
    body { margin: 0; padding: 0; font-family: "Tahoma", "Geneva", sans-serif; font-size: 11px; display: flex; flex-direction: column; height: 100vh; overflow: hidden; background-color: #D4D0C8;}
    .xp-button { background-color: #ECE9D8; border: 1px outset #7F7F7F; padding: 5px 12px; min-width: 75px; text-align: center; cursor: pointer; margin: 2px; }
    .xp-button:active { border-style: inset; }
    .xp-button:hover { border-color: #005CFE; }
    .xp-button-small { padding: 2px 5px; font-size: 10px; min-width: auto; margin: 0 2px;}

    .playjockey-body-container { display: flex; flex-direction: column; width: 100%; height: 100%; background-color: #D4D0C8; padding: 5px; box-sizing: border-box; }
    .playjockey-input-bar { display: flex; margin-bottom: 5px; padding: 5px; background-color: #C0C0C0; border: 1px outset #FFFFFF; border-right-color: #808080; border-bottom-color: #808080; flex-shrink: 0; }
    #playJockeyLinkInput { flex-grow: 1; margin-right: 5px; border: 1px inset #7F7F7F; padding: 4px; font-family: "Tahoma", "Geneva", sans-serif; font-size: 11px; background-color: #FFFFFF; }
    #playJockeyAddBtn { min-width: 60px; padding: 3px 8px; font-size: 11px; }
    .playjockey-player-area { flex-grow: 1; margin-bottom: 5px; border: 2px inset #808080; background-color: black; min-height: 150px; overflow: hidden; }
    #playJockeyPlayer { width: 100%; height: 100%; }
    .playjockey-tabs-bar { display: flex; flex-wrap: nowrap; overflow-x: auto; background-color: #C0C0C0; padding: 3px 3px 0 3px; border-bottom: 1px solid #808080; flex-shrink: 0; gap: 2px; }
    .playjockey-tab { padding: 6px 10px; border: 1px inset #FFFFFF; border-bottom: none; background-color: #D4D0C8; cursor: default; font-size: 10px; white-space: nowrap; border-top-left-radius: 3px; border-top-right-radius: 3px; }
    .playjockey-tab:hover { background-color: #E0E0E0; }
    .playjockey-tab.active { background-color: #F0F0F0; border-style: inset; border-bottom: 1px solid #F0F0F0; position: relative; z-index: 1; font-weight: bold; }
    .playjockey-add-tab-btn { padding: 6px 8px; margin-left: 0px; font-weight: bold; }
    .playjockey-controls-bar { display: flex; justify-content: center; padding: 5px 0px 5px 0px; flex-shrink: 0; gap: 5px; border-top: 1px solid #ACA899; background-color: #F0F0F0; }
    #playJockeyRandomBtn, #playJockeyAutoPlayBtn, #playJockeyRepeatBtn { min-width: 90px; padding: 3px 8px; font-size: 11px; }
    #playJockeyRandomBtn.random-on, #playJockeyAutoPlayBtn.autoplay-on, #playJockeyRepeatBtn.repeat-on { border-style: inset; font-weight: bold; }
    .playjockey-playlist-area { height: 100px; overflow-y: auto; border: 1px inset #7F7F7F; background-color: #FFFFFF; padding: 3px; flex-shrink: 0; border-top: none; position: relative; z-index: 0; }
    .playjockey-playlist-item { padding: 4px 6px; cursor: grab; border-bottom: 1px solid #ECE9D8; font-size: 10px; color: #000080; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; user-select: none; }
    .playjockey-playlist-item:hover { background-color: #000080; color: white; }
    .playjockey-playlist-item.playing { background-color: #005CFE; color: white; font-weight: bold; }
    .playjockey-playlist-item:last-child { border-bottom: none; }
    .playjockey-playlist-item.dragging { opacity: 0.5; background-color: #AED6F1; }
    .playjockey-playlist-item.drag-over-target-before { border-top: 2px dashed #005CFE; }
    .playjockey-playlist-item.drag-over-target-after { border-bottom: 2px dashed #005CFE; }
    /* Styles for context menus and modals if they were to be app-specific */
</style>

<div class="playjockey-body-container">
    <div class="playjockey-input-bar">
        <input type="text" id="playJockeyLinkInput" placeholder="Paste YouTube Link or Search Query">
        <button id="playJockeyAddBtn" class="xp-button">Add</button>
    </div>
    <div class="playjockey-player-area">
        <div id="playJockeyPlayer"></div>
    </div>
    <div class="playjockey-tabs-bar" id="playJockeyTabsBar"></div>
    <div class="playjockey-playlist-area" id="playJockeyPlaylist"></div>
    <div class="playjockey-controls-bar">
        <button id="playJockeyRandomBtn" class="xp-button">Random: Off</button>
        <button id="playJockeyAutoPlayBtn" class="xp-button">Auto Play: On</button>
        <button id="playJockeyRepeatBtn" class="xp-button">Repeat: Off</button>
    </div>
</div>
<script src="https://www.youtube.com/iframe_api"></script>
<script>
    const PJ_STORAGE_KEY = 'playJockeyAppData_v1.0.1'; // Incremented version
    let YOUTUBE_API_KEY = ""; 

    let pjData = {
        playlists: [],
        currentPlaylistId: null,
        currentVideo: null, 
        autoPlayEnabled: true,
        randomEnabled: false,
        repeatState: "off", 
        randomHistory: []
    };

    const DOM_PJ = {
        linkInput: document.getElementById('playJockeyLinkInput'),
        addBtn: document.getElementById('playJockeyAddBtn'),
        playerContainer: document.getElementById('playJockeyPlayer'),
        tabsBar: document.getElementById('playJockeyTabsBar'),
        playlistArea: document.getElementById('playJockeyPlaylist'),
        randomBtn: document.getElementById('playJockeyRandomBtn'),
        autoPlayBtn: document.getElementById('playJockeyAutoPlayBtn'),
        repeatBtn: document.getElementById('playJockeyRepeatBtn')
    };

    let ytPlayerInstance = null;
    let isYouTubeApiReady = false;
    let pendingVideoToLoad = null;
    let pjDraggedItem = null;
    
    function decodeHtmlEntitiesPJ(text) {
        if (typeof text !== 'string') return text;
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }

    function loadPjData() {
        const stored = localStorage.getItem(PJ_STORAGE_KEY);
        const defaultPlaylistId = 'playlist_default_0';
        if (stored) {
            try {
                pjData = JSON.parse(stored);
                pjData.playlists = pjData.playlists || [{id: defaultPlaylistId, name: "Playlist", videos: []}];
                if (pjData.playlists.length === 0) {
                     pjData.playlists = [{id: defaultPlaylistId, name: "Playlist", videos: []}];
                }
                pjData.currentPlaylistId = pjData.currentPlaylistId || pjData.playlists[0]?.id || defaultPlaylistId;
                if (!pjData.playlists.find(p => p.id === pjData.currentPlaylistId)) {
                    pjData.currentPlaylistId = pjData.playlists[0]?.id || defaultPlaylistId;
                }

                pjData.autoPlayEnabled = typeof pjData.autoPlayEnabled === 'boolean' ? pjData.autoPlayEnabled : true;
                pjData.randomEnabled = typeof pjData.randomEnabled === 'boolean' ? pjData.randomEnabled : false;
                pjData.repeatState = ["off", "playlist", "song"].includes(pjData.repeatState) ? pjData.repeatState : "off";
                pjData.randomHistory = Array.isArray(pjData.randomHistory) ? pjData.randomHistory : [];
                pjData.currentVideo = pjData.currentVideo || null;

            } catch (e) {
                console.error("Error loading Play Jockey data, resetting.", e);
                resetPjData();
            }
        } else {
            resetPjData();
        }
    }
    
    function resetPjData() {
        const defaultPlaylistId = 'playlist_default_0_' + Date.now();
        pjData = {
            playlists: [{id: defaultPlaylistId, name: "Playlist", videos: []}],
            currentPlaylistId: defaultPlaylistId,
            currentVideo: null, autoPlayEnabled: true, randomEnabled: false,
            repeatState: "off", randomHistory: []
        };
    }

    function savePjData() {
        localStorage.setItem(PJ_STORAGE_KEY, JSON.stringify(pjData));
    }

    function getCurrentPjPlaylist() {
        if (!pjData.currentPlaylistId || !pjData.playlists) {
            if (pjData.playlists && pjData.playlists.length > 0) {
                pjData.currentPlaylistId = pjData.playlists[0].id;
            } else {
                return null;
            }
        }
        return pjData.playlists.find(p => p.id === pjData.currentPlaylistId);
    }
    
    // This function is called by the YouTube IFrame API script
    function onYouTubeIframeAPIReady() {
        isYouTubeApiReady = true;
        console.log("Play Jockey: YouTube API Ready.");
        const currentPlaylist = getCurrentPjPlaylist();
        const currentVideoInPlaylist = currentPlaylist?.videos.find(v => v.id === pjData.currentVideo?.id);

        if (pendingVideoToLoad && currentVideoInPlaylist) {
            playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
            pendingVideoToLoad = null;
        } else if (pjData.currentVideo && currentVideoInPlaylist && !ytPlayerInstance) {
            playYouTubeVideoById(pjData.currentVideo.videoId, pjData.autoPlayEnabled);
        }
    }

    function extractYouTubeVideoId(url) { 
        if (!url) return null;
        const regex = /(?:youtube\.com\/(?:[^\/\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }
    function isValidYouTubeUrl(url) { 
         if (!url) return false;
        const regex = /^(https?:\/\/)?(www\.)?(youtube\.com\/(watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})([&?].*)?$/;
        return regex.test(url);
    }

    async function handlePjInput() {
        const input = DOM_PJ.linkInput.value.trim();
        if (!input) { alert("Please enter a YouTube link or search query."); return; }

        if (isValidYouTubeUrl(input)) {
            addYouTubeLinkToPj(input);
        } else {
            if (!YOUTUBE_API_KEY) {
                 alert("YouTube API Key is not available for video search. Please add direct YouTube video links.");
                 return;
            }
            searchYouTubeVideos(input);
        }
    }
    
    async function searchYouTubeVideos(query) {
        // This would typically open a modal in the parent OS to show results.
        // For now, we'll simulate a direct add of the first result if API key is present.
        // A proper implementation requires inter-iframe communication for the modal.
        console.log(`Play Jockey: Searching YouTube for "${query}" (requires OS modal for results).`);
        if (!YOUTUBE_API_KEY) {
            alert("Search requires a YouTube API key.");
            return;
        }
        const maxResults = 5; // Fetch a few results
        const apiUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&key=${YOUTUBE_API_KEY}&maxResults=${maxResults}`;
        try {
            const response = await fetch(apiUrl);
            if (!response.ok) throw new Error(`YouTube API Error: ${response.statusText}`);
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                // For simplicity, let's say we'd ask the user to pick via a modal.
                // Here, we'll just take the first one as an example.
                const firstResult = data.items[0];
                addVideoFromSearchResult(firstResult.id.videoId, decodeHtmlEntitiesPJ(firstResult.snippet.title), decodeHtmlEntitiesPJ(firstResult.snippet.channelTitle));
            } else {
                alert("No videos found for your search query.");
            }
        } catch (error) {
            console.error('Error searching YouTube videos:', error);
            alert(`Failed to search videos: ${error.message}`);
        }
    }

    function addVideoFromSearchResult(videoId, title, artist) {
        let currentPlaylist = getCurrentPjPlaylist();
        if (!currentPlaylist) {
            addNewPjPlaylist();
            currentPlaylist = getCurrentPjPlaylist();
            if (!currentPlaylist) { alert("Error: Could not create playlist."); return; }
        }
        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            return;
        }
        const videoEntry = {
            id: 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7),
            originalUrl: `https://www.youtube.com/watch?v=${videoId}`,
            videoId: videoId,
            title: title,
            artist: artist.replace(/\s-\sTopic$/, '').trim()
        };
        currentPlaylist.videos.push(videoEntry);
        renderPjPlaylist();
        if (!ytPlayerInstance || !pjData.currentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true);
        }
        savePjData();
    }


    function addYouTubeLinkToPj(link) {
        const videoId = extractYouTubeVideoId(link);
        if (!videoId) { alert("Invalid YouTube link."); return; }

        let currentPlaylist = getCurrentPjPlaylist();
        if (!currentPlaylist) {
            addNewPjPlaylist(); 
            currentPlaylist = getCurrentPjPlaylist();
            if (!currentPlaylist) { alert("Error: Could not create playlist."); return; }
        }

        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            DOM_PJ.linkInput.value = '';
            return;
        }
        const tempId = 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7);
        const videoEntry = {
            id: tempId, originalUrl: link, videoId: videoId,
            title: "Loading title...", artist: ""
        };
        currentPlaylist.videos.push(videoEntry);
        renderPjPlaylist();
        DOM_PJ.linkInput.value = '';
        fetchYouTubeTitle(videoEntry, currentPlaylist.id);

        if (!ytPlayerInstance || !pjData.currentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true);
        }
        savePjData();
    }

    async function fetchYouTubeTitle(videoEntryToUpdate, playlistId) { 
        try {
            let newTitle = "Unknown Title";
            let newArtist = "";
            if (YOUTUBE_API_KEY) {
                 const apiUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoEntryToUpdate.videoId}&key=${YOUTUBE_API_KEY}`;
                 const response = await fetch(apiUrl);
                 if (response.ok) {
                     const data = await response.json();
                     if (data.items && data.items.length > 0) {
                         newTitle = decodeHtmlEntitiesPJ(data.items[0].snippet.title);
                         newArtist = decodeHtmlEntitiesPJ(data.items[0].snippet.channelTitle).replace(/\s-\sTopic$/, '').trim();
                     } else {
                         newTitle = decodeHtmlEntitiesPJ(videoEntryToUpdate.originalUrl); 
                     }
                 } else {
                     newTitle = decodeHtmlEntitiesPJ(videoEntryToUpdate.originalUrl); 
                 }
            } else { 
                // Fallback if no API key - title will remain "Loading title..." or original URL
                console.warn("Play Jockey: YouTube API Key not available to fetch title for " + videoEntryToUpdate.videoId);
                newTitle = decodeHtmlEntitiesPJ(videoEntryToUpdate.originalUrl);
            }

            const targetPlaylist = pjData.playlists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const itemInPlaylist = targetPlaylist.videos.find(item => item.id === videoEntryToUpdate.id);
                if (itemInPlaylist) {
                    itemInPlaylist.title = newTitle;
                    itemInPlaylist.artist = newArtist;
                    if (pjData.currentPlaylistId === playlistId) {
                        renderPjPlaylist(); 
                    }
                    if(pjData.currentVideo && pjData.currentVideo.id === itemInPlaylist.id) {
                        pjData.currentVideo.title = newTitle;
                        pjData.currentVideo.artist = newArtist;
                    }
                    savePjData();
                }
            }
        } catch (error) {
            console.error(`Error in fetchYouTubeTitle for ${videoEntryToUpdate.videoId}:`, error);
             const targetPlaylist = pjData.playlists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const itemInPlaylist = targetPlaylist.videos.find(item => item.id === videoEntryToUpdate.id);
                if (itemInPlaylist && (itemInPlaylist.title === "Loading title..." || !itemInPlaylist.title.trim())) {
                    itemInPlaylist.title = decodeHtmlEntitiesPJ(itemInPlaylist.originalUrl); 
                    if (pjData.currentPlaylistId === playlistId) renderPjPlaylist();
                    savePjData();
                }
            }
        }
    }


    function renderPjTabs() { 
        DOM_PJ.tabsBar.innerHTML = '';
        pjData.playlists.forEach(playlist => {
            const tab = document.createElement('div');
            tab.className = 'playjockey-tab';
            const displayName = decodeHtmlEntitiesPJ(playlist.name);
            tab.textContent = displayName;
            tab.title = displayName;
            tab.dataset.playlistId = playlist.id;
            if (playlist.id === pjData.currentPlaylistId) {
                tab.classList.add('active');
            }
            tab.addEventListener('click', () => switchPjPlaylist(playlist.id));
            DOM_PJ.tabsBar.appendChild(tab);
        });

        const addTabBtn = document.createElement('button');
        addTabBtn.className = 'playjockey-tab playjockey-add-tab-btn xp-button xp-button-small';
        addTabBtn.textContent = '+';
        addTabBtn.title = "New Playlist";
        addTabBtn.addEventListener('click', addNewPjPlaylist);
        DOM_PJ.tabsBar.appendChild(addTabBtn);
    }
    function addNewPjPlaylist() { 
        let newPlaylistName = "Playlist";
        let counter = 1;
        const existingNames = pjData.playlists.map(p => p.name.toLowerCase());
        let potentialName = newPlaylistName.toLowerCase();
        while (existingNames.includes(potentialName)) {
            potentialName = `${newPlaylistName} ${counter}`.toLowerCase();
            counter++;
        }
        if (counter > 1) newPlaylistName = `${newPlaylistName} ${counter-1}`;

        const newPlaylistId = 'playlist_' + Date.now() + '_' + Math.random().toString(36).substring(2,9);
        pjData.playlists.push({
            id: newPlaylistId,
            name: newPlaylistName,
            videos: []
        });
        switchPjPlaylist(newPlaylistId); 
    }
    function switchPjPlaylist(playlistId) { 
        if (pjData.currentPlaylistId === playlistId) return;
        pjData.currentPlaylistId = playlistId;
        pjData.currentVideo = null; 
        pjData.randomHistory = []; 
        if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') {
            ytPlayerInstance.stopVideo();
            // Clear player content to ensure it stops
            if (DOM_PJ.playerContainer) DOM_PJ.playerContainer.innerHTML = '<div id="playJockeyPlayer"></div>';
            ytPlayerInstance = null; // Force re-creation if needed
        }
        renderPjTabs();
        renderPjPlaylist();
        savePjData();
    }

    function renderPjPlaylist() { 
        DOM_PJ.playlistArea.innerHTML = '';
        const currentPlaylist = getCurrentPjPlaylist();

        if (!currentPlaylist || currentPlaylist.videos.length === 0) {
            const emptyMsg = document.createElement('div');
            emptyMsg.textContent = "Playlist is empty. Add YouTube links or search!";
            emptyMsg.style.padding = "10px";
            emptyMsg.style.textAlign = "center";
            emptyMsg.style.color = "#555";
            DOM_PJ.playlistArea.appendChild(emptyMsg);
            updatePlayingClassInPjPlaylist(null); 
            return;
        }

        currentPlaylist.videos.forEach(video => {
            const item = document.createElement('div');
            item.className = 'playjockey-playlist-item';

            let cleanTitle = decodeHtmlEntitiesPJ(video.title);
            let cleanArtist = decodeHtmlEntitiesPJ(video.artist);
            
            let displayTitle = cleanTitle;
            if (cleanTitle === "Loading title..." || cleanTitle === video.originalUrl || !cleanTitle.trim()) {
                const decodedOriginalUrl = decodeHtmlEntitiesPJ(video.originalUrl);
                displayTitle = decodedOriginalUrl.length > 40 ? decodedOriginalUrl.substring(0, 37) + '...' : decodedOriginalUrl;
            } else {
                 displayTitle = cleanTitle.length > 40 ? cleanTitle.substring(0, 37) + '...' : cleanTitle;
            }

            let itemText = displayTitle;
            let itemTooltip = (cleanTitle !== "Loading title..." && cleanTitle.trim()) ? cleanTitle : decodeHtmlEntitiesPJ(video.originalUrl);

            if (cleanArtist && cleanArtist.trim() !== "") {
                const artistShort = cleanArtist.length > 20 ? cleanArtist.substring(0, 17) + '...' : cleanArtist;
                itemText = `${displayTitle} - ${artistShort}`;
                itemTooltip = `${itemTooltip} by ${cleanArtist}`;
            }
            
            item.textContent = itemText;
            item.title = itemTooltip;
            item.dataset.videoId = video.videoId;
            item.dataset.playlistItemId = video.id; 
            item.draggable = true;

            if (pjData.currentVideo && pjData.currentVideo.id === video.id) {
                item.classList.add('playing');
            }

            item.addEventListener('click', (event) => {
                if (event.target.closest('.context-modal')) return; 
                if (item.classList.contains('dragging')) return; 

                const clickedItem = event.currentTarget;
                if (clickedItem && clickedItem.dataset.videoId) {
                    playYouTubeVideoById(clickedItem.dataset.videoId, true, true);
                }
            });
            DOM_PJ.playlistArea.appendChild(item);
        });
    }


    function playYouTubeVideoById(videoId, autoplayIntent = true, isManualPlay = false) { 
        if (!videoId) { console.warn("playYouTubeVideoById called with no videoId"); return; }
        const currentPlaylist = getCurrentPjPlaylist();
        if (!currentPlaylist) { console.warn("No current playlist to play from"); return; }

        const videoToPlay = currentPlaylist.videos.find(v => v.videoId === videoId);
        if (!videoToPlay) {
            console.warn(`Video with ID ${videoId} not found in current playlist.`);
            pjData.currentVideo = null;
            updatePlayingClassInPjPlaylist(null);
            if(ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') ytPlayerInstance.stopVideo();
            return;
        }
        
        if ( isManualPlay && videoToPlay && pjData.randomEnabled &&
             pjData.autoPlayEnabled && pjData.repeatState === "off" &&
             currentPlaylist.videos.length > 0 ) {
            
            const uniqueVideoIdsInPlaylist = new Set(currentPlaylist.videos.map(v => v.id));
            if (new Set(pjData.randomHistory).size >= uniqueVideoIdsInPlaylist.size) {
                 pjData.randomHistory = [videoToPlay.id];
            } else if (!pjData.randomHistory.includes(videoToPlay.id)) {
                 pjData.randomHistory.push(videoToPlay.id);
            }
        }

        pjData.currentVideo = { ...videoToPlay }; 
        updatePlayingClassInPjPlaylist(videoToPlay.id);
        savePjData();

        if (!isYouTubeApiReady) {
            pendingVideoToLoad = { videoId, autoplayIntent };
            console.log("Play Jockey: YouTube API not ready, video load queued:", videoId);
            if (typeof YT !== 'undefined' && YT.Player && !isYouTubeApiReady) { 
                // If script is loaded but onYouTubeIframeAPIReady hasn't fired, try to trigger it.
                // This can happen if the script loads after DOMContentLoaded.
                console.log("Play Jockey: Manually calling onYouTubeIframeAPIReady as YT object exists.");
                onYouTubeIframeAPIReady();
            }
            return;
        }

        if (ytPlayerInstance && typeof ytPlayerInstance.loadVideoById === 'function' && ytPlayerInstance.getIframe && ytPlayerInstance.getIframe().parentNode) {
            ytPlayerInstance.loadVideoById({ 'videoId': videoId });
            if (autoplayIntent && typeof ytPlayerInstance.playVideo === 'function') {
                 ytPlayerInstance.playVideo();
            }
        } else {
            if (DOM_PJ.playerContainer.firstChild && DOM_PJ.playerContainer.firstChild.id === 'playJockeyPlayerPlaceholder') {
                 DOM_PJ.playerContainer.innerHTML = '<div id="playJockeyPlayer"></div>'; // Replace placeholder
            } else if (DOM_PJ.playerContainer.firstChild && DOM_PJ.playerContainer.firstChild.tagName === 'IFRAME') {
                 // If an old iframe exists, clear it to ensure clean player creation
                 DOM_PJ.playerContainer.innerHTML = '<div id="playJockeyPlayer"></div>';
            } else if (!DOM_PJ.playerContainer.firstChild) {
                // If container is empty, ensure the target div for player exists
                DOM_PJ.playerContainer.innerHTML = '<div id="playJockeyPlayer"></div>';
            }

            console.log("Play Jockey: Creating new YT Player instance for video:", videoId);
            ytPlayerInstance = new YT.Player('playJockeyPlayer', { 
                height: '100%',
                width: '100%',
                videoId: videoId,
                playerVars: {
                    'autoplay': autoplayIntent ? 1 : 0,
                    'controls': 1, 'enablejsapi': 1, 'origin': window.location.origin,
                    'modestbranding': 1, 'rel': 0
                },
                events: {
                    'onReady': (event) => { 
                        console.log("Play Jockey: Player ready for video:", videoId);
                        if (autoplayIntent) event.target.playVideo(); 
                    },
                    'onStateChange': onPjPlayerStateChange,
                    'onError': (event) => {
                        console.error("Play Jockey: YouTube Player Error:", event.data, "for video:", videoId);
                        // Handle common errors like video unavailable, playback restricted etc.
                        if (event.data === 2 || event.data === 5 || event.data === 100 || event.data === 101 || event.data === 150) {
                            // Video unavailable or restricted, try playing next if autoplay is on
                            if (pjData.autoPlayEnabled) {
                                console.log("Play Jockey: Video error, trying next video.");
                                playNextPjVideo();
                            }
                        }
                    }
                }
            });
        }
    }
    function onPjPlayerStateChange(event) { 
        if (event.data === YT.PlayerState.ENDED && pjData.autoPlayEnabled) {
            playNextPjVideo();
        }
    }
    function playNextPjVideo() { 
        const currentPlaylist = getCurrentPjPlaylist();
        if (!ytPlayerInstance || !pjData.currentVideo || !currentPlaylist || currentPlaylist.videos.length === 0) {
            return;
        }

        let nextVideoItem = null;
        const currentVideoUniqueId = pjData.currentVideo.id; 
        const activePlaylistVideos = currentPlaylist.videos;

        if (pjData.repeatState === "song") {
            nextVideoItem = activePlaylistVideos.find(item => item.id === currentVideoUniqueId);
        } else if (pjData.randomEnabled) {
            if (activePlaylistVideos.length === 0) return;

            if (activePlaylistVideos.length === 1) { 
                if (pjData.repeatState === "off") {
                    if (pjData.randomHistory.includes(currentVideoUniqueId) && pjData.randomHistory.length >= activePlaylistVideos.length) return;
                    nextVideoItem = activePlaylistVideos[0];
                } else { 
                    nextVideoItem = activePlaylistVideos[0];
                }
            } else { 
                let eligibleVideos = activePlaylistVideos.filter(
                    video => !pjData.randomHistory.includes(video.id) || video.id === currentVideoUniqueId 
                );

                if (eligibleVideos.length === 1 && eligibleVideos[0].id === currentVideoUniqueId && pjData.repeatState !== "song") {
                     eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                     if (eligibleVideos.length === 0 && pjData.repeatState === "playlist") {
                        pjData.randomHistory = [currentVideoUniqueId]; 
                        eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                     }
                } else if (eligibleVideos.length === 0 && pjData.repeatState === "playlist") { 
                    pjData.randomHistory = [currentVideoUniqueId]; 
                    eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId);
                }
                
                if (eligibleVideos.length === 0) { 
                    if (pjData.repeatState === "playlist") { 
                        pjData.randomHistory = []; 
                        eligibleVideos = [...activePlaylistVideos];
                        if(activePlaylistVideos.length === 1) nextVideoItem = activePlaylistVideos[0]; 
                    } else { 
                        pjData.randomHistory = []; 
                        return; 
                    }
                }

                if (eligibleVideos.length > 0 && !nextVideoItem) { 
                    const randomIndex = Math.floor(Math.random() * eligibleVideos.length);
                    nextVideoItem = eligibleVideos[randomIndex];
                }
            }
            
            if (nextVideoItem) {
                if (!pjData.randomHistory.includes(nextVideoItem.id)) {
                     pjData.randomHistory.push(nextVideoItem.id);
                }
                if (pjData.repeatState === "playlist") {
                    const maxHistorySize = Math.max(0, activePlaylistVideos.length -1); 
                    while (pjData.randomHistory.length > maxHistorySize && maxHistorySize > 0 && pjData.randomHistory.length >= activePlaylistVideos.length) {
                        pjData.randomHistory.shift(); 
                    }
                }
            }

        } else { 
            const currentIndex = activePlaylistVideos.findIndex(item => item.id === currentVideoUniqueId);
            if (currentIndex === -1) return; 

            let nextIndex = currentIndex + 1;
            if (nextIndex >= activePlaylistVideos.length) { 
                if (pjData.repeatState === "playlist") {
                    nextIndex = 0; 
                } else {
                    return; 
                }
            }
            if (activePlaylistVideos[nextIndex]) {
                nextVideoItem = activePlaylistVideos[nextIndex];
            }
        }

        if (nextVideoItem && nextVideoItem.videoId) {
            playYouTubeVideoById(nextVideoItem.videoId, true, false); 
        }
    }
    function updatePlayingClassInPjPlaylist(playingItemId) { 
        const items = DOM_PJ.playlistArea.querySelectorAll('.playjockey-playlist-item');
        items.forEach(item => {
            if (item.dataset.playlistItemId === playingItemId) {
                item.classList.add('playing');
            } else {
                item.classList.remove('playing');
            }
        });
    }

    function handlePjDragStart(e) { 
        const target = e.target.closest('.playjockey-playlist-item');
        if (target) {
            pjDraggedItem = target;
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', target.dataset.playlistItemId); 
            setTimeout(() => {
                target.classList.add('dragging');
            }, 0);
        }
    }
    function handlePjDragEnd(e) { 
        if (pjDraggedItem) {
            pjDraggedItem.classList.remove('dragging');
        }
        DOM_PJ.playlistArea.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
        pjDraggedItem = null;
    }
    function clearPjDragOverHighlights() { 
        DOM_PJ.playlistArea.querySelectorAll('.playjockey-playlist-item').forEach(item => {
            item.classList.remove('drag-over-target-before', 'drag-over-target-after');
        });
    }
    function handlePjDragOver(e) { 
        e.preventDefault();
        const targetItem = e.target.closest('.playjockey-playlist-item');
        clearPjDragOverHighlights(); 
        if (targetItem && pjDraggedItem && targetItem !== pjDraggedItem) {
            const rect = targetItem.getBoundingClientRect();
            const midpointY = rect.top + rect.height / 2;
            if (e.clientY < midpointY) {
                targetItem.classList.add('drag-over-target-before');
            } else {
                targetItem.classList.add('drag-over-target-after');
            }
        }
    }
    function handlePjDragLeave(e) { 
        const relatedTargetIsChildOrSelf = DOM_PJ.playlistArea.contains(e.relatedTarget);
        if (!relatedTargetIsChildOrSelf) { 
             clearPjDragOverHighlights();
        } else { 
            const targetItem = e.target.closest('.playjockey-playlist-item');
            if (targetItem) { 
                 targetItem.classList.remove('drag-over-target-before', 'drag-over-target-after');
            }
        }
    }
    function handlePjDrop(e) { 
        e.preventDefault();
        clearPjDragOverHighlights();
        const currentPlaylist = getCurrentPjPlaylist();
        if (!pjDraggedItem || !currentPlaylist) return;

        const draggedItemId = e.dataTransfer.getData('text/plain'); 
        const targetItemElement = e.target.closest('.playjockey-playlist-item');

        const draggedItemIndex = currentPlaylist.videos.findIndex(item => item.id === draggedItemId);
        if (draggedItemIndex === -1) return;

        const itemToMove = currentPlaylist.videos[draggedItemIndex];
        currentPlaylist.videos.splice(draggedItemIndex, 1); 

        let targetIndex = -1;
        if (targetItemElement && targetItemElement.dataset.playlistItemId !== draggedItemId) {
            const targetItemId = targetItemElement.dataset.playlistItemId; 
            targetIndex = currentPlaylist.videos.findIndex(item => item.id === targetItemId);
            
            if (targetIndex !== -1) {
                const rect = targetItemElement.getBoundingClientRect();
                const midpointY = rect.top + rect.height / 2;
                if (e.clientY >= midpointY) { 
                    targetIndex++;
                }
            }
        }

        if (targetIndex !== -1 && targetIndex <= currentPlaylist.videos.length) {
            currentPlaylist.videos.splice(targetIndex, 0, itemToMove);
        } else { 
            currentPlaylist.videos.push(itemToMove);
        }

        renderPjPlaylist();
        savePjData();
        pjDraggedItem = null;
    }

    function togglePjAutoPlay() { 
        pjData.autoPlayEnabled = !pjData.autoPlayEnabled;
        updatePjAutoPlayButtonState();
        savePjData();
    }
    function updatePjAutoPlayButtonState() { 
        DOM_PJ.autoPlayBtn.classList.toggle('autoplay-on', pjData.autoPlayEnabled);
        DOM_PJ.autoPlayBtn.textContent = `Auto Play: ${pjData.autoPlayEnabled ? 'On' : 'Off'}`;
    }
    function togglePjRandom() { 
        pjData.randomEnabled = !pjData.randomEnabled;
        pjData.randomHistory = []; 
        const currentPlaylist = getCurrentPjPlaylist();
        if (pjData.randomEnabled && pjData.currentVideo && currentPlaylist && currentPlaylist.videos.length > 0) {
             if (currentPlaylist.videos.length > 1 || pjData.repeatState !== "off") {
                 pjData.randomHistory.push(pjData.currentVideo.id); 
            }
        }
        updatePjRandomButtonState();
        savePjData();
    }
    function updatePjRandomButtonState() { 
        DOM_PJ.randomBtn.classList.toggle('random-on', pjData.randomEnabled);
        DOM_PJ.randomBtn.textContent = `Random: ${pjData.randomEnabled ? 'On' : 'Off'}`;
    }
    function cyclePjRepeat() { 
        const states = ["off", "playlist", "song"];
        let currentIndex = states.indexOf(pjData.repeatState);
        currentIndex = (currentIndex + 1) % states.length;
        pjData.repeatState = states[currentIndex];
        
        pjData.randomHistory = []; 
        const currentPlaylist = getCurrentPjPlaylist();
        if (pjData.randomEnabled && pjData.currentVideo && currentPlaylist && currentPlaylist.videos.length > 0) {
             if (currentPlaylist.videos.length > 1 || pjData.repeatState !== "off") {
                 pjData.randomHistory.push(pjData.currentVideo.id);
            }
        }
        updatePjRepeatButtonState();
        savePjData();
    }
    function updatePjRepeatButtonState() { 
        DOM_PJ.repeatBtn.classList.remove('repeat-on'); 
        switch (pjData.repeatState) {
            case "off":
                DOM_PJ.repeatBtn.textContent = 'Repeat: Off';
                break;
            case "playlist":
                DOM_PJ.repeatBtn.textContent = 'Repeat: List';
                DOM_PJ.repeatBtn.classList.add('repeat-on');
                break;
            case "song":
                DOM_PJ.repeatBtn.textContent = 'Repeat: One';
                DOM_PJ.repeatBtn.classList.add('repeat-on');
                break;
        }
    }


    function addPjEventListeners() {
        DOM_PJ.addBtn.addEventListener('click', handlePjInput);
        DOM_PJ.linkInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handlePjInput(); });
        DOM_PJ.playlistArea.addEventListener('dragstart', handlePjDragStart);
        DOM_PJ.playlistArea.addEventListener('dragend', handlePjDragEnd);
        DOM_PJ.playlistArea.addEventListener('dragover', handlePjDragOver);
        DOM_PJ.playlistArea.addEventListener('dragleave', handlePjDragLeave);
        DOM_PJ.playlistArea.addEventListener('drop', handlePjDrop);
        DOM_PJ.autoPlayBtn.addEventListener('click', togglePjAutoPlay);
        DOM_PJ.randomBtn.addEventListener('click', togglePjRandom);
        DOM_PJ.repeatBtn.addEventListener('click', cyclePjRepeat);
    }
    
    window.addEventListener('message', (event) => {
        // Add origin check in a real application
        // if (event.origin !== 'YOUR_OS_ORIGIN_HERE') return; 
        if (event.data && event.data.type === 'apiKeyResponse' && event.data.service === 'youtube') {
            YOUTUBE_API_KEY = event.data.key;
            console.log("Play Jockey App: YouTube API Key received.");
             if (!YOUTUBE_API_KEY) {
                 console.warn("Play Jockey: YouTube API Key from OS is empty. Search will be disabled.");
            }
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        loadPjData();
        renderPjTabs();
        renderPjPlaylist();
        updatePjAutoPlayButtonState();
        updatePjRandomButtonState();
        updatePjRepeatButtonState();
        addPjEventListeners();

        if (window.parent && window.parent !== window) {
            console.log("Play Jockey App: Requesting YouTube API key from parent OS.");
            window.parent.postMessage({ type: 'requestApiKey', service: 'youtube', appId: 'playJockey' }, '*');
        } else {
            console.warn("Play Jockey App: Not running in an iframe or parent context not detected for API key request.");
        }

        // Auto-load current video if API is ready and video exists
        // The onYouTubeIframeAPIReady function will handle this once the API is loaded.
        // If YT object is already available (API script loaded before DOMContentLoaded), trigger manually.
        if (typeof YT !== 'undefined' && YT.Player && !isYouTubeApiReady) {
            onYouTubeIframeAPIReady();
        }
    });
</script>
