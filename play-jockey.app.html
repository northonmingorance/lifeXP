<style>
    body { margin: 0; padding: 0; font-family: "Tahoma", "Geneva", sans-serif; font-size: 11px; display: flex; flex-direction: column; height: 100vh; overflow: hidden; background-color: #D4D0C8;}
    .xp-button { background-color: #ECE9D8; border: 1px outset #7F7F7F; padding: 5px 12px; min-width: 75px; text-align: center; cursor: pointer; margin: 2px; }
    .xp-button:active { border-style: inset; }
    .xp-button:hover { border-color: #005CFE; }
    .xp-button-small { padding: 2px 5px; font-size: 10px; min-width: auto; margin: 0 2px;}

    .playjockey-body-container { display: flex; flex-direction: column; width: 100%; height: 100%; background-color: #D4D0C8; padding: 5px; box-sizing: border-box; }
    .playjockey-input-bar { display: flex; margin-bottom: 5px; padding: 5px; background-color: #C0C0C0; border: 1px outset #FFFFFF; border-right-color: #808080; border-bottom-color: #808080; flex-shrink: 0; }
    #playJockeyLinkInput { flex-grow: 1; margin-right: 5px; border: 1px inset #7F7F7F; padding: 4px; font-family: "Tahoma", "Geneva", sans-serif; font-size: 11px; background-color: #FFFFFF; }
    #playJockeyAddBtn { min-width: 60px; padding: 3px 8px; font-size: 11px; }
    .playjockey-player-area { flex-grow: 1; margin-bottom: 5px; border: 2px inset #808080; background-color: black; min-height: 150px; overflow: hidden; }
    #playJockeyPlayer { width: 100%; height: 100%; }
    .playjockey-tabs-bar { display: flex; flex-wrap: nowrap; overflow-x: auto; background-color: #C0C0C0; padding: 3px 3px 0 3px; border-bottom: 1px solid #808080; flex-shrink: 0; gap: 2px; }
    .playjockey-tab { padding: 6px 10px; border: 1px inset #FFFFFF; border-bottom: none; background-color: #D4D0C8; cursor: default; font-size: 10px; white-space: nowrap; border-top-left-radius: 3px; border-top-right-radius: 3px; }
    .playjockey-tab:hover { background-color: #E0E0E0; }
    .playjockey-tab.active { background-color: #F0F0F0; border-style: inset; border-bottom: 1px solid #F0F0F0; position: relative; z-index: 1; font-weight: bold; }
    .playjockey-add-tab-btn { padding: 6px 8px; margin-left: 0px; font-weight: bold; }
    .playjockey-controls-bar { display: flex; justify-content: center; padding: 5px 0px 5px 0px; flex-shrink: 0; gap: 5px; border-top: 1px solid #ACA899; background-color: #F0F0F0; }
    #playJockeyRandomBtn, #playJockeyAutoPlayBtn, #playJockeyRepeatBtn { min-width: 90px; padding: 3px 8px; font-size: 11px; }
    #playJockeyRandomBtn.random-on, #playJockeyAutoPlayBtn.autoplay-on, #playJockeyRepeatBtn.repeat-on { border-style: inset; font-weight: bold; }
    .playjockey-playlist-area { height: 100px; overflow-y: auto; border: 1px inset #7F7F7F; background-color: #FFFFFF; padding: 3px; flex-shrink: 0; border-top: none; position: relative; z-index: 0; }
    .playjockey-playlist-item { padding: 4px 6px; cursor: grab; border-bottom: 1px solid #ECE9D8; font-size: 10px; color: #000080; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; user-select: none; }
    .playjockey-playlist-item:hover { background-color: #000080; color: white; }
    .playjockey-playlist-item.playing { background-color: #005CFE; color: white; font-weight: bold; }
    .playjockey-playlist-item:last-child { border-bottom: none; }
    .playjockey-playlist-item.dragging { opacity: 0.5; background-color: #AED6F1; }
    .playjockey-playlist-item.drag-over-target-before { border-top: 2px dashed #005CFE; }
    .playjockey-playlist-item.drag-over-target-after { border-bottom: 2px dashed #005CFE; }

    .pj-context-modal { display: none; position: fixed; background-color: #ECE9D8; border: 1px solid #000; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); z-index: 2000; padding: 3px 0; min-width: 120px; font-family: "Tahoma", "Geneva", sans-serif; font-size: 11px; }
    .pj-context-modal-item { padding: 5px 12px; cursor: default; color: black; }
    .pj-context-modal-item:hover { background-color: #005CFE; color: white; }

    .pj-modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); justify-content: center; align-items: center; }
    .pj-modal-content { background-color: #ECE9D8; margin: auto; padding: 0; border: 1px solid #000; width: 80%; box-shadow: 5px 5px 15px rgba(0,0,0,0.5); animation: pjFadeIn 0.3s; display: flex; flex-direction: column; }
    .pj-modal-title-bar { background: linear-gradient(to bottom, #005CFE, #0039A9); color: white; padding: 5px 8px; font-weight: bold; border-bottom: 1px solid #000; display: flex; justify-content: space-between; align-items: center; height: 28px; box-sizing: border-box; flex-shrink: 0; }
    .pj-modal-close-button { color: white; font-size: 16px; font-family: "Marlett", "Webdings", sans-serif; font-weight: normal; background: #E04343; border: 1px outset white; width: 22px; height: 18px; text-align: center; line-height: 16px; padding: 0; cursor: pointer; }
    .pj-modal-close-button:hover, .pj-modal-close-button:focus { background: #FF6363; }
    .pj-modal-close-button:active { border-style: inset; }
    .pj-modal-body { padding: 15px; overflow-y: auto; flex-grow: 1; }
    .pj-modal-body p { margin-top: 0; margin-bottom: 10px; }
    .pj-modal-body label { display: block; margin-bottom: 5px; margin-top: 12px; }
    .pj-modal-body input[type="text"] { width: calc(100% - 12px); padding: 5px; margin-bottom: 10px; border: 1px solid #ACA899; box-sizing: border-box; }
    .pj-modal-footer { padding: 10px 15px; text-align: right; background-color: #F0F0F0; border-top: 1px solid #ACA899; flex-shrink: 0; }
    @keyframes pjFadeIn { from {opacity: 0; transform: scale(0.9);} to {opacity: 1; transform: scale(1);} }

    #pjYoutubeSearchResultsBody { max-height: 400px; overflow-y: auto; }
    .pj-youtube-result-item { display: flex; align-items: center; padding: 8px; border-bottom: 1px solid #ACA899; cursor: pointer; background-color: #FFFFFF; }
    .pj-youtube-result-item:hover { background-color: #E0E0E0; }
    .pj-youtube-result-item:last-child { border-bottom: none; }
    .pj-youtube-result-item img { width: 120px; height: 90px; margin-right: 10px; border: 1px solid #ACA899; object-fit: cover; }
    .pj-youtube-result-item-details { display: flex; flex-direction: column; }
    .pj-youtube-result-item-title { font-weight: bold; color: #0039A9; font-size: 12px; margin-bottom: 3px; }
    .pj-youtube-result-item-channel { font-size: 10px; color: #555; }
    #pjYoutubeSearchStatus { padding: 15px; font-size: 12px; text-align: center;}
</style>

<div class="playjockey-body-container">
    <div class="playjockey-input-bar">
        <input type="text" id="playJockeyLinkInput" placeholder="Paste YouTube Link or Search Query">
        <button id="playJockeyAddBtn" class="xp-button">Add</button>
    </div>
    <div class="playjockey-player-area">
        <div id="playJockeyPlayer"></div>
    </div>
    <div class="playjockey-tabs-bar" id="playJockeyTabsBar"></div>
    <div class="playjockey-playlist-area" id="playJockeyPlaylist"></div>
    <div class="playjockey-controls-bar">
        <button id="playJockeyRandomBtn" class="xp-button">Random: Off</button>
        <button id="playJockeyAutoPlayBtn" class="xp-button">Auto Play: On</button>
        <button id="playJockeyRepeatBtn" class="xp-button">Repeat: Off</button>
    </div>
</div>

<div id="pjTrackContextMenu" class="pj-context-modal">
    <div class="pj-context-modal-item" id="pjContextRenameTrack">Rename Track</div>
    <div class="pj-context-modal-item" id="pjContextRemoveTrack">Remove Track</div>
</div>
<div id="pjPlaylistTabContextMenu" class="pj-context-modal">
    <div class="pj-context-modal-item" id="pjTabContextRenamePlaylist">Rename Playlist</div>
    <div class="pj-context-modal-item" id="pjTabContextRemovePlaylist">Remove Playlist</div>
</div>

<div id="pjYoutubeSearchModal" class="pj-modal">
    <div class="pj-modal-content" style="max-width: 600px;">
        <div class="pj-modal-title-bar">
            <span>Youtube Results</span>
            <span class="pj-modal-close-button" data-modal-id="pjYoutubeSearchModal">r</span>
        </div>
        <div class="pj-modal-body" id="pjYoutubeSearchResultsBody">
            <p id="pjYoutubeSearchStatus" style="text-align: center; display: none;"></p>
        </div>
        <div class="pj-modal-footer">
            <button class="xp-button pj-modal-cancel-button" data-modal-id="pjYoutubeSearchModal">Cancel</button>
        </div>
    </div>
</div>

<div id="pjRenamePlaylistModal" class="pj-modal">
    <div class="pj-modal-content" style="max-width: 400px;">
        <div class="pj-modal-title-bar">
            <span>Rename Playlist</span>
            <span class="pj-modal-close-button" data-modal-id="pjRenamePlaylistModal">r</span>
        </div>
        <div class="pj-modal-body">
            <label for="pjPlaylistNewNameInput">New playlist name:</label>
            <input type="text" id="pjPlaylistNewNameInput" placeholder="Enter playlist name">
        </div>
        <div class="pj-modal-footer">
            <button id="pjSaveRenamedPlaylistBtn" class="xp-button">Save</button>
            <button class="xp-button pj-modal-cancel-button" data-modal-id="pjRenamePlaylistModal">Cancel</button>
        </div>
    </div>
</div>

<div id="pjConfirmRemovePlaylistModal" class="pj-modal">
    <div class="pj-modal-content" style="max-width: 400px;">
        <div class="pj-modal-title-bar">
            <span>Confirm Playlist Deletion</span>
            <span class="pj-modal-close-button" data-modal-id="pjConfirmRemovePlaylistModal">r</span>
        </div>
        <div class="pj-modal-body">
            <p id="pjConfirmRemovePlaylistMessage">Are you sure you want to remove this playlist?</p>
        </div>
        <div class="pj-modal-footer">
            <button id="pjConfirmFinalPlaylistRemoveBtn" class="xp-button">Delete</button>
            <button class="xp-button pj-modal-cancel-button" data-modal-id="pjConfirmRemovePlaylistModal">Cancel</button>
        </div>
    </div>
</div>

<div id="pjRenameTrackModal" class="pj-modal">
    <div class="pj-modal-content" style="max-width: 400px;">
        <div class="pj-modal-title-bar">
            <span>Rename Track</span>
            <span class="pj-modal-close-button" data-modal-id="pjRenameTrackModal">r</span>
        </div>
        <div class="pj-modal-body">
            <label for="pjTrackNewNameInput">New track name:</label>
            <input type="text" id="pjTrackNewNameInput" placeholder="Enter track name">
            <label for="pjTrackNewArtistInput" style="margin-top:10px;">New artist name (optional):</label>
            <input type="text" id="pjTrackNewArtistInput" placeholder="Enter artist name">
        </div>
        <div class="pj-modal-footer">
            <button id="pjSaveRenamedTrackBtn" class="xp-button">Save</button>
            <button class="xp-button pj-modal-cancel-button" data-modal-id="pjRenameTrackModal">Cancel</button>
        </div>
    </div>
</div>

<div id="pjConfirmRemoveTrackModal" class="pj-modal">
    <div class="pj-modal-content" style="max-width: 400px;">
        <div class="pj-modal-title-bar">
            <span>Confirm Track Deletion</span>
            <span class="pj-modal-close-button" data-modal-id="pjConfirmRemoveTrackModal">r</span>
        </div>
        <div class="pj-modal-body">
            <p id="pjConfirmRemoveTrackMessage">Are you sure you want to remove this track from the playlist?</p>
        </div>
        <div class="pj-modal-footer">
            <button id="pjConfirmFinalTrackRemoveBtn" class="xp-button">Delete</button>
            <button class="xp-button pj-modal-cancel-button" data-modal-id="pjConfirmRemoveTrackModal">Cancel</button>
        </div>
    </div>
</div>


<script src="https://www.youtube.com/iframe_api"></script> <script>
    const PJ_STORAGE_KEY = 'playJockeyAppData_v1.0.2';
    let YOUTUBE_API_KEY = ""; 

    let pjData = {
        playlists: [],
        currentPlaylistId: null,
        currentVideo: null, 
        autoPlayEnabled: true,
        randomEnabled: false,
        repeatState: "off", 
        randomHistory: []
    };

    const DOM_PJ = {
        linkInput: document.getElementById('playJockeyLinkInput'),
        addBtn: document.getElementById('playJockeyAddBtn'),
        playerContainer: document.getElementById('playJockeyPlayer'),
        tabsBar: document.getElementById('playJockeyTabsBar'),
        playlistArea: document.getElementById('playJockeyPlaylist'),
        randomBtn: document.getElementById('playJockeyRandomBtn'),
        autoPlayBtn: document.getElementById('playJockeyAutoPlayBtn'),
        repeatBtn: document.getElementById('playJockeyRepeatBtn'),
        trackContextMenu: document.getElementById('pjTrackContextMenu'),
        renameTrackContextBtn: document.getElementById('pjContextRenameTrack'),
        removeTrackContextBtn: document.getElementById('pjContextRemoveTrack'),
        playlistTabContextMenu: document.getElementById('pjPlaylistTabContextMenu'),
        renamePlaylistTabContextBtn: document.getElementById('pjTabContextRenamePlaylist'),
        removePlaylistTabContextBtn: document.getElementById('pjTabContextRemovePlaylist'),
        youtubeSearchModal: document.getElementById('pjYoutubeSearchModal'),
        youtubeSearchResultsBody: document.getElementById('pjYoutubeSearchResultsBody'),
        youtubeSearchStatus: document.getElementById('pjYoutubeSearchStatus'),
        renamePlaylistModal: document.getElementById('pjRenamePlaylistModal'),
        playlistNewNameInput: document.getElementById('pjPlaylistNewNameInput'),
        saveRenamedPlaylistBtn: document.getElementById('pjSaveRenamedPlaylistBtn'),
        confirmRemovePlaylistModal: document.getElementById('pjConfirmRemovePlaylistModal'),
        confirmRemovePlaylistMessage: document.getElementById('pjConfirmRemovePlaylistMessage'),
        confirmFinalPlaylistRemoveBtn: document.getElementById('pjConfirmFinalPlaylistRemoveBtn'),
        renameTrackModal: document.getElementById('pjRenameTrackModal'),
        trackNewNameInput: document.getElementById('pjTrackNewNameInput'),
        trackNewArtistInput: document.getElementById('pjTrackNewArtistInput'),
        saveRenamedTrackBtn: document.getElementById('pjSaveRenamedTrackBtn'),
        confirmRemoveTrackModal: document.getElementById('pjConfirmRemoveTrackModal'),
        confirmRemoveTrackMessage: document.getElementById('pjConfirmRemoveTrackMessage'),
        confirmFinalTrackRemoveBtn: document.getElementById('pjConfirmFinalTrackRemoveBtn'),
    };

    let ytPlayerInstance = null;
    let isYouTubeApiReady = false;
    let pendingVideoToLoad = null;
    let pjDraggedItem = null;
    
    function decodeHtmlEntitiesPJ(text) {
        if (typeof text !== 'string') return text;
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }

    function loadPjData() {
        const stored = localStorage.getItem(PJ_STORAGE_KEY);
        const defaultPlaylistId = 'playlist_default_0_' + Date.now();
        if (stored) {
            try {
                pjData = JSON.parse(stored);
                pjData.playlists = pjData.playlists || [{id: defaultPlaylistId, name: "Playlist", videos: []}];
                if (pjData.playlists.length === 0) {
                     pjData.playlists = [{id: defaultPlaylistId, name: "Playlist", videos: []}];
                }
                pjData.currentPlaylistId = pjData.currentPlaylistId || pjData.playlists[0]?.id || defaultPlaylistId;
                if (!pjData.playlists.find(p => p.id === pjData.currentPlaylistId)) {
                    pjData.currentPlaylistId = pjData.playlists[0]?.id || defaultPlaylistId;
                }

                pjData.autoPlayEnabled = typeof pjData.autoPlayEnabled === 'boolean' ? pjData.autoPlayEnabled : true;
                pjData.randomEnabled = typeof pjData.randomEnabled === 'boolean' ? pjData.randomEnabled : false;
                pjData.repeatState = ["off", "playlist", "song"].includes(pjData.repeatState) ? pjData.repeatState : "off";
                pjData.randomHistory = Array.isArray(pjData.randomHistory) ? pjData.randomHistory : [];
                pjData.currentVideo = pjData.currentVideo || null;

            } catch (e) {
                console.error("Error loading Play Jockey data, resetting.", e);
                resetPjData(defaultPlaylistId);
            }
        } else {
            resetPjData(defaultPlaylistId);
        }
    }
    
    function resetPjData(defaultId) {
        pjData = {
            playlists: [{id: defaultId, name: "Playlist", videos: []}],
            currentPlaylistId: defaultId,
            currentVideo: null, autoPlayEnabled: true, randomEnabled: false,
            repeatState: "off", randomHistory: []
        };
    }

    function savePjData() {
        localStorage.setItem(PJ_STORAGE_KEY, JSON.stringify(pjData));
    }

    function getCurrentPjPlaylist() {
        if (!pjData.currentPlaylistId || !pjData.playlists) {
            if (pjData.playlists && pjData.playlists.length > 0) {
                pjData.currentPlaylistId = pjData.playlists[0].id;
            } else {
                const defaultId = 'playlist_default_0_' + Date.now();
                resetPjData(defaultId);
                renderPjTabs();
                return pjData.playlists[0];
            }
        }
        let foundPlaylist = pjData.playlists.find(p => p.id === pjData.currentPlaylistId);
        if (!foundPlaylist && pjData.playlists.length > 0) {
            pjData.currentPlaylistId = pjData.playlists[0].id;
            foundPlaylist = pjData.playlists[0];
        } else if (!foundPlaylist && pjData.playlists.length === 0) {
             const defaultId = 'playlist_default_0_' + Date.now();
             resetPjData(defaultId);
             renderPjTabs();
             return pjData.playlists[0];
        }
        return foundPlaylist;
    }
    
    
    window.onYouTubeIframeAPIReady = function() {
        isYouTubeApiReady = true;
        console.log("Play Jockey: YouTube API Ready.");
        const currentPlaylist = getCurrentPjPlaylist();
        const currentVideo = pjData.currentVideo;

        if (pendingVideoToLoad && currentPlaylist?.videos.find(v => v.videoId === pendingVideoToLoad.videoId)) {
            playYouTubeVideoById(pendingVideoToLoad.videoId, pendingVideoToLoad.autoplayIntent);
            pendingVideoToLoad = null;
        } else if (currentVideo && currentPlaylist?.videos.find(v => v.id === currentVideo.id) && !ytPlayerInstance) {
             if (window.frameElement && window.parent && window.parent.getById) {
                const appWindow = window.parent.getById(`window-playJockey`);
                if (appWindow && appWindow.style.display !== 'none' && !appWindow.classList.contains('minimized')) {
                    playYouTubeVideoById(currentVideo.videoId, pjData.autoPlayEnabled);
                }
            } else {
                 playYouTubeVideoById(currentVideo.videoId, pjData.autoPlayEnabled);
            }
        }
    }

    function extractYouTubeVideoId(url) { 
        if (!url) return null;
        const regex = /(?:youtube\.com\/(?:[^\/\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
        const match = url.match(regex);
        return match ? match[1] : null;
    }
    function isValidYouTubeUrl(url) { 
         if (!url) return false;
        const regex = /^(https?:\/\/)?(www\.)?(youtube\.com\/(watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})([&?].*)?$/;
        return regex.test(url);
    }

    async function handlePjInput() {
        const input = DOM_PJ.linkInput.value.trim();
        if (!input) { alert("Please enter a YouTube link or search query."); return; }

        if (isValidYouTubeUrl(input)) {
            addYouTubeLinkToPj(input);
        } else {
            if (!YOUTUBE_API_KEY) {
                 alert("YouTube API Key is not available for video search. Please add direct YouTube video links or ensure the API key is loaded by the OS.");
                 return;
            }
            searchYouTubeVideos(input);
        }
    }
    
    async function searchYouTubeVideos(query) {
        DOM_PJ.youtubeSearchResultsBody.innerHTML = '';
        DOM_PJ.youtubeSearchStatus.textContent = 'Searching...';
        DOM_PJ.youtubeSearchStatus.style.display = 'block';
        openPjModal('pjYoutubeSearchModal');

        const maxResults = 10; 
        const apiUrl = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&key=${YOUTUBE_API_KEY}&maxResults=${maxResults}`;
        try {
            const response = await fetch(apiUrl);
            if (!response.ok) {
                 const errorData = await response.json();
                 console.error('YouTube API Error during search:', errorData);
                 let errorMessage = `Error searching: ${response.statusText}`;
                 if(errorData.error && errorData.error.errors && errorData.error.errors[0] && errorData.error.errors[0].reason) {
                     errorMessage += ` (Reason: ${errorData.error.errors[0].reason})`;
                 } else if (errorData.error && errorData.error.message) {
                     errorMessage += ` - ${errorData.error.message}`;
                 }
                DOM_PJ.youtubeSearchStatus.textContent = errorMessage;
                return;
            }
            const data = await response.json();
            if (data.items && data.items.length > 0) {
                DOM_PJ.youtubeSearchStatus.style.display = 'none';
                renderYouTubeSearchResults(data.items);
            } else {
                DOM_PJ.youtubeSearchStatus.textContent = 'No videos found for your search query.';
            }
        } catch (error) {
            console.error('Error fetching Youtube results:', error);
            DOM_PJ.youtubeSearchStatus.textContent = 'Failed to search videos. Check console for details.';
        }
    }

    function renderYouTubeSearchResults(items) {
        DOM_PJ.youtubeSearchResultsBody.innerHTML = '';
        items.forEach(item => {
            const videoId = item.id.videoId;
            const title = decodeHtmlEntitiesPJ(item.snippet.title);
            const channelTitle = decodeHtmlEntitiesPJ(item.snippet.channelTitle);
            const thumbnailUrl = item.snippet.thumbnails.default.url;

            const resultDiv = document.createElement('div');
            resultDiv.className = 'pj-youtube-result-item';
            resultDiv.dataset.videoId = videoId;

            const img = document.createElement('img');
            img.src = thumbnailUrl;
            img.alt = title;

            const detailsDiv = document.createElement('div');
            detailsDiv.className = 'pj-youtube-result-item-details';

            const titleDiv = document.createElement('div');
            titleDiv.className = 'pj-youtube-result-item-title';
            titleDiv.textContent = title;
            titleDiv.title = title;

            const channelDiv = document.createElement('div');
            channelDiv.className = 'pj-youtube-result-item-channel';
            channelDiv.textContent = channelTitle;
            channelDiv.title = channelTitle;

            detailsDiv.appendChild(titleDiv);
            detailsDiv.appendChild(channelDiv);
            resultDiv.appendChild(img);
            resultDiv.appendChild(detailsDiv);

            resultDiv.addEventListener('click', () => {
                addVideoFromSearchResult(videoId, title, channelTitle);
                closePjModal('pjYoutubeSearchModal');
            });
            DOM_PJ.youtubeSearchResultsBody.appendChild(resultDiv);
        });
    }


    function addVideoFromSearchResult(videoId, title, artist) {
        let currentPlaylist = getCurrentPjPlaylist();
        if (!currentPlaylist) {
            addNewPjPlaylist();
            currentPlaylist = getCurrentPjPlaylist();
            if (!currentPlaylist) { alert("Error: Could not create playlist."); return; }
        }
        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            return;
        }
        const videoEntry = {
            id: 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7),
            originalUrl: `https://www.youtube.com/watch?v=$$$$$$$$$${videoId}`,
            videoId: videoId,
            title: title,
            artist: artist.replace(/\s-\sTopic$/, '').trim()
        };
        currentPlaylist.videos.push(videoEntry);
        renderPjPlaylist();
        if (!ytPlayerInstance || !pjData.currentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true);
        }
        savePjData();
    }


    function addYouTubeLinkToPj(link) {
        const videoId = extractYouTubeVideoId(link);
        if (!videoId) { alert("Invalid YouTube link."); return; }

        let currentPlaylist = getCurrentPjPlaylist();
        if (!currentPlaylist) {
            addNewPjPlaylist(); 
            currentPlaylist = getCurrentPjPlaylist();
            if (!currentPlaylist) { alert("Error: Could not create playlist."); return; }
        }

        if (currentPlaylist.videos.some(video => video.videoId === videoId)) {
            alert("This video is already in the current playlist.");
            DOM_PJ.linkInput.value = '';
            return;
        }
        const tempId = 'pjv_' + Date.now() + '_' + Math.random().toString(36).substring(2,7);
        const videoEntry = {
            id: tempId, originalUrl: link, videoId: videoId,
            title: "Loading title...", artist: ""
        };
        currentPlaylist.videos.push(videoEntry);
        renderPjPlaylist();
        DOM_PJ.linkInput.value = '';
        fetchYouTubeTitle(videoEntry, currentPlaylist.id);

        if (!ytPlayerInstance || !pjData.currentVideo || currentPlaylist.videos.length === 1) {
            playYouTubeVideoById(videoId, true, true);
        }
        savePjData();
    }

    async function fetchYouTubeTitle(videoEntryToUpdate, playlistId) { 
        try {
            let newTitle = "Unknown Title";
            let newArtist = "";
            if (YOUTUBE_API_KEY) {
                 const apiUrl = `https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoEntryToUpdate.videoId}&key=${YOUTUBE_API_KEY}`;
                 const response = await fetch(apiUrl);
                 if (response.ok) {
                     const data = await response.json();
                     if (data.items && data.items.length > 0) {
                         newTitle = decodeHtmlEntitiesPJ(data.items[0].snippet.title);
                         newArtist = decodeHtmlEntitiesPJ(data.items[0].snippet.channelTitle).replace(/\s-\sTopic$/, '').trim();
                     } else {
                         newTitle = decodeHtmlEntitiesPJ(videoEntryToUpdate.originalUrl); 
                     }
                 } else {
                     newTitle = decodeHtmlEntitiesPJ(videoEntryToUpdate.originalUrl); 
                 }
            } else { 
                console.warn("Play Jockey: YouTube API Key not available to fetch title for " + videoEntryToUpdate.videoId);
                newTitle = decodeHtmlEntitiesPJ(videoEntryToUpdate.originalUrl);
            }

            const targetPlaylist = pjData.playlists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const itemInPlaylist = targetPlaylist.videos.find(item => item.id === videoEntryToUpdate.id);
                if (itemInPlaylist) {
                    itemInPlaylist.title = newTitle;
                    itemInPlaylist.artist = newArtist;
                    if (pjData.currentPlaylistId === playlistId) {
                        renderPjPlaylist(); 
                    }
                    if(pjData.currentVideo && pjData.currentVideo.id === itemInPlaylist.id) {
                        pjData.currentVideo.title = newTitle;
                        pjData.currentVideo.artist = newArtist;
                    }
                    savePjData();
                }
            }
        } catch (error) {
            console.error(`Error in fetchYouTubeTitle for ${videoEntryToUpdate.videoId}:`, error);
             const targetPlaylist = pjData.playlists.find(pl => pl.id === playlistId);
            if (targetPlaylist) {
                const itemInPlaylist = targetPlaylist.videos.find(item => item.id === videoEntryToUpdate.id);
                if (itemInPlaylist && (itemInPlaylist.title === "Loading title..." || !itemInPlaylist.title.trim())) {
                    itemInPlaylist.title = decodeHtmlEntitiesPJ(itemInPlaylist.originalUrl); 
                    if (pjData.currentPlaylistId === playlistId) renderPjPlaylist();
                    savePjData();
                }
            }
        }
    }

    function renderPjTabs() { DOM_PJ.tabsBar.innerHTML = ''; pjData.playlists.forEach(playlist => { const tab = document.createElement('div'); tab.className = 'playjockey-tab'; const displayName = decodeHtmlEntitiesPJ(playlist.name); tab.textContent = displayName; tab.title = displayName; tab.dataset.playlistId = playlist.id; if (playlist.id === pjData.currentPlaylistId) { tab.classList.add('active'); } tab.addEventListener('click', () => switchPjPlaylist(playlist.id)); tab.addEventListener('contextmenu', (e) => showPjTabContextMenu(e, playlist.id)); DOM_PJ.tabsBar.appendChild(tab); }); const addTabBtn = document.createElement('button'); addTabBtn.className = 'playjockey-tab playjockey-add-tab-btn xp-button xp-button-small'; addTabBtn.textContent = '+'; addTabBtn.title = "New Playlist"; addTabBtn.addEventListener('click', addNewPjPlaylist); DOM_PJ.tabsBar.appendChild(addTabBtn); }
    function addNewPjPlaylist() { let newPlaylistName = "Playlist"; let counter = 1; const existingNames = pjData.playlists.map(p => p.name.toLowerCase()); let potentialName = newPlaylistName.toLowerCase(); while (existingNames.includes(potentialName)) { potentialName = `${newPlaylistName} ${counter}`.toLowerCase(); counter++; } if (counter > 1) newPlaylistName = `${newPlaylistName} ${counter-1}`; const newPlaylistId = 'playlist_' + Date.now() + '_' + Math.random().toString(36).substring(2,9); pjData.playlists.push({ id: newPlaylistId, name: newPlaylistName, videos: [] }); switchPjPlaylist(newPlaylistId); }
    function switchPjPlaylist(playlistId) { if (pjData.currentPlaylistId === playlistId) return; pjData.currentPlaylistId = playlistId; pjData.currentVideo = null; pjData.randomHistory = []; if (ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') { ytPlayerInstance.stopVideo(); if (DOM_PJ.playerContainer) DOM_PJ.playerContainer.innerHTML = '<div id="playJockeyPlayer"></div>'; ytPlayerInstance = null; } renderPjTabs(); renderPjPlaylist(); savePjData(); }
    function renderPjPlaylist() { DOM_PJ.playlistArea.innerHTML = ''; const currentPlaylist = getCurrentPjPlaylist(); if (!currentPlaylist || currentPlaylist.videos.length === 0) { const emptyMsg = document.createElement('div'); emptyMsg.textContent = "Playlist is empty. Add YouTube links or search!"; emptyMsg.style.padding = "10px"; emptyMsg.style.textAlign = "center"; emptyMsg.style.color = "#555"; DOM_PJ.playlistArea.appendChild(emptyMsg); updatePlayingClassInPjPlaylist(null); return; } currentPlaylist.videos.forEach(video => { const item = document.createElement('div'); item.className = 'playjockey-playlist-item'; let cleanTitle = decodeHtmlEntitiesPJ(video.title); let cleanArtist = decodeHtmlEntitiesPJ(video.artist); let displayTitle = cleanTitle; if (cleanTitle === "Loading title..." || cleanTitle === video.originalUrl || !cleanTitle.trim()) { const decodedOriginalUrl = decodeHtmlEntitiesPJ(video.originalUrl); displayTitle = decodedOriginalUrl.length > 40 ? decodedOriginalUrl.substring(0, 37) + '...' : decodedOriginalUrl; } else { displayTitle = cleanTitle.length > 40 ? cleanTitle.substring(0, 37) + '...' : cleanTitle; } let itemText = displayTitle; let itemTooltip = (cleanTitle !== "Loading title..." && cleanTitle.trim()) ? cleanTitle : decodeHtmlEntitiesPJ(video.originalUrl); if (cleanArtist && cleanArtist.trim() !== "") { const artistShort = cleanArtist.length > 20 ? cleanArtist.substring(0, 17) + '...' : cleanArtist; itemText = `${displayTitle} - ${artistShort}`; itemTooltip = `${itemTooltip} by ${cleanArtist}`; } item.textContent = itemText; item.title = itemTooltip; item.dataset.videoId = video.videoId; item.dataset.playlistItemId = video.id; item.draggable = true; if (pjData.currentVideo && pjData.currentVideo.id === video.id) { item.classList.add('playing'); } item.addEventListener('click', (event) => { if (event.target.closest('.pj-context-modal')) return; if (item.classList.contains('dragging')) return; const clickedItem = event.currentTarget; if (clickedItem && clickedItem.dataset.videoId) { playYouTubeVideoById(clickedItem.dataset.videoId, true, true); } }); item.addEventListener('contextmenu', showPjTrackContextMenu); DOM_PJ.playlistArea.appendChild(item); }); }
    function playYouTubeVideoById(videoId, autoplayIntent = true, isManualPlay = false) { if (!videoId) { console.warn("playYouTubeVideoById called with no videoId"); return; } const currentPlaylist = getCurrentPjPlaylist(); if (!currentPlaylist) { console.warn("No current playlist to play from"); return; } const videoToPlay = currentPlaylist.videos.find(v => v.videoId === videoId); if (!videoToPlay) { console.warn(`Video with ID ${videoId} not found in current playlist.`); pjData.currentVideo = null; updatePlayingClassInPjPlaylist(null); if(ytPlayerInstance && typeof ytPlayerInstance.stopVideo === 'function') ytPlayerInstance.stopVideo(); return; } if ( isManualPlay && videoToPlay && pjData.randomEnabled && pjData.autoPlayEnabled && pjData.repeatState === "off" && currentPlaylist.videos.length > 0 ) { const uniqueVideoIdsInPlaylist = new Set(currentPlaylist.videos.map(v => v.id)); if (new Set(pjData.randomHistory).size >= uniqueVideoIdsInPlaylist.size) { pjData.randomHistory = [videoToPlay.id]; } else if (!pjData.randomHistory.includes(videoToPlay.id)) { pjData.randomHistory.push(videoToPlay.id); } } pjData.currentVideo = { ...videoToPlay }; updatePlayingClassInPjPlaylist(videoToPlay.id); savePjData(); if (!isYouTubeApiReady) { pendingVideoToLoad = { videoId, autoplayIntent }; console.log("Play Jockey: YouTube API not ready, video load queued:", videoId); if (typeof YT !== 'undefined' && YT.Player && !isYouTubeApiReady) { onYouTubeIframeAPIReady(); } return; } if (ytPlayerInstance && typeof ytPlayerInstance.loadVideoById === 'function' && ytPlayerInstance.getIframe && ytPlayerInstance.getIframe().parentNode) { ytPlayerInstance.loadVideoById({ 'videoId': videoId }); if (autoplayIntent && typeof ytPlayerInstance.playVideo === 'function') { ytPlayerInstance.playVideo(); } } else { if (DOM_PJ.playerContainer.firstChild && DOM_PJ.playerContainer.firstChild.id === 'playJockeyPlayerPlaceholder') { DOM_PJ.playerContainer.innerHTML = '<div id="playJockeyPlayer"></div>'; } else if (DOM_PJ.playerContainer.firstChild && DOM_PJ.playerContainer.firstChild.tagName === 'IFRAME') { DOM_PJ.playerContainer.innerHTML = '<div id="playJockeyPlayer"></div>'; } else if (!DOM_PJ.playerContainer.firstChild) { DOM_PJ.playerContainer.innerHTML = '<div id="playJockeyPlayer"></div>';} console.log("Play Jockey: Creating new YT Player instance for video:", videoId); ytPlayerInstance = new YT.Player('playJockeyPlayer', { height: '100%', width: '100%', videoId: videoId, playerVars: { 'autoplay': autoplayIntent ? 1 : 0, 'controls': 1, 'enablejsapi': 1, 'origin': window.location.origin, 'modestbranding': 1, 'rel': 0 }, events: { 'onReady': (event) => { if (autoplayIntent) event.target.playVideo(); }, 'onStateChange': onPjPlayerStateChange, 'onError': (event) => { console.error("Play Jockey: YouTube Player Error:", event.data, "for video:", videoId); if (event.data === 2 || event.data === 5 || event.data === 100 || event.data === 101 || event.data === 150) { if (pjData.autoPlayEnabled) { console.log("Play Jockey: Video error, trying next video."); playNextPjVideo(); } } } } }); } }
    function onPjPlayerStateChange(event) { if (event.data === YT.PlayerState.ENDED && pjData.autoPlayEnabled) { playNextPjVideo(); } }
    function playNextPjVideo() { const currentPlaylist = getCurrentPjPlaylist(); if (!ytPlayerInstance || !pjData.currentVideo || !currentPlaylist || currentPlaylist.videos.length === 0) { return; } let nextVideoItem = null; const currentVideoUniqueId = pjData.currentVideo.id; const activePlaylistVideos = currentPlaylist.videos; if (pjData.repeatState === "song") { nextVideoItem = activePlaylistVideos.find(item => item.id === currentVideoUniqueId); } else if (pjData.randomEnabled) { if (activePlaylistVideos.length === 0) return; if (activePlaylistVideos.length === 1) { if (pjData.repeatState === "off") { if (pjData.randomHistory.includes(currentVideoUniqueId) && pjData.randomHistory.length >= activePlaylistVideos.length) return; nextVideoItem = activePlaylistVideos[0]; } else { nextVideoItem = activePlaylistVideos[0]; } } else { let eligibleVideos = activePlaylistVideos.filter( video => !pjData.randomHistory.includes(video.id) || video.id === currentVideoUniqueId ); if (eligibleVideos.length === 1 && eligibleVideos[0].id === currentVideoUniqueId && pjData.repeatState !== "song") { eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId); if (eligibleVideos.length === 0 && pjData.repeatState === "playlist") { pjData.randomHistory = [currentVideoUniqueId]; eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId); } } else if (eligibleVideos.length === 0 && pjData.repeatState === "playlist") { pjData.randomHistory = [currentVideoUniqueId]; eligibleVideos = activePlaylistVideos.filter(video => video.id !== currentVideoUniqueId); } if (eligibleVideos.length === 0) { if (pjData.repeatState === "playlist") { pjData.randomHistory = []; eligibleVideos = [...activePlaylistVideos]; if(activePlaylistVideos.length === 1) nextVideoItem = activePlaylistVideos[0]; } else { pjData.randomHistory = []; return; } } if (eligibleVideos.length > 0 && !nextVideoItem) { const randomIndex = Math.floor(Math.random() * eligibleVideos.length); nextVideoItem = eligibleVideos[randomIndex]; } } if (nextVideoItem) { if (!pjData.randomHistory.includes(nextVideoItem.id)) { pjData.randomHistory.push(nextVideoItem.id); } if (pjData.repeatState === "playlist") { const maxHistorySize = Math.max(0, activePlaylistVideos.length -1); while (pjData.randomHistory.length > maxHistorySize && maxHistorySize > 0 && pjData.randomHistory.length >= activePlaylistVideos.length) { pjData.randomHistory.shift(); } } } } else { const currentIndex = activePlaylistVideos.findIndex(item => item.id === currentVideoUniqueId); if (currentIndex === -1) return; let nextIndex = currentIndex + 1; if (nextIndex >= activePlaylistVideos.length) { if (pjData.repeatState === "playlist") { nextIndex = 0; } else { return; } } if (activePlaylistVideos[nextIndex]) { nextVideoItem = activePlaylistVideos[nextIndex]; } } if (nextVideoItem && nextVideoItem.videoId) { playYouTubeVideoById(nextVideoItem.videoId, true, false); } }
    function updatePlayingClassInPjPlaylist(playingItemId) { const items = DOM_PJ.playlistArea.querySelectorAll('.playjockey-playlist-item'); items.forEach(item => { if (item.dataset.playlistItemId === playingItemId) { item.classList.add('playing'); } else { item.classList.remove('playing'); } }); }
    function handlePjDragStart(e) { const target = e.target.closest('.playjockey-playlist-item'); if (target) { pjDraggedItem = target; e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', target.dataset.playlistItemId); setTimeout(() => { target.classList.add('dragging'); }, 0); hidePjTrackContextMenu(); hidePjPlaylistTabContextMenu(); } }
    function handlePjDragEnd(e) { if (pjDraggedItem) { pjDraggedItem.classList.remove('dragging'); } DOM_PJ.playlistArea.querySelectorAll('.playjockey-playlist-item').forEach(item => { item.classList.remove('drag-over-target-before', 'drag-over-target-after'); }); pjDraggedItem = null; }
    function clearPjDragOverHighlights() { DOM_PJ.playlistArea.querySelectorAll('.playjockey-playlist-item').forEach(item => { item.classList.remove('drag-over-target-before', 'drag-over-target-after'); }); }
    function handlePjDragOver(e) { e.preventDefault(); const targetItem = e.target.closest('.playjockey-playlist-item'); clearPjDragOverHighlights(); if (targetItem && pjDraggedItem && targetItem !== pjDraggedItem) { const rect = targetItem.getBoundingClientRect(); const midpointY = rect.top + rect.height / 2; if (e.clientY < midpointY) { targetItem.classList.add('drag-over-target-before'); } else { targetItem.classList.add('drag-over-target-after'); } } }
    function handlePjDragLeave(e) { const relatedTargetIsChildOrSelf = DOM_PJ.playlistArea.contains(e.relatedTarget); if (!relatedTargetIsChildOrSelf) { clearPjDragOverHighlights(); } else { const targetItem = e.target.closest('.playjockey-playlist-item'); if (targetItem) { targetItem.classList.remove('drag-over-target-before', 'drag-over-target-after'); } } }
    function handlePjDrop(e) { e.preventDefault(); clearPjDragOverHighlights(); const currentPlaylist = getCurrentPjPlaylist(); if (!pjDraggedItem || !currentPlaylist) return; const draggedItemId = e.dataTransfer.getData('text/plain'); const targetItemElement = e.target.closest('.playjockey-playlist-item'); const draggedItemIndex = currentPlaylist.videos.findIndex(item => item.id === draggedItemId); if (draggedItemIndex === -1) return; const itemToMove = currentPlaylist.videos[draggedItemIndex]; currentPlaylist.videos.splice(draggedItemIndex, 1); let targetIndex = -1; if (targetItemElement && targetItemElement.dataset.playlistItemId !== draggedItemId) { const targetItemId = targetItemElement.dataset.playlistItemId; targetIndex = currentPlaylist.videos.findIndex(item => item.id === targetItemId); if (targetIndex !== -1) { const rect = targetItemElement.getBoundingClientRect(); const midpointY = rect.top + rect.height / 2; if (e.clientY >= midpointY) { targetIndex++; } } } if (targetIndex !== -1 && targetIndex <= currentPlaylist.videos.length) { currentPlaylist.videos.splice(targetIndex, 0, itemToMove); } else { currentPlaylist.videos.push(itemToMove); } renderPjPlaylist(); savePjData(); pjDraggedItem = null; }
    function togglePjAutoPlay() { pjData.autoPlayEnabled = !pjData.autoPlayEnabled; updatePjAutoPlayButtonState(); savePjData(); }
    function updatePjAutoPlayButtonState() { DOM_PJ.autoPlayBtn.classList.toggle('autoplay-on', pjData.autoPlayEnabled); DOM_PJ.autoPlayBtn.textContent = `Auto Play: ${pjData.autoPlayEnabled ? 'On' : 'Off'}`; }
    function togglePjRandom() { pjData.randomEnabled = !pjData.randomEnabled; pjData.randomHistory = []; const currentPlaylist = getCurrentPjPlaylist(); if (pjData.randomEnabled && pjData.currentVideo && currentPlaylist && currentPlaylist.videos.length > 0) { if (currentPlaylist.videos.length > 1 || pjData.repeatState !== "off") { pjData.randomHistory.push(pjData.currentVideo.id); } } updatePjRandomButtonState(); savePjData(); }
    function updatePjRandomButtonState() { DOM_PJ.randomBtn.classList.toggle('random-on', pjData.randomEnabled); DOM_PJ.randomBtn.textContent = `Random: ${pjData.randomEnabled ? 'On' : 'Off'}`; }
    function cyclePjRepeat() { const states = ["off", "playlist", "song"]; let currentIndex = states.indexOf(pjData.repeatState); currentIndex = (currentIndex + 1) % states.length; pjData.repeatState = states[currentIndex]; pjData.randomHistory = []; const currentPlaylist = getCurrentPjPlaylist(); if (pjData.randomEnabled && pjData.currentVideo && currentPlaylist && currentPlaylist.videos.length > 0) { if (currentPlaylist.videos.length > 1 || pjData.repeatState !== "off") { pjData.randomHistory.push(pjData.currentVideo.id); } } updatePjRepeatButtonState(); savePjData(); }
    function updatePjRepeatButtonState() { DOM_PJ.repeatBtn.classList.remove('repeat-on'); switch (pjData.repeatState) { case "off": DOM_PJ.repeatBtn.textContent = 'Repeat: Off'; break; case "playlist": DOM_PJ.repeatBtn.textContent = 'Repeat: List'; DOM_PJ.repeatBtn.classList.add('repeat-on'); break; case "song": DOM_PJ.repeatBtn.textContent = 'Repeat: One'; DOM_PJ.repeatBtn.classList.add('repeat-on'); break; } }

    function openPjModal(modalId) { const modal = document.getElementById(modalId); if(modal) modal.style.display = 'flex'; }
    function closePjModal(modalId) { const modal = document.getElementById(modalId); if(modal) modal.style.display = 'none'; }
    function showPjTrackContextMenu(e) { e.preventDefault(); hidePjTrackContextMenu(); hidePjPlaylistTabContextMenu(); const clickedItem = e.target.closest('.playjockey-playlist-item'); if (clickedItem) { DOM_PJ.trackContextMenu.style.display = 'block'; let x = e.clientX; let y = e.clientY; const menuWidth = DOM_PJ.trackContextMenu.offsetWidth; const menuHeight = DOM_PJ.trackContextMenu.offsetHeight; const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight; if (x + menuWidth > viewportWidth) x = viewportWidth - menuWidth - 5; if (y + menuHeight > viewportHeight) y = viewportHeight - menuHeight - 5; DOM_PJ.trackContextMenu.style.left = `${Math.max(0,x)}px`; DOM_PJ.trackContextMenu.style.top = `${Math.max(0,y)}px`; DOM_PJ.trackContextMenu.dataset.itemId = clickedItem.dataset.playlistItemId; } }
    function hidePjTrackContextMenu() { DOM_PJ.trackContextMenu.style.display = 'none'; delete DOM_PJ.trackContextMenu.dataset.itemId; }
    function showPjTabContextMenu(e, playlistId) { e.preventDefault(); hidePjTrackContextMenu(); hidePjPlaylistTabContextMenu(); DOM_PJ.playlistTabContextMenu.style.display = 'block'; let x = e.clientX; let y = e.clientY; const menuWidth = DOM_PJ.playlistTabContextMenu.offsetWidth; const menuHeight = DOM_PJ.playlistTabContextMenu.offsetHeight; const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight; if (x + menuWidth > viewportWidth) x = viewportWidth - menuWidth - 5; if (y + menuHeight > viewportHeight) y = viewportHeight - menuHeight - 5; DOM_PJ.playlistTabContextMenu.style.left = `${Math.max(0,x)}px`; DOM_PJ.playlistTabContextMenu.style.top = `${Math.max(0,y)}px`; DOM_PJ.playlistTabContextMenu.dataset.playlistId = playlistId; }
    function hidePjPlaylistTabContextMenu() { DOM_PJ.playlistTabContextMenu.style.display = 'none'; delete DOM_PJ.playlistTabContextMenu.dataset.playlistId; }
    function handlePjContextRenameTrack() { const itemId = DOM_PJ.trackContextMenu.dataset.itemId; const currentPlaylist = getCurrentPjPlaylist(); if(!itemId || !currentPlaylist) return hidePjTrackContextMenu(); const item = currentPlaylist.videos.find(v => v.id === itemId); if(item) { DOM_PJ.trackNewNameInput.value = decodeHtmlEntitiesPJ(item.title); DOM_PJ.trackNewArtistInput.value = decodeHtmlEntitiesPJ(item.artist); DOM_PJ.saveRenamedTrackBtn.dataset.itemId = itemId; openPjModal('pjRenameTrackModal'); DOM_PJ.trackNewNameInput.focus(); } hidePjTrackContextMenu(); }
    function handlePjContextRemoveTrack() { const itemId = DOM_PJ.trackContextMenu.dataset.itemId; const currentPlaylist = getCurrentPjPlaylist(); if(!itemId || !currentPlaylist) return hidePjTrackContextMenu(); const item = currentPlaylist.videos.find(v => v.id === itemId); if(item) { DOM_PJ.confirmRemoveTrackMessage.textContent = `Remove "${decodeHtmlEntitiesPJ(item.title)}"?`; DOM_PJ.confirmFinalTrackRemoveBtn.dataset.itemId = itemId; openPjModal('pjConfirmRemoveTrackModal'); } hidePjTrackContextMenu(); }
    function saveRenamedPjTrack() { const itemId = DOM_PJ.saveRenamedTrackBtn.dataset.itemId; const newName = DOM_PJ.trackNewNameInput.value.trim(); const newArtist = DOM_PJ.trackNewArtistInput.value.trim(); const currentPlaylist = getCurrentPjPlaylist(); if (!itemId || !currentPlaylist || !newName) return alert("Track name cannot be empty."); const item = currentPlaylist.videos.find(v => v.id === itemId); if(item){ item.title = newName; item.artist = newArtist; if(pjData.currentVideo && pjData.currentVideo.id === itemId){pjData.currentVideo.title = newName; pjData.currentVideo.artist = newArtist;} renderPjPlaylist(); savePjData(); } closePjModal('pjRenameTrackModal'); }
    function executePjTrackDeletion() { const itemId = DOM_PJ.confirmFinalTrackRemoveBtn.dataset.itemId; const currentPlaylist = getCurrentPjPlaylist(); if (!itemId || !currentPlaylist) return closePjModal('pjConfirmRemoveTrackModal'); const itemIndex = currentPlaylist.videos.findIndex(v => v.id === itemId); if(itemIndex > -1){ const removed = currentPlaylist.videos.splice(itemIndex,1)[0]; if(pjData.currentVideo && pjData.currentVideo.id === removed.id){ if(ytPlayerInstance && ytPlayerInstance.stopVideo) ytPlayerInstance.stopVideo(); pjData.currentVideo = null; if(pjData.autoPlayEnabled && currentPlaylist.videos.length>0) playNextPjVideo(); else if(currentPlaylist.videos.length === 0) DOM_PJ.playerContainer.innerHTML = '<div id="playJockeyPlayer"></div>';} renderPjPlaylist(); savePjData(); } closePjModal('pjConfirmRemoveTrackModal');}
    function openRenamePjPlaylistModal() { const playlistId = DOM_PJ.playlistTabContextMenu.dataset.playlistId; if(!playlistId) return hidePjPlaylistTabContextMenu(); const playlist = pjData.playlists.find(p=>p.id === playlistId); if(playlist) { DOM_PJ.playlistNewNameInput.value = decodeHtmlEntitiesPJ(playlist.name); DOM_PJ.saveRenamedPlaylistBtn.dataset.playlistId = playlistId; openPjModal('pjRenamePlaylistModal'); DOM_PJ.playlistNewNameInput.focus(); } hidePjPlaylistTabContextMenu(); }
    function saveRenamedPjPlaylist() { const playlistId = DOM_PJ.saveRenamedPlaylistBtn.dataset.playlistId; const newName = DOM_PJ.playlistNewNameInput.value.trim(); if(!playlistId || !newName) return alert("Playlist name cannot be empty."); const playlist = pjData.playlists.find(p => p.id === playlistId); if(playlist) { playlist.name = newName; renderPjTabs(); savePjData(); } closePjModal('pjRenamePlaylistModal'); }
    function openConfirmRemovePjPlaylistModal() { const playlistId = DOM_PJ.playlistTabContextMenu.dataset.playlistId; if(!playlistId) return hidePjPlaylistTabContextMenu(); const playlist = pjData.playlists.find(p=>p.id === playlistId); if(playlist) { DOM_PJ.confirmRemovePlaylistMessage.textContent = `Delete playlist "${decodeHtmlEntitiesPJ(playlist.name)}"?`; DOM_PJ.confirmFinalPlaylistRemoveBtn.dataset.playlistId = playlistId; openPjModal('pjConfirmRemovePlaylistModal'); } hidePjPlaylistTabContextMenu(); }
    function executePjPlaylistDeletion() { const playlistId = DOM_PJ.confirmFinalPlaylistRemoveBtn.dataset.playlistId; if(!playlistId || pjData.playlists.length <=1) return closePjModal('pjConfirmRemovePlaylistModal'); const index = pjData.playlists.findIndex(p=>p.id === playlistId); if(index > -1) { pjData.playlists.splice(index,1); if(pjData.currentPlaylistId === playlistId) { if(ytPlayerInstance && ytPlayerInstance.stopVideo) ytPlayerInstance.stopVideo(); pjData.currentVideo = null; pjData.currentPlaylistId = pjData.playlists[0]?.id || null; if(!pjData.currentPlaylistId && pjData.playlists.length === 0) { const defaultId = 'playlist_default_0_' + Date.now(); resetPjData(defaultId); } } renderPjTabs(); renderPjPlaylist(); savePjData(); } closePjModal('pjConfirmRemovePlaylistModal'); }


    function addPjEventListeners() {
        DOM_PJ.addBtn.addEventListener('click', handlePjInput);
        DOM_PJ.linkInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handlePjInput(); });
        DOM_PJ.playlistArea.addEventListener('dragstart', handlePjDragStart);
        DOM_PJ.playlistArea.addEventListener('dragend', handlePjDragEnd);
        DOM_PJ.playlistArea.addEventListener('dragover', handlePjDragOver);
        DOM_PJ.playlistArea.addEventListener('dragleave', handlePjDragLeave);
        DOM_PJ.playlistArea.addEventListener('drop', handlePjDrop);
        DOM_PJ.autoPlayBtn.addEventListener('click', togglePjAutoPlay);
        DOM_PJ.randomBtn.addEventListener('click', togglePjRandom);
        DOM_PJ.repeatBtn.addEventListener('click', cyclePjRepeat);

        DOM_PJ.renameTrackContextBtn.addEventListener('click', handlePjContextRenameTrack);
        DOM_PJ.removeTrackContextBtn.addEventListener('click', handlePjContextRemoveTrack);
        DOM_PJ.renamePlaylistTabContextBtn.addEventListener('click', openRenamePjPlaylistModal);
        DOM_PJ.removePlaylistTabContextBtn.addEventListener('click', openConfirmRemovePjPlaylistModal);

        DOM_PJ.saveRenamedPlaylistBtn.addEventListener('click', saveRenamedPjPlaylist);
        DOM_PJ.playlistNewNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') saveRenamedPjPlaylist(); });
        DOM_PJ.confirmFinalPlaylistRemoveBtn.addEventListener('click', executePjPlaylistDeletion);
        DOM_PJ.saveRenamedTrackBtn.addEventListener('click', saveRenamedPjTrack);
        DOM_PJ.trackNewNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') saveRenamedPjTrack(); });
        DOM_PJ.trackNewArtistInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') saveRenamedPjTrack(); });
        DOM_PJ.confirmFinalTrackRemoveBtn.addEventListener('click', executePjTrackDeletion);

        document.querySelectorAll('.pj-modal-close-button, .pj-modal-cancel-button').forEach(btn => {
            btn.addEventListener('click', (event) => {
                const modalId = event.target.dataset.modalId;
                if(modalId) closePjModal(modalId);
            });
        });
        document.addEventListener('click', (e) => {
            if (!DOM_PJ.trackContextMenu.contains(e.target) && !e.target.closest('.playjockey-playlist-item')) {
                hidePjTrackContextMenu();
            }
            if (!DOM_PJ.playlistTabContextMenu.contains(e.target) && !e.target.closest('.playjockey-tab')) {
                hidePjPlaylistTabContextMenu();
            }
        });
    }
    
    window.addEventListener('message', (event) => {
        if (event.data && event.data.type === 'apiKeyResponse' && event.data.service === 'youtube') {
            YOUTUBE_API_KEY = event.data.key;
            console.log("Play Jockey App: YouTube API Key received.");
             if (!YOUTUBE_API_KEY) {
                 console.warn("Play Jockey: YouTube API Key from OS is empty. Search will be disabled.");
            }
        }
    });

    document.addEventListener('DOMContentLoaded', () => {
        loadPjData();
        renderPjTabs();
        renderPjPlaylist();
        updatePjAutoPlayButtonState();
        updatePjRandomButtonState();
        updatePjRepeatButtonState();
        addPjEventListeners();

        if (window.parent && window.parent !== window) {
            console.log("Play Jockey App: Requesting YouTube API key from parent OS.");
            window.parent.postMessage({ type: 'requestApiKey', service: 'youtube', appId: 'playJockey' }, '*');
        } else {
            console.warn("Play Jockey App: Not running in an iframe or parent context not detected for API key request.");
        }        
    });
</script>