<template id="xpTrackerIconTemplate">
    <div id="trackerIcon" class="desktop-icon" data-window-id="xpMainWindow" style="left: 10px; top: 10px;">
        <div class="icon-image">âœ…</div>
        <div class="icon-label">XP Tracker</div>
    </div>
</template>

<template id="xpTrackerWindowTemplate">
    <div class="xp-window" id="xpMainWindow" style="display: none;">
        <div class="title-bar" id="xpMainWindowTitleBar">
            <span class="title-bar-text">XP Tracker</span>
            <div class="title-bar-controls">
                <button id="xpMainWindowMinimizeBtn" title="Minimize">0</button>
                <button id="xpMainWindowMaximizeBtn" title="Maximize">1</button>
                <button title="Close" id="xpMainWindowCloseBtn">r</button>
            </div>
        </div>
        <div class="window-body" id="xpMainWindowBody">
            </div>
        <div class="resize-handle" id="xpMainWindowResizeHandle"></div>
    </div>
</template>

<template id="xpTrackerBodyContentTemplate">
    <div class="controls-bar" id="controlsBar">
        <div class="week-navigation">
            <button id="prevWeekBtn" class="xp-button">&lt; Prev Week</button>
            <button id="thisWeekBtn" class="xp-button">This Week</button>
            <button id="nextWeekBtn" class="xp-button">Next Week &gt;</button>
        </div>
        <div class="controls-group">
            <span id="currentWeekDisplay">Week X</span>
            <span id="weekCountDisplay">Year Week: XX</span>
        </div>
        <div class="global-actions">
            <button id="toggleViewBtn" class="xp-button">Day View</button>
            <button id="showQuestsBtn" class="xp-button">Weekly Quests</button>
            <button id="addAreaBtn" class="xp-button">New Area</button>
        </div>
    </div>
    <table id="gridTable">
        <thead>
            <tr id="weekdayHeaders">
                <th>Area</th>
            </tr>
        </thead>
        <tbody id="gridBody">
        </tbody>
    </table>
</template>

<template id="xpTrackerModalsTemplate">
    <div id="newAreaModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span id="newAreaModalTitle">Create New Area</span>
                <span class="close-button" data-modal-id="newAreaModal">r</span>
            </div>
            <div class="modal-body">
                <label for="newAreaName">Area Name:</label>
                <input type="text" id="newAreaName" placeholder="e.g., Fitness, Learning, Work">
            </div>
            <div class="modal-footer">
                <button id="saveNewAreaBtn" class="xp-button">Save</button>
                <button class="xp-button" data-modal-id="newAreaModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="addEditAchievementModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span id="addEditAchievementModalTitle">Add Achievement</span>
                <span class="close-button" data-modal-id="addEditAchievementModal">r</span>
            </div>
            <div class="modal-body">
                <input type="hidden" id="achievementAreaName">
                <input type="hidden" id="achievementDayIndex">
                <input type="hidden" id="editingAchievementKey">
                <input type="hidden" id="editingAchievementId">
                <label>Type:</label>
                <input type="radio" name="achievementType" value="text" id="typeText" checked> Text
                <input type="radio" name="achievementType" value="image" id="typeImage"> Image
                <br><br>
                <div id="textInputDiv">
                    <label for="achievementText">Description:</label>
                    <textarea id="achievementText" rows="3"></textarea>
                </div>
                <div id="imageInputDiv" style="display:none;">
                    <label for="achievementImage">Upload Image:</label>
                    <input type="file" id="achievementImage" accept="image/*">
                    <p><small>Current image will be kept if no new image is selected during edit.</small></p>
                </div>
            </div>
            <div class="modal-footer">
                <button id="saveAchievementBtn" class="xp-button">Save Achievement</button>
                <button class="xp-button" data-modal-id="addEditAchievementModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="questsModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Weekly Quests</span>
                <span class="close-button" data-modal-id="questsModal">r</span>
            </div>
            <div class="modal-body" id="questsList">
            </div>
            <div class="modal-footer">
                <button id="addQuestBtn" class="xp-button">Create New Quest</button>
                <button class="xp-button" data-modal-id="questsModal">Close</button>
            </div>
        </div>
    </div>
    <div id="confirmRemoveAreaModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Deletion</span>
                <span class="close-button" data-modal-id="confirmRemoveAreaModal">r</span>
            </div>
            <div class="modal-body">
                <p id="confirmRemoveAreaMessage">Are you sure?</p>
            </div>
            <div class="modal-footer">
                <button id="confirmRemoveBtn" class="xp-button">Confirm</button>
                <button class="xp-button" data-modal-id="confirmRemoveAreaModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmDeleteAchievementModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Achievement Deletion</span>
                <span class="close-button" data-modal-id="confirmDeleteAchievementModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to delete this achievement? This will deduct its XP if it was awarded.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmDeleteAchievementBtn" class="xp-button">Delete</button>
                <button class="xp-button" data-modal-id="confirmDeleteAchievementModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="createQuestModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Create New Quest</span>
                <span class="close-button" data-modal-id="createQuestModal">r</span>
            </div>
            <div class="modal-body">
                <label for="newQuestAreaName">Area:</label>
                <select id="newQuestAreaName"></select>
                <label for="newQuestDescription">Description:</label>
                <textarea id="newQuestDescription" rows="2" placeholder="e.g., Read 2 chapters"></textarea>
                <label for="newQuestTargetXP">Target XP to Earn in Area for Quest:</label>
                <input type="number" id="newQuestTargetXP" min="1" value="30">
                <label for="newQuestRewardXP">Quest Reward XP:</label>
                <input type="number" id="newQuestRewardXP" min="1" value="50">
            </div>
            <div class="modal-footer">
                <button id="saveNewQuestBtn" class="xp-button">Save Quest</button>
                <button class="xp-button" data-modal-id="createQuestModal">Cancel</button>
            </div>
        </div>
    </div>
    <div id="confirmRefreshQuestModal" class="modal">
        <div class="modal-content">
            <div class="modal-title-bar">
                <span>Confirm Quest Refresh</span>
                <span class="close-button" data-modal-id="confirmRefreshQuestModal">r</span>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to refresh this quest? Current progress on this quest will be lost and a new quest will be generated.</p>
            </div>
            <div class="modal-footer">
                <button id="confirmRefreshQuestBtn" class="xp-button">Refresh Quest</button>
                <button class="xp-button" data-modal-id="confirmRefreshQuestModal">Cancel</button>
            </div>
        </div>
    </div>
</template>

<style>
    /* XP Tracker Specific Styles */
    #xpMainWindow .window-body {
         padding: 15px;
         overflow-y: auto;
    }
    .controls-bar {
        display: flex;
        margin-bottom: 15px;
        padding: 8px;
        border: 1px solid #ACA899;
        background-color: #F0F0F0;
    }
    .controls-bar.layout-single-row {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
        flex-wrap: nowrap;
    }
    .controls-bar.layout-single-row > div {
         margin: 2px 5px;
         flex-shrink: 0;
    }
    .controls-bar.layout-multi-row {
        flex-direction: column;
        align-items: stretch;
    }
    .controls-bar.layout-multi-row > div {
        width: 100%;
        box-sizing: border-box;
        margin-bottom: 8px;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        padding: 5px 0;
    }
    .controls-bar.layout-multi-row > div:last-child {
        margin-bottom: 0;
    }
    .controls-bar.layout-multi-row .controls-group {
         text-align: center;
    }
    .week-navigation {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
    }
    .week-navigation button {
        margin: 0 3px;
    }
    .controls-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin: 0 10px;
        text-align: center;
    }
    #currentWeekDisplay {
        font-weight: bold;
    }
    #weekCountDisplay {
        font-size: 0.9em;
        color: #333;
    }
    .global-actions {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
    }
    #gridTable {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        table-layout: fixed;
    }
    #gridTable th, #gridTable td {
        border: 1px solid #ACA899;
        padding: 8px;
        text-align: left;
        vertical-align: top;
        word-wrap: break-word;
    }
    #gridTable th {
        background-color: #D4D0C8;
        text-align: center;
    }
    #gridTable td.area-name-cell {
        font-weight: bold;
        width: 180px; /* Fixed width for the area name column */
    }
    .area-stats {
        font-size: 0.9em;
        margin-top: 5px;
        color: #333;
    }
    .area-stats span { display: flex; }
    .xp-bar-container {
        width: 100%;
        height: 12px;
        background-color: #BDBDBD;
        border: 1px solid #7F7F7F;
        margin-top: 3px;
        position: relative;
        border-radius: 2px;
        overflow: hidden;
    }
    .xp-bar {
        height: 100%;
        background-color: #008000;
        transition: width 0.3s ease;
        border-radius: 1px;
    }
    .xp-bar-text {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 9px;
        line-height: 12px;
        color: white;
        text-shadow: 1px 1px 0px black;
        font-weight: bold;
        z-index: 1;
    }
    .achievement-item {
        background-color: #FFF;
        border: 1px solid #DDD;
        padding: 8px;
        margin-bottom: 4px;
        font-size: 0.9em;
        border-radius: 3px;
        word-wrap: break-word;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .achievement-content {
        width: 100%;
        text-align: center;
        margin-bottom: 8px;
    }
    .achievement-content img {
        max-width: 100%;
        height: auto;
        display: block;
        margin-left: auto;
        margin-right: auto;
        margin-top: 0px;
        border-radius: 2px;
    }
    .achievement-item-actions {
        display: flex;
        gap: 3px;
    }
    .achievement-add-btn-cell {
        display: block;
        width: 99.5%;
        box-sizing: border-box;
        margin-top: 5px;
    }
    .quest-item {
        padding: 8px;
        border: 1px solid #ACA899;
        margin-bottom: 8px;
        background-color: #FFF;
        border-radius: 3px;
        position: relative;
    }
    .quest-item label {
        margin-left: 8px;
    }
    .quest-item.completed {
        background-color: #DFF0D8;
        text-decoration: line-through;
        color: #508a50;
    }
    .quest-item.completed .quest-title {
         color: #006400;
    }
    .quest-title {
        font-weight: bold;
        margin-bottom: 5px;
        color: #0039A9;
    }
    .quest-details {
        font-size: 0.95em;
        margin-bottom: 3px;
    }
    .quest-progress {
        font-size: 0.85em;
        color: #555;
        margin-top: 3px;
        margin-bottom: 25px;
    }
    .quest-actions {
        position: absolute;
        bottom: 5px;
        right: 5px;
    }
    .area-name-wrapper {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
    }
    .delete-area-btn {
        padding: 1px 6px;
        min-width: auto;
        font-size: 10px;
        font-family: "Tahoma", "Geneva", sans-serif;
        font-weight: bold;
        margin-left: 10px;
        background-color: #E04343;
        color: white;
        border: 1px outset white;
        line-height: 1.2;
        cursor: pointer;
    }
    .delete-area-btn:hover {
        background-color: #FF6363;
    }
    .delete-area-btn:active {
        border-style: inset;
    }
    .xp-button-small { /* Ensure this is available if used by tracker */
        padding: 2px 5px;
        font-size: 10px;
        min-width: auto;
        margin: 0 2px;
    }
</style>

<script>
(function() {
    const APP_ID = 'xpMainWindow'; // This app's main window ID
    const MIN_WIDTH_WEEK_VIEW = 905;
    const MIN_WIDTH_DAY_VIEW = 375;
    const MIN_HEIGHT = 250;

    const WEEKDAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    const XP_PER_REGULAR_ACHIEVEMENT = 10;
    const XP_PER_QUEST_COMPLETED_BASE = 50;
    const MAX_WEEKLY_QUESTS = 5;

    let xpTrackerDOM = {}; // Will be populated by populateXPTrackerDOM

    // Helper to access global getById
    const getById = window.getById;

    function decodeHtmlEntities(text) {
        if (typeof text !== 'string') return text;
        const textarea = document.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }
    
    function populateXPTrackerDOM() {
        // Query for elements *after* they have been injected into the main DOM
        xpTrackerDOM = {
            xpMainWindow: getById('xpMainWindow'),
            xpMainWindowBody: getById('xpMainWindowBody'),
            weekdayHeaders: getById('weekdayHeaders'),
            gridBody: getById('gridBody'),
            addAreaBtn: getById('addAreaBtn'),
            prevWeekBtn: getById('prevWeekBtn'),
            nextWeekBtn: getById('nextWeekBtn'),
            thisWeekBtn: getById('thisWeekBtn'),
            toggleViewBtn: getById('toggleViewBtn'),
            currentWeekDisplay: getById('currentWeekDisplay'),
            weekCountDisplay: getById('weekCountDisplay'),
            showQuestsBtn: getById('showQuestsBtn'),
            controlsBar: getById('controlsBar'),
            newAreaModal: getById('newAreaModal'),
            newAreaNameInput: getById('newAreaName'),
            saveNewAreaBtn: getById('saveNewAreaBtn'),
            addEditAchievementModal: getById('addEditAchievementModal'),
            addEditAchievementModalTitle: getById('addEditAchievementModalTitle'),
            achievementAreaNameInput: getById('achievementAreaName'),
            achievementDayIndexInput: getById('achievementDayIndex'),
            editingAchievementKeyInput: getById('editingAchievementKey'),
            editingAchievementIdInput: getById('editingAchievementId'),
            achievementTypeRadios: document.getElementsByName('achievementType'), // Still global query
            textInputDiv: getById('textInputDiv'),
            imageInputDiv: getById('imageInputDiv'),
            achievementTextInput: getById('achievementText'),
            achievementImageInput: getById('achievementImage'),
            saveAchievementBtn: getById('saveAchievementBtn'),
            questsModal: getById('questsModal'),
            questsList: getById('questsList'),
            addQuestBtn: getById('addQuestBtn'),
            createQuestModal: getById('createQuestModal'),
            newQuestAreaNameSelect: getById('newQuestAreaName'),
            newQuestDescriptionInput: getById('newQuestDescription'),
            newQuestTargetXPInput: getById('newQuestTargetXP'),
            newQuestRewardXPInput: getById('newQuestRewardXP'),
            saveNewQuestBtn: getById('saveNewQuestBtn'),
            confirmRefreshQuestModal: getById('confirmRefreshQuestModal'),
            confirmRefreshQuestBtn: getById('confirmRefreshQuestBtn'),
            confirmRemoveAreaModal: getById('confirmRemoveAreaModal'),
            confirmRemoveAreaMessage: getById('confirmRemoveAreaMessage'),
            confirmRemoveBtn: getById('confirmRemoveBtn'),
            confirmDeleteAchievementModal: getById('confirmDeleteAchievementModal'),
            confirmDeleteAchievementBtn: getById('confirmDeleteAchievementBtn'),
        };
    }

    function getXPTrackerData() {
        if (!window.appData.xpTracker) {
            window.appData.xpTracker = {
                areas: [],
                achievements: {},
                quests: {},
                currentWeekStartDate: null,
                viewMode: 'week',
                selectedDayIndex: 0,
            };
        }
        return window.appData.xpTracker;
    }

    function parseYYYYMMDDToLocalDate(dateString) {
        if (!dateString || typeof dateString !== 'string') return null;
        const parts = dateString.split('-');
        if (parts.length !== 3) return null;
        const [year, month, day] = parts.map(Number);
        if (isNaN(year) || isNaN(month) || isNaN(day)) return null;
        return new Date(year, month - 1, day);
    }

    function getDayOfYear(date) {
        const startOfYear = new Date(date.getFullYear(), 0, 0);
        const diff = date - startOfYear;
        const oneDay = 1000 * 60 * 60 * 24;
        return Math.floor(diff / oneDay);
    }

     function checkAndAwardScheduledXP() {
        const trackerData = getXPTrackerData();
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        let xpWasAwardedThisCheck = false;

        for (const achievementsKey in trackerData.achievements) {
            if (trackerData.achievements.hasOwnProperty(achievementsKey)) {
                const achievementsInCell = trackerData.achievements[achievementsKey];
                const keyParts = achievementsKey.split('_');
                if (keyParts.length < 3) continue;
                
                const areaName = keyParts.slice(1, keyParts.length - 1).join('_'); 

                for (const ach of achievementsInCell) {
                    if (ach.xpAwarded === undefined) ach.xpAwarded = false;
                    if (!ach.scheduledDate || ach.xpAwarded) continue;

                    const achievementScheduledDate = parseYYYYMMDDToLocalDate(ach.scheduledDate);
                    if (achievementScheduledDate && achievementScheduledDate <= today) {
                        addXpToArea(areaName, ach.xp);
                        updateQuestProgress(areaName, ach.xp);
                        ach.xpAwarded = true;
                        xpWasAwardedThisCheck = true;
                    }
                }
            }
        }
        if (xpWasAwardedThisCheck) {
            renderGrid();
            window.saveData(); 
        }
    }

    function initXPTrackerApp() {
        const trackerData = getXPTrackerData(); // Ensures data object is initialized
        populateXPTrackerDOM(); // Now safe to query for elements

        if (trackerData.viewMode !== 'week' && trackerData.viewMode !== 'day') {
             trackerData.viewMode = 'week';
        }
        if (!trackerData.currentWeekStartDate) {
            trackerData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        }
        if (trackerData.viewMode === 'day' && (trackerData.selectedDayIndex === undefined || trackerData.selectedDayIndex < 0 || trackerData.selectedDayIndex > 6) ) {
             trackerData.selectedDayIndex = 0;
        }
        
        updateMinDimensionsForXPTracker(); // Register dimensions with OS
        checkAndAwardScheduledXP();

        addXPTrackerEventListeners();
        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        handleXPTrackerWindowResize(); // Initial layout check

        const windowEl = getById(APP_ID);
        if (windowEl) {
            windowEl.addEventListener('appresize', handleXPTrackerWindowResize);
            // Listen for appopen event if specific actions are needed when window becomes visible
            windowEl.addEventListener('appopen', (event) => {
                if (event.detail && event.detail.windowId === APP_ID) {
                    // App was opened or restored from hidden, refresh UI if needed
                    handleXPTrackerWindowResize();
                    renderGrid(); // Example: re-render grid
                }
            });
        }
    }
    
    function updateMinDimensionsForXPTracker() {
        const trackerData = getXPTrackerData();
        let currentMinWidth = (trackerData.viewMode === 'week') ? MIN_WIDTH_WEEK_VIEW : MIN_WIDTH_DAY_VIEW;
        if (window.appRegistry && window.appRegistry[APP_ID]) {
            window.appRegistry[APP_ID].minWidth = currentMinWidth;
            // minHeight is constant for this app
        }
        // If window already exists, OS might need to re-evaluate its size if minWidth changed
        const appWindow = getById(APP_ID);
        if (appWindow && !appWindow.classList.contains('true-maximized') && !appWindow.classList.contains('minimized')) {
            if (appWindow.offsetWidth < currentMinWidth) {
                appWindow.style.width = currentMinWidth + 'px';
                window.saveWindowState(APP_ID); // Save new size if OS adjusted it
            }
        }
    }

    function handleXPTrackerWindowResize() {
        const windowEl = getById(APP_ID);
        if (!windowEl || windowEl.classList.contains('minimized') || windowEl.style.display === 'none') return;
        checkControlsBarLayout();
    }

    function checkControlsBarLayout() {
        const controlsBar = xpTrackerDOM.controlsBar;
        if (!controlsBar || !controlsBar.clientWidth) return;

        const children = [
            controlsBar.querySelector('.week-navigation'),
            controlsBar.querySelector('.controls-group'),
            controlsBar.querySelector('.global-actions')
        ].filter(el => el);

        if (children.length === 0) return;
        const originalClasses = controlsBar.className;
        controlsBar.className = 'controls-bar layout-single-row';
        
        let totalChildrenWidth = 0;
        children.forEach(child => {
            const childStyle = getComputedStyle(child);
            totalChildrenWidth += child.scrollWidth + parseFloat(childStyle.marginLeft) + parseFloat(childStyle.marginRight);
        });
        
        controlsBar.className = originalClasses;
        const controlsBarClientWidth = controlsBar.clientWidth - (parseFloat(getComputedStyle(controlsBar).paddingLeft) + parseFloat(getComputedStyle(controlsBar).paddingRight));

        if (totalChildrenWidth > controlsBarClientWidth && controlsBarClientWidth > 0) {
            controlsBar.classList.add('layout-multi-row');
            controlsBar.classList.remove('layout-single-row');
        } else {
            controlsBar.classList.add('layout-single-row');
            controlsBar.classList.remove('layout-multi-row');
        }
    }

    function addXPTrackerEventListeners() {
        // Ensure DOM elements are available
        if (!xpTrackerDOM.gridBody) {
            console.error("XP Tracker DOM not ready for event listeners.");
            return;
        }

        xpTrackerDOM.gridBody.addEventListener('click', function(event) {
            const target = event.target;
            if (target.classList.contains('delete-area-btn')) {
                const areaName = target.dataset.areaName;
                if (areaName) promptRemoveArea(areaName);
            } else if (target.classList.contains('edit-ach-btn')) {
                const achKey = target.dataset.achKey;
                const achId = target.dataset.achId;
                openAddEditAchievementModal(null, null, achKey, achId);
            } else if (target.classList.contains('remove-ach-btn')) {
                const achKey = target.dataset.achKey;
                const achId = target.dataset.achId;
                promptRemoveAchievement(achKey, achId);
            } else if (target.classList.contains('achievement-add-btn-cell')) {
                const areaName = target.dataset.areaName;
                const dayIndex = parseInt(target.dataset.dayIndex);
                openAddEditAchievementModal(areaName, dayIndex);
            }
        });

        xpTrackerDOM.addAreaBtn.addEventListener('click', () => window.openModal('newAreaModal'));
        xpTrackerDOM.saveNewAreaBtn.addEventListener('click', saveNewArea);
        xpTrackerDOM.newAreaNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') saveNewArea();
        });

        xpTrackerDOM.saveAchievementBtn.addEventListener('click', saveOrUpdateAchievement);
        xpTrackerDOM.achievementTypeRadios.forEach(radio => {
            radio.addEventListener('change', toggleAchievementInputType);
        });

        xpTrackerDOM.prevWeekBtn.addEventListener('click', () => {
            const trackerData = getXPTrackerData();
            if (trackerData.viewMode === 'week') navigateWeek(-7);
            else navigateDay(-1);
        });
        xpTrackerDOM.nextWeekBtn.addEventListener('click', () => {
            const trackerData = getXPTrackerData();
            if (trackerData.viewMode === 'week') navigateWeek(7);
            else navigateDay(1);
        });
        xpTrackerDOM.thisWeekBtn.addEventListener('click', goToThisWeek);
        xpTrackerDOM.toggleViewBtn.addEventListener('click', toggleViewMode);

        xpTrackerDOM.showQuestsBtn.addEventListener('click', showQuests);
        xpTrackerDOM.addQuestBtn.addEventListener('click', openCreateQuestModal);
        xpTrackerDOM.saveNewQuestBtn.addEventListener('click', saveNewQuest);
        xpTrackerDOM.questsList.addEventListener('click', function(event) {
            if (event.target.classList.contains('refresh-quest-btn')) {
                const questId = event.target.dataset.questId;
                promptRefreshQuest(questId);
            }
        });
        xpTrackerDOM.confirmRefreshQuestBtn.addEventListener('click', confirmAndRefreshQuest);
        
        xpTrackerDOM.confirmRemoveBtn.addEventListener('click', function() {
            const areaNameToRemove = this.dataset.areaNameToRemove;
            if (areaNameToRemove) {
                removeArea(areaNameToRemove);
                window.closeModal('confirmRemoveAreaModal');
                delete this.dataset.areaNameToRemove;
            }
        });
        xpTrackerDOM.confirmDeleteAchievementBtn.addEventListener('click', function() {
            const key = this.dataset.achievementKey;
            const id = this.dataset.achievementId;
            if (key && id) {
                confirmRemoveAchievement(key, id);
            }
        });
        
        const appWindow = getById(APP_ID);
        if (appWindow) {
            const closeButton = appWindow.querySelector('#xpMainWindowCloseBtn');
            if (closeButton) closeButton.addEventListener('click', () => {
                let state = window.appData.windowStates[APP_ID];
                if (state) state.hiddenByUser = true;
                window.saveWindowState(APP_ID);
                appWindow.style.display = 'none';
            });

            const minimizeButton = appWindow.querySelector('#xpMainWindowMinimizeBtn');
            if (minimizeButton) minimizeButton.addEventListener('click', () => window.minimizeWindow(APP_ID));

            const maximizeButton = appWindow.querySelector('#xpMainWindowMaximizeBtn');
            if (maximizeButton) maximizeButton.addEventListener('click', () => window.maximizeWindow(APP_ID));
        }
    }

    function getMonday(d) {
        d = new Date(d);
        const currentDay = d.getDay();
        const diffToMondayVal = d.getDate() - currentDay + (currentDay === 0 ? -6 : 1);
        const mondayDate = new Date(d.getFullYear(), d.getMonth(), diffToMondayVal);
        return mondayDate;
    }

    function getWeekNumber(d) {
        d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }

    function getCurrentWeekId() {
        const trackerData = getXPTrackerData();
        if (!trackerData.currentWeekStartDate) {
            trackerData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        }
        const startDate = parseYYYYMMDDToLocalDate(trackerData.currentWeekStartDate);
        return `${startDate.getFullYear()}-W${String(getWeekNumber(startDate)).padStart(2, '0')}`;
    }

    function navigateWeek(offsetInDays) {
        const trackerData = getXPTrackerData();
        const currentMon = parseYYYYMMDDToLocalDate(trackerData.currentWeekStartDate);
        currentMon.setDate(currentMon.getDate() + offsetInDays);
        trackerData.currentWeekStartDate = getMonday(currentMon).toISOString().split('T')[0];
        updateDateDisplay();
        renderWeekdayHeaders();
        checkAndAwardScheduledXP();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        window.saveData();
    }

    function navigateDay(offset) {
        const trackerData = getXPTrackerData();
        trackerData.selectedDayIndex += offset;
        let weekChanged = false;
        let currentMonDate = parseYYYYMMDDToLocalDate(trackerData.currentWeekStartDate);
        if (trackerData.selectedDayIndex < 0) {
            currentMonDate.setDate(currentMonDate.getDate() - 7);
            trackerData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            trackerData.selectedDayIndex = 6;
            weekChanged = true;
        } else if (trackerData.selectedDayIndex > 6) {
            currentMonDate.setDate(currentMonDate.getDate() + 7);
            trackerData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            trackerData.selectedDayIndex = 0;
            weekChanged = true;
        }
        updateDateDisplay();
        renderWeekdayHeaders();
        checkAndAwardScheduledXP();
        renderGrid();
        if (weekChanged) {
            generateQuestsForCurrentWeekIfNeeded();
        }
        window.saveData();
    }

    function goToThisWeek() {
        const trackerData = getXPTrackerData();
        trackerData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        if(trackerData.viewMode === 'day') {
            const today = new Date();
            let currentDayOfWeek = today.getDay();
            trackerData.selectedDayIndex = (currentDayOfWeek === 0) ? 6 : currentDayOfWeek - 1;
        }
        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        checkAndAwardScheduledXP();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        window.saveData();
    }

    function toggleViewMode() {
        const trackerData = getXPTrackerData();
        const appWindow = getById(APP_ID);
        const state = window.appData.windowStates[APP_ID];
        const wasMaximized = appWindow.classList.contains('true-maximized');
        const wasMinimized = appWindow.classList.contains('minimized');

        if (trackerData.viewMode === 'week') {
            trackerData.viewMode = 'day';
            const today = new Date();
            const currentWeekMondayObj = parseYYYYMMDDToLocalDate(trackerData.currentWeekStartDate);
            const checkDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const weekStartCheck = new Date(currentWeekMondayObj.getFullYear(), currentWeekMondayObj.getMonth(), currentWeekMondayObj.getDate());
            const weekEndCheck = new Date(weekStartCheck);
            weekEndCheck.setDate(weekStartCheck.getDate() + 6);

            if (checkDate >= weekStartCheck && checkDate <= weekEndCheck) {
                let currentDayOfWeek = today.getDay();
                trackerData.selectedDayIndex = (currentDayOfWeek === 0) ? 6 : currentDayOfWeek - 1;
            } else {
                 if (trackerData.selectedDayIndex === undefined || trackerData.selectedDayIndex < 0 || trackerData.selectedDayIndex > 6) {
                    trackerData.selectedDayIndex = 0;
                }
            }
        } else {
            trackerData.viewMode = 'week';
        }
        updateMinDimensionsForXPTracker(); 
        const newMinWidth = (trackerData.viewMode === 'week') ? MIN_WIDTH_WEEK_VIEW : MIN_WIDTH_DAY_VIEW;

        if (!wasMaximized && !wasMinimized) {
            let currentWidth = appWindow.offsetWidth;
            if (currentWidth < newMinWidth) {
                appWindow.style.width = newMinWidth + 'px';
                if(state) {
                    state.width = newMinWidth;
                    state.userManuallySet = false; 
                }
            } else if (state && !state.userManuallySet) {
                 window.setWindowDefaults(APP_ID, false); 
            }
        }

        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        window.saveData();
    }

    function updateViewControls() {
        const trackerData = getXPTrackerData();
        if (xpTrackerDOM.toggleViewBtn) { // Check if DOM elements are populated
            if (trackerData.viewMode === 'week') {
                xpTrackerDOM.toggleViewBtn.textContent = 'Day View';
                xpTrackerDOM.prevWeekBtn.textContent = '< Prev Week';
                xpTrackerDOM.nextWeekBtn.textContent = 'Next Week >';
                xpTrackerDOM.thisWeekBtn.textContent = 'This Week';
            } else {
                xpTrackerDOM.toggleViewBtn.textContent = 'Week View';
                xpTrackerDOM.prevWeekBtn.textContent = '< Prev Day';
                xpTrackerDOM.nextWeekBtn.textContent = 'Next Day >';
                xpTrackerDOM.thisWeekBtn.textContent = 'Today';
            }
        }
    }

    function updateDateDisplay() {
        const trackerData = getXPTrackerData();
        if (xpTrackerDOM.currentWeekDisplay) { // Check if DOM elements are populated
            const currentMonday = parseYYYYMMDDToLocalDate(trackerData.currentWeekStartDate);
            if (trackerData.viewMode === 'week') {
                const weekEndDate = new Date(currentMonday);
                weekEndDate.setDate(currentMonday.getDate() + 6);
                const options = { month: 'short', day: 'numeric' };
                xpTrackerDOM.currentWeekDisplay.textContent = `${currentMonday.toLocaleDateString(undefined, options)} - ${weekEndDate.toLocaleDateString(undefined, options)}`;
                xpTrackerDOM.weekCountDisplay.textContent = `Year Week: ${getWeekNumber(currentMonday)}`;
            } else {
                const selectedDate = new Date(currentMonday);
                const currentDayIndex = (typeof trackerData.selectedDayIndex === 'number' && trackerData.selectedDayIndex >= 0 && trackerData.selectedDayIndex <=6) ? trackerData.selectedDayIndex : 0;
                selectedDate.setDate(selectedDate.getDate() + currentDayIndex);
                const dayDisplayOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                xpTrackerDOM.currentWeekDisplay.textContent = selectedDate.toLocaleDateString(undefined, dayDisplayOptions);
                xpTrackerDOM.weekCountDisplay.textContent = `Year Day: ${getDayOfYear(selectedDate)}`;
            }
        }
    }

    function renderWeekdayHeaders() {
        const trackerData = getXPTrackerData();
        if (xpTrackerDOM.weekdayHeaders) { // Check if DOM elements are populated
            xpTrackerDOM.weekdayHeaders.innerHTML = '<th>Area</th>';
            if (trackerData.viewMode === 'week') {
                WEEKDAYS.forEach(day => {
                    const th = document.createElement('th');
                    th.textContent = day;
                    xpTrackerDOM.weekdayHeaders.appendChild(th);
                });
            } else {
                const th = document.createElement('th');
                const dayDate = parseYYYYMMDDToLocalDate(trackerData.currentWeekStartDate);
                const currentDayIndex = (typeof trackerData.selectedDayIndex === 'number' && trackerData.selectedDayIndex >= 0 && trackerData.selectedDayIndex <=6) ? trackerData.selectedDayIndex : 0;
                dayDate.setDate(dayDate.getDate() + currentDayIndex);
                th.textContent = `${WEEKDAYS[currentDayIndex]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;
                xpTrackerDOM.weekdayHeaders.appendChild(th);
            }
        }
    }

    function renderGrid() {
        const trackerData = getXPTrackerData();
        if (!xpTrackerDOM.gridBody) return; // Ensure DOM is ready

        xpTrackerDOM.gridBody.innerHTML = '';
        trackerData.areas.forEach(area => {
            const tr = document.createElement('tr');
            tr.dataset.areaName = area.name;

            const nameTd = document.createElement('td');
            nameTd.className = 'area-name-cell';
            const currentXP = area.xp;
            const xpToNext = xpForNextLevel(area.level);
            const percentage = xpToNext > 0 ? Math.min((currentXP / xpToNext) * 100, 100) : (currentXP > 0 ? 100 : 0);

            nameTd.innerHTML = `
                <div class="area-name-wrapper">
                    <span>${decodeHtmlEntities(area.name)}</span>
                    <button class="xp-button delete-area-btn" data-area-name="${area.name}" title="Delete ${decodeHtmlEntities(area.name)}">X</button>
                </div>
                <div class="area-stats">
                    <span>Level: <span class="area-level">${area.level}</span></span>
                    <div class="xp-bar-container">
                        <div class="xp-bar" style="width: ${percentage}%;"></div>
                        <div class="xp-bar-text"><span class="area-xp">${currentXP}</span> / ${xpToNext} XP</div>
                    </div>
                </div>`;
            tr.appendChild(nameTd);

            const renderCellContent = (td, areaName, dayIdx) => {
                const achievementsKey = `${trackerData.currentWeekStartDate}_${areaName}_${dayIdx}`;
                const cellAchievements = trackerData.achievements[achievementsKey] || [];
                cellAchievements.forEach(ach => {
                    const achDiv = document.createElement('div');
                    achDiv.className = 'achievement-item';
                    achDiv.dataset.achId = ach.id;
                    achDiv.dataset.achKey = achievementsKey;

                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'achievement-content';
                    if (ach.type === 'text') {
                        contentDiv.textContent = decodeHtmlEntities(ach.content);
                    } else if (ach.type === 'image') {
                        const img = document.createElement('img');
                        img.src = ach.content;
                        img.alt = "Achievement Image";
                        contentDiv.appendChild(img);
                    }
                    achDiv.appendChild(contentDiv);

                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'achievement-item-actions';
                    actionsDiv.innerHTML = `
                        <button class="xp-button xp-button-small edit-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Edit">Edit</button>
                        <button class="xp-button xp-button-small remove-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Delete">Delete</button>
                    `;
                    achDiv.appendChild(actionsDiv);
                    let titleText = `XP: ${ach.xp} | Added: ${new Date(ach.timestamp).toLocaleString()}`;
                    if (ach.scheduledDate) {
                        titleText += ` | Scheduled: ${ach.scheduledDate}`;
                        titleText += ach.xpAwarded ? ' (XP Awarded)' : ' (XP Pending)';
                    }
                    achDiv.title = titleText;
                    td.appendChild(achDiv);
                });

                const addAchBtn = document.createElement('button');
                addAchBtn.className = 'xp-button achievement-add-btn-cell';
                addAchBtn.textContent = '+';
                addAchBtn.dataset.areaName = areaName;
                addAchBtn.dataset.dayIndex = dayIdx;
                const dayDate = parseYYYYMMDDToLocalDate(trackerData.currentWeekStartDate);
                dayDate.setDate(dayDate.getDate() + dayIdx);
                addAchBtn.title = `Add achievement to ${decodeHtmlEntities(areaName)} on ${WEEKDAYS[dayIdx]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;
                td.appendChild(addAchBtn);
            };

            if (trackerData.viewMode === 'week') {
                WEEKDAYS.forEach((day, dayIndex) => {
                    const td = document.createElement('td');
                    td.dataset.areaName = area.name;
                    td.dataset.dayIndex = dayIndex;
                    renderCellContent(td, area.name, dayIndex);
                    tr.appendChild(td);
                });
            } else {
                const dayIndex = (typeof trackerData.selectedDayIndex === 'number' && trackerData.selectedDayIndex >= 0 && trackerData.selectedDayIndex <=6) ? trackerData.selectedDayIndex : 0;
                const td = document.createElement('td');
                td.dataset.areaName = area.name;
                td.dataset.dayIndex = dayIndex;
                renderCellContent(td, area.name, dayIndex);
                tr.appendChild(td);
            }
            xpTrackerDOM.gridBody.appendChild(tr);
        });
    }

    function saveNewArea() {
        const trackerData = getXPTrackerData();
        const name = xpTrackerDOM.newAreaNameInput.value.trim();
        if (!name) {
            alert("Area name cannot be empty.");
            return;
        }
        if (trackerData.areas.find(a => a.name.toLowerCase() === name.toLowerCase())) {
            alert("Area with this name already exists.");
            return;
        }
        trackerData.areas.push({ name: name, level: 1, xp: 0 });
        xpTrackerDOM.newAreaNameInput.value = '';
        window.closeModal('newAreaModal');
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded(true);
        window.saveData();
    }

    function promptRemoveArea(areaName) {
        xpTrackerDOM.confirmRemoveAreaMessage.textContent = `Are you sure you want to remove the area "${decodeHtmlEntities(areaName)}"? This action cannot be undone and will delete all associated achievements and quests.`;
        xpTrackerDOM.confirmRemoveBtn.dataset.areaNameToRemove = areaName;
        window.openModal('confirmRemoveAreaModal');
    }

    function removeArea(areaName) {
        const trackerData = getXPTrackerData();
        trackerData.areas = trackerData.areas.filter(area => area.name !== areaName);
        const achievementKeysToDelete = [];
        for (const key in trackerData.achievements) {
            if (trackerData.achievements.hasOwnProperty(key)) {
                const parts = key.split('_');
                const keyAreaName = parts.slice(1, parts.length -1).join('_');
                if (keyAreaName === areaName) {
                    achievementKeysToDelete.push(key);
                }
            }
        }
        achievementKeysToDelete.forEach(key => delete trackerData.achievements[key]);

        for (const weekId in trackerData.quests) {
            if (trackerData.quests.hasOwnProperty(weekId)) {
                trackerData.quests[weekId] = trackerData.quests[weekId].filter(quest => quest.areaName !== areaName);
            }
        }
        generateQuestsForCurrentWeekIfNeeded(true);
        updateDateDisplay();
        renderWeekdayHeaders();
        renderGrid();
        window.saveData();
    }

    function openAddEditAchievementModal(areaName, dayIndex, achievementKeyToEdit = null, achievementIdToEdit = null) {
        const trackerData = getXPTrackerData();
        xpTrackerDOM.achievementImageInput.value = null;
        xpTrackerDOM.achievementTextInput.value = '';
        xpTrackerDOM.editingAchievementKeyInput.value = '';
        xpTrackerDOM.editingAchievementIdInput.value = '';

        if (achievementKeyToEdit && achievementIdToEdit) {
            const achievementsInCell = trackerData.achievements[achievementKeyToEdit];
            const achievementToEdit = achievementsInCell ? achievementsInCell.find(ach => ach.id === achievementIdToEdit) : null;
            if (!achievementToEdit) {
                alert("Error: Could not find achievement to edit.");
                return;
            }
            const keyParts = achievementKeyToEdit.split('_');
            const currentAreaName = keyParts.slice(1, keyParts.length -1).join('_');
            const currentDayIndex = parseInt(keyParts[keyParts.length -1]);

            xpTrackerDOM.achievementAreaNameInput.value = currentAreaName;
            xpTrackerDOM.achievementDayIndexInput.value = currentDayIndex;
            xpTrackerDOM.editingAchievementKeyInput.value = achievementKeyToEdit;
            xpTrackerDOM.editingAchievementIdInput.value = achievementIdToEdit;
            xpTrackerDOM.addEditAchievementModalTitle.textContent = "Edit Achievement";
            xpTrackerDOM.saveAchievementBtn.textContent = "Update Achievement";

            if (achievementToEdit.type === 'text') {
                xpTrackerDOM.achievementTypeRadios[0].checked = true;
                xpTrackerDOM.achievementTextInput.value = decodeHtmlEntities(achievementToEdit.content);
            } else if (achievementToEdit.type === 'image') {
                xpTrackerDOM.achievementTypeRadios[1].checked = true;
            }
        } else {
            xpTrackerDOM.achievementAreaNameInput.value = areaName;
            xpTrackerDOM.achievementDayIndexInput.value = dayIndex;
            xpTrackerDOM.addEditAchievementModalTitle.textContent = "Add Achievement";
            xpTrackerDOM.saveAchievementBtn.textContent = "Save Achievement";
            xpTrackerDOM.achievementTypeRadios[0].checked = true;
        }
        toggleAchievementInputType();
        window.openModal('addEditAchievementModal');
        if(xpTrackerDOM.achievementTypeRadios[0].checked) xpTrackerDOM.achievementTextInput.focus();
    }

    function toggleAchievementInputType() {
        if (xpTrackerDOM.achievementTypeRadios[0].checked) {
            xpTrackerDOM.textInputDiv.style.display = 'block';
            xpTrackerDOM.imageInputDiv.style.display = 'none';
        } else {
            xpTrackerDOM.textInputDiv.style.display = 'none';
            xpTrackerDOM.imageInputDiv.style.display = 'block';
        }
    }
    
    function getAchievementDate(weekStartDateStr, dayIdx) {
        const achievementDate = parseYYYYMMDDToLocalDate(weekStartDateStr);
        achievementDate.setDate(achievementDate.getDate() + dayIdx);
        return achievementDate;
    }

    function saveOrUpdateAchievement() {
        const trackerData = getXPTrackerData();
        const areaName = xpTrackerDOM.achievementAreaNameInput.value;
        const dayIndex = parseInt(xpTrackerDOM.achievementDayIndexInput.value);
        const type = document.querySelector('input[name="achievementType"]:checked').value;
        const editingKey = xpTrackerDOM.editingAchievementKeyInput.value;
        const editingId = xpTrackerDOM.editingAchievementIdInput.value;
        const isEditing = editingKey && editingId;

        let achievement;
        const achievementsKey = isEditing ? editingKey : `${trackerData.currentWeekStartDate}_${areaName}_${dayIndex}`;
        if (!trackerData.achievements[achievementsKey] && !isEditing) {
            trackerData.achievements[achievementsKey] = [];
        }
        let achievementList = trackerData.achievements[achievementsKey] || [];

        if (isEditing) {
            achievement = achievementList.find(ach => ach.id === editingId);
            if (!achievement) {
                alert("Error: Could not find achievement to update.");
                return;
            }
        } else {
            achievement = {
                id: Date.now() + '-' + Math.random().toString(36).substring(2, 9),
                timestamp: new Date().toISOString(),
                xp: XP_PER_REGULAR_ACHIEVEMENT,
                scheduledDate: getAchievementDate(trackerData.currentWeekStartDate, dayIndex).toISOString().split('T')[0],
                xpAwarded: false
            };
        }
        achievement.type = type;

        const processSave = (contentToSave) => {
            achievement.content = contentToSave;
            if (isEditing) {
                // If editing an already awarded achievement, no XP change unless content implies re-evaluation (not handled here)
            } else {
                achievementList.push(achievement);
                const today = new Date();
                today.setHours(0,0,0,0);
                const achievementScheduledDateObj = parseYYYYMMDDToLocalDate(achievement.scheduledDate);

                if (achievementScheduledDateObj && achievementScheduledDateObj <= today) {
                    addXpToArea(areaName, achievement.xp);
                    updateQuestProgress(areaName, achievement.xp);
                    achievement.xpAwarded = true;
                } else {
                    achievement.xpAwarded = false;
                }
            }
            window.closeModal('addEditAchievementModal');
            renderGrid();
            window.saveData();
        };

        if (type === 'text') {
            const textContent = xpTrackerDOM.achievementTextInput.value.trim();
            if (!textContent) {
                alert("Achievement description cannot be empty.");
                return;
            }
            processSave(textContent);
        } else if (type === 'image') {
            const file = xpTrackerDOM.achievementImageInput.files[0];
            if (file) {
                if (file.size > 2 * 1024 * 1024) { // 2MB limit for image
                    alert("Image file is too large. Please choose an image under 2MB.");
                    return;
                }
                const reader = new FileReader();
                reader.onloadend = function() {
                    processSave(reader.result);
                }
                reader.onerror = function() { alert("Error reading image file."); }
                reader.readAsDataURL(file);
            } else if (isEditing && achievement.type === 'image' && achievement.content) {
                // No new file selected during edit, keep existing image
                processSave(achievement.content);
            } else if (!isEditing || (isEditing && achievement.type !== 'image')) {
                alert("Please select an image file for an image type achievement.");
                return;
            }
        }
    }

    function promptRemoveAchievement(achievementKey, achievementId) {
        xpTrackerDOM.confirmDeleteAchievementBtn.dataset.achievementKey = achievementKey;
        xpTrackerDOM.confirmDeleteAchievementBtn.dataset.achievementId = achievementId;
        window.openModal('confirmDeleteAchievementModal');
    }

    function confirmRemoveAchievement(achievementKey, achievementId) {
        const trackerData = getXPTrackerData();
        if (!trackerData.achievements[achievementKey]) return;

        const achIndex = trackerData.achievements[achievementKey].findIndex(ach => ach.id === achievementId);
        if (achIndex === -1) return;

        const achievementToRemove = trackerData.achievements[achievementKey][achIndex];
        const xpToRemove = achievementToRemove.xp;
        const keyParts = achievementKey.split('_');
        const areaName = keyParts.slice(1, keyParts.length -1).join('_');

        trackerData.achievements[achievementKey].splice(achIndex, 1);
        if (trackerData.achievements[achievementKey].length === 0) {
            delete trackerData.achievements[achievementKey];
        }

        if (achievementToRemove.xpAwarded) {
            subtractXpFromArea(areaName, xpToRemove);
            updateQuestProgress(areaName, -xpToRemove); // Negative XP to reverse progress
        }
        window.closeModal('confirmDeleteAchievementModal');
        renderGrid();
        window.saveData();
    }

    function xpForNextLevel(currentLevel) {
        if (currentLevel <= 0) return 50; // Should not happen if level starts at 1
        return Math.floor(50 * Math.pow(currentLevel, 1.5));
    }

    function addXpToArea(areaName, xpAmount) {
        const trackerData = getXPTrackerData();
        const area = trackerData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp += xpAmount;
            let leveledUp = false;
            let requiredForNext = xpForNextLevel(area.level);
            while (area.xp >= requiredForNext && requiredForNext > 0) { // requiredForNext > 0 to prevent infinite loop if xpForNextLevel calculation is flawed
                area.xp -= requiredForNext;
                area.level++;
                leveledUp = true;
                requiredForNext = xpForNextLevel(area.level);
            }
            if (leveledUp) {
                alert(`${decodeHtmlEntities(area.name)} leveled up to Level ${area.level}!`);
                generateQuestsForCurrentWeekIfNeeded(true); // Regenerate quests as area level changed
            }
        }
    }
    
    function subtractXpFromArea(areaName, xpAmount) {
        const trackerData = getXPTrackerData();
        const area = trackerData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp -= xpAmount;
            let deLeveled = false;
            while (area.xp < 0) {
                if (area.level > 1) {
                    area.level--;
                    deLeveled = true;
                    area.xp += xpForNextLevel(area.level); // Add XP of the new, lower level's requirement
                } else {
                    area.xp = 0; // Cannot go below 0 XP at level 1
                    break;
                }
            }
             if (deLeveled) {
                 generateQuestsForCurrentWeekIfNeeded(true);
            }
        }
    }

    function generateQuestsForCurrentWeekIfNeeded(forceRegenerate = false) {
        const trackerData = getXPTrackerData();
        const weekId = getCurrentWeekId();
        if (!trackerData.quests) trackerData.quests = {};
        if (!trackerData.quests[weekId] || forceRegenerate) {
            trackerData.quests[weekId] = [];
        }

        if (trackerData.areas.length < 1 && !forceRegenerate) {
            if(trackerData.quests[weekId].length === 0) return; // No areas, no auto quests
        }
        
        if (forceRegenerate || (trackerData.quests[weekId].length === 0 && trackerData.areas.length > 0)) {
            if (forceRegenerate) trackerData.quests[weekId] = []; // Clear existing if forcing

            const questsToPotentiallyGenerate = Math.min(MAX_WEEKLY_QUESTS, trackerData.areas.length, 3); // Generate up to 3 or num areas or MAX_QUESTS
            let generatedCount = 0;

            const availableAreasForNewQuests = [...trackerData.areas].filter(area =>
                forceRegenerate || !trackerData.quests[weekId].some(q => q.areaName === area.name)
            );
            
            let shuffledAreas = [...(availableAreasForNewQuests.length > 0 ? availableAreasForNewQuests : trackerData.areas)];
            for (let i = shuffledAreas.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledAreas[i], shuffledAreas[j]] = [shuffledAreas[j], shuffledAreas[i]];
            }

            for (let i = 0; i < questsToPotentiallyGenerate && trackerData.quests[weekId].length < MAX_WEEKLY_QUESTS; i++) {
                if (shuffledAreas.length === 0) break; 
                const selectedArea = shuffledAreas.pop(); 
                if (!selectedArea) continue;

                if(!forceRegenerate && trackerData.quests[weekId].some(q => q.areaName === selectedArea.name)) continue;

                const targetXPEarned = 20 + (selectedArea.level * 10);
                const rewardXP = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5);
                trackerData.quests[weekId].push({
                    id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}_${i}`,
                    areaName: selectedArea.name,
                    description: `Earn ${targetXPEarned} XP in "${decodeHtmlEntities(selectedArea.name)}" this week.`,
                    targetXPEarned: targetXPEarned,
                    currentXPEarned: 0,
                    rewardXP: rewardXP,
                    completed: false
                });
                generatedCount++;
            }
        }
    }

    function updateQuestProgress(areaName, xpGained) {
        const trackerData = getXPTrackerData();
        const weekId = getCurrentWeekId();
        if (!trackerData.quests || !trackerData.quests[weekId]) return;

        let questCompletedThisUpdate = false;
        trackerData.quests[weekId].forEach(quest => {
            if (quest.areaName === areaName && !quest.completed) {
                quest.currentXPEarned += xpGained;
                if (quest.currentXPEarned < 0) quest.currentXPEarned = 0; 

                if (quest.currentXPEarned >= quest.targetXPEarned) {
                    quest.completed = true;
                    quest.currentXPEarned = quest.targetXPEarned; 
                    addXpToArea(quest.areaName, quest.rewardXP); 
                    alert(`Quest Completed: ${decodeHtmlEntities(quest.description)}\n+${quest.rewardXP} XP to ${decodeHtmlEntities(quest.areaName)}!`);
                    questCompletedThisUpdate = true;
                }
            }
        });
        if (questCompletedThisUpdate) {
            renderGrid(); 
            window.saveData();
        }
    }

    function showQuests() {
        const trackerData = getXPTrackerData();
        const weekId = getCurrentWeekId();
        xpTrackerDOM.questsList.innerHTML = '';
        generateQuestsForCurrentWeekIfNeeded(); 

        const currentQuests = trackerData.quests[weekId] || [];

        if (currentQuests.length === 0) {
            xpTrackerDOM.questsList.innerHTML = `<p>No quests available for this week.${trackerData.areas.length === 0 ? ' Add some areas first to generate quests!' : ' You can create new quests manually.'}</p>`;
        } else {
            currentQuests.forEach(quest => {
                const questDiv = document.createElement('div');
                questDiv.className = 'quest-item';
                if (quest.completed) {
                    questDiv.classList.add('completed');
                }

                const title = document.createElement('div');
                title.className = 'quest-title';
                title.textContent = `Quest for: ${decodeHtmlEntities(quest.areaName)}`;

                const details = document.createElement('div');
                details.className = 'quest-details';
                details.textContent = decodeHtmlEntities(quest.description);

                const progress = document.createElement('div');
                progress.className = 'quest-progress';
                progress.textContent = `Progress: ${Math.min(quest.currentXPEarned, quest.targetXPEarned)} / ${quest.targetXPEarned} XP. Reward: ${quest.rewardXP} XP.`;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'quest-actions';
                if (!quest.completed) {
                    const refreshBtn = document.createElement('button');
                    refreshBtn.className = 'xp-button xp-button-small refresh-quest-btn';
                    refreshBtn.dataset.questId = quest.id;
                    refreshBtn.textContent = 'Refresh';
                    actionsDiv.appendChild(refreshBtn);
                }

                questDiv.appendChild(title);
                questDiv.appendChild(details);
                questDiv.appendChild(progress);
                questDiv.appendChild(actionsDiv);
                xpTrackerDOM.questsList.appendChild(questDiv);
            });
        }
        xpTrackerDOM.addQuestBtn.disabled = currentQuests.length >= MAX_WEEKLY_QUESTS;
        window.openModal('questsModal');
    }
    
    function openCreateQuestModal() {
        const trackerData = getXPTrackerData();
        const weekId = getCurrentWeekId();
        if (trackerData.quests[weekId] && trackerData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Maximum of ${MAX_WEEKLY_QUESTS} quests per week reached.`);
            return;
        }
        if (trackerData.areas.length === 0) {
            alert("Please create at least one Area before adding quests.");
            return;
        }

        xpTrackerDOM.newQuestAreaNameSelect.innerHTML = '';
        trackerData.areas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.name;
            option.textContent = decodeHtmlEntities(area.name);
            xpTrackerDOM.newQuestAreaNameSelect.appendChild(option);
        });
        xpTrackerDOM.newQuestDescriptionInput.value = '';
        xpTrackerDOM.newQuestTargetXPInput.value = 30;
        xpTrackerDOM.newQuestRewardXPInput.value = 50;
        window.openModal('createQuestModal');
    }

    function saveNewQuest() {
        const trackerData = getXPTrackerData();
        const weekId = getCurrentWeekId();
        if (!trackerData.quests[weekId]) trackerData.quests[weekId] = [];

        if (trackerData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Cannot add new quest: Maximum of ${MAX_WEEKLY_QUESTS} quests reached for this week.`);
            return;
        }

        const areaName = xpTrackerDOM.newQuestAreaNameSelect.value;
        const description = xpTrackerDOM.newQuestDescriptionInput.value.trim();
        const targetXP = parseInt(xpTrackerDOM.newQuestTargetXPInput.value);
        const rewardXP = parseInt(xpTrackerDOM.newQuestRewardXPInput.value);

        if (!areaName) { alert("Please select an area."); return; }
        if (!description) { alert("Please enter a description."); return; }
        if (isNaN(targetXP) || targetXP <= 0) { alert("Target XP must be a positive number."); return; }
        if (isNaN(rewardXP) || rewardXP <= 0) { alert("Reward XP must be a positive number."); return; }

        const newQuest = {
            id: `quest_${weekId}_${areaName.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName: areaName,
            description: description,
            targetXPEarned: targetXP,
            currentXPEarned: 0,
            rewardXP: rewardXP,
            completed: false
        };
        trackerData.quests[weekId].push(newQuest);
        window.closeModal('createQuestModal');
        showQuests(); 
        window.saveData();
    }
    
    function promptRefreshQuest(questId) {
        xpTrackerDOM.confirmRefreshQuestBtn.dataset.questIdToRefresh = questId;
        window.openModal('confirmRefreshQuestModal');
    }

    function generateSingleRandomQuest(weekId, questToReplace = null) {
        const trackerData = getXPTrackerData();
        if (trackerData.areas.length === 0) return null;

        let potentialAreas = [...trackerData.areas];
        if (questToReplace && potentialAreas.length > 1) {
            const filteredAreas = potentialAreas.filter(a => a.name !== questToReplace.areaName);
            if (filteredAreas.length > 0) {
                potentialAreas = filteredAreas;
            }
        }
        if(potentialAreas.length === 0) potentialAreas = [...trackerData.areas]; 

        const randomAreaIndex = Math.floor(Math.random() * potentialAreas.length);
        const selectedArea = potentialAreas[randomAreaIndex];

        const baseTarget = 20 + (selectedArea.level * 10); 
        const targetXPEarned = Math.max(10, Math.round(baseTarget + (Math.random() * baseTarget * 0.3) - (baseTarget * 0.15)) ); 
        const baseReward = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5);
        const rewardXP = Math.max(10, Math.round(baseReward + (Math.random() * baseReward * 0.2) - (baseReward * 0.1))); 

        return {
            id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName: selectedArea.name,
            description: `Earn ${targetXPEarned} XP in "${decodeHtmlEntities(selectedArea.name)}" this week. (Refreshed)`,
            targetXPEarned: targetXPEarned,
            currentXPEarned: 0,
            rewardXP: rewardXP,
            completed: false
        };
    }
    
    function confirmAndRefreshQuest() {
        const trackerData = getXPTrackerData();
        const questIdToRefresh = xpTrackerDOM.confirmRefreshQuestBtn.dataset.questIdToRefresh;
        const weekId = getCurrentWeekId();

        if (!questIdToRefresh || !trackerData.quests[weekId]) {
            window.closeModal('confirmRefreshQuestModal');
            return;
        }
        const questIndex = trackerData.quests[weekId].findIndex(q => q.id === questIdToRefresh);
        if (questIndex === -1) {
            window.closeModal('confirmRefreshQuestModal');
            return;
        }
        const oldQuest = trackerData.quests[weekId][questIndex];
        trackerData.quests[weekId].splice(questIndex, 1); 
        const newQuest = generateSingleRandomQuest(weekId, oldQuest); 

        if (newQuest) {
            trackerData.quests[weekId].push(newQuest);
        } else if (trackerData.areas.length > 0) {
            alert("Could not generate a new quest. Try again or create one manually.");
        }
        window.closeModal('confirmRefreshQuestModal');
        showQuests(); 
        window.saveData();
    }

    function setupXPTrackerApp() {
        // This function is called by the main OS after the app's HTML (templates) are loaded.
        // The templates are already in the DOM. Now, populate the window body.
        const windowBody = getById('xpMainWindowBody');
        const bodyContentTemplate = document.getElementById('xpTrackerBodyContentTemplate');

        if (windowBody && bodyContentTemplate) {
            windowBody.innerHTML = ''; // Clear placeholder
            windowBody.appendChild(bodyContentTemplate.content.cloneNode(true));
        } else {
            console.error("XP Tracker window body or content template not found during setup.");
            return;
        }
        
        // Register with OS appRegistry
        if (!window.appRegistry) window.appRegistry = {};
        window.appRegistry[APP_ID] = {
            minWidth: MIN_WIDTH_WEEK_VIEW, // Initial default
            minHeight: MIN_HEIGHT,
            appName: "XP Tracker"
            // Apps could also register a 'resizeCallback' or 'openCallback' here
        };
        
        // Initialize the app specific logic AFTER DOM elements are in place
        initXPTrackerApp();
    }

    // Make setup function globally available for the OS to call
    window.setupXPTrackerApp = setupXPTrackerApp;

})();
</script>
