<body data-app-id="xpTracker">

    <template id="xpTracker-icon-template">
        <div class="icon-image">âœ…</div>
        <div class="icon-label">XP Tracker</div>
    </template>

    <template id="xpTracker-window-template">
        <div class="xp-window" id="xpTrackerWindow" style="display:none;">
            <div class="title-bar">
                <span class="title-bar-text">XP Tracker</span>
                <div class="title-bar-controls">
                    <button data-app-action="minimize" title="Minimize">0</button>
                    <button data-app-action="maximize" title="Maximize">1</button>
                    <button data-app-action="close" title="Close">r</button>
                </div>
            </div>
            <div class="window-body" style="padding: 15px; overflow-y: auto;">
                <div class="controls-bar" id="xpTrackerControlsBar">
                    <div class="week-navigation">
                        <button id="xpTrackerPrevWeekBtn" class="xp-button">&lt; Prev Week</button>
                        <button id="xpTrackerThisWeekBtn" class="xp-button">This Week</button>
                        <button id="xpTrackerNextWeekBtn" class="xp-button">Next Week &gt;</button>
                    </div>
                    <div class="controls-group">
                        <span id="xpTrackerCurrentWeekDisplay">Week X</span>
                        <span id="xpTrackerWeekCountDisplay">Year Week: XX</span>
                    </div>
                    <div class="global-actions">
                        <button id="xpTrackerToggleViewBtn" class="xp-button">Day View</button>
                        <button id="xpTrackerShowQuestsBtn" class="xp-button">Weekly Quests</button>
                        <button id="xpTrackerAddAreaBtn" class="xp-button">New Area</button>
                    </div>
                </div>
                <table id="xpTrackerGridTable" style="width: 100%; border-collapse: collapse; margin-top: 10px; table-layout: fixed;">
                    <thead>
                        <tr id="xpTrackerWeekdayHeaders">
                            <th>Area</th>
                        </tr>
                    </thead>
                    <tbody id="xpTrackerGridBody">
                    </tbody>
                </table>
            </div>
            <div class="resize-handle"></div>

            <div id="xpTrackerNewAreaModal" class="modal">
                <div class="modal-content">
                    <div class="modal-title-bar"><span id="xpTrackerNewAreaModalTitle">Create New Area</span><span class="close-button" data-modal-id="xpTrackerNewAreaModal">r</span></div>
                    <div class="modal-body">
                        <label for="xpTrackerNewAreaName">Area Name:</label><input type="text" id="xpTrackerNewAreaName" placeholder="e.g., Fitness, Learning, Work">
                    </div>
                    <div class="modal-footer"><button id="xpTrackerSaveNewAreaBtn" class="xp-button">Save</button><button class="xp-button" data-modal-id="xpTrackerNewAreaModal">Cancel</button></div>
                </div>
            </div>
            <div id="xpTrackerAddEditAchievementModal" class="modal">
                <div class="modal-content">
                    <div class="modal-title-bar"><span id="xpTrackerAddEditAchievementModalTitle">Add Achievement</span><span class="close-button" data-modal-id="xpTrackerAddEditAchievementModal">r</span></div>
                    <div class="modal-body">
                        <input type="hidden" id="xpTrackerAchievementAreaName"><input type="hidden" id="xpTrackerAchievementDayIndex">
                        <input type="hidden" id="xpTrackerEditingAchievementKey"><input type="hidden" id="xpTrackerEditingAchievementId">
                        <label>Type:</label> <input type="radio" name="xpTrackerAchievementType" value="text" id="xpTrackerTypeText" checked> Text <input type="radio" name="xpTrackerAchievementType" value="image" id="xpTrackerTypeImage"> Image <br><br>
                        <div id="xpTrackerTextInputDiv"><label for="xpTrackerAchievementText">Description:</label><textarea id="xpTrackerAchievementText" rows="3"></textarea></div>
                        <div id="xpTrackerImageInputDiv" style="display:none;"><label for="xpTrackerAchievementImage">Upload Image:</label><input type="file" id="xpTrackerAchievementImage" accept="image/*"><p><small>Current image will be kept if no new image is selected.</small></p></div>
                    </div>
                    <div class="modal-footer"><button id="xpTrackerSaveAchievementBtn" class="xp-button">Save Achievement</button><button class="xp-button" data-modal-id="xpTrackerAddEditAchievementModal">Cancel</button></div>
                </div>
            </div>
            <div id="xpTrackerQuestsModal" class="modal">
                <div class="modal-content">
                    <div class="modal-title-bar"><span>Weekly Quests</span><span class="close-button" data-modal-id="xpTrackerQuestsModal">r</span></div>
                    <div class="modal-body" id="xpTrackerQuestsList"></div>
                    <div class="modal-footer"><button id="xpTrackerAddQuestBtn" class="xp-button">Create New Quest</button><button class="xp-button" data-modal-id="xpTrackerQuestsModal">Close</button></div>
                </div>
            </div>
            <div id="xpTrackerConfirmRemoveAreaModal" class="modal">
                <div class="modal-content">
                    <div class="modal-title-bar"><span>Confirm Deletion</span><span class="close-button" data-modal-id="xpTrackerConfirmRemoveAreaModal">r</span></div>
                    <div class="modal-body"><p id="xpTrackerConfirmRemoveAreaMessage">Are you sure?</p></div>
                    <div class="modal-footer"><button id="xpTrackerConfirmRemoveBtn" class="xp-button">Confirm</button><button class="xp-button" data-modal-id="xpTrackerConfirmRemoveAreaModal">Cancel</button></div>
                </div>
            </div>
            <div id="xpTrackerConfirmDeleteAchievementModal" class="modal">
                <div class="modal-content">
                    <div class="modal-title-bar"><span>Confirm Achievement Deletion</span><span class="close-button" data-modal-id="xpTrackerConfirmDeleteAchievementModal">r</span></div>
                    <div class="modal-body"><p>Are you sure you want to delete this achievement? This will deduct its XP if it was awarded.</p></div>
                    <div class="modal-footer"><button id="xpTrackerConfirmDeleteAchievementBtn" class="xp-button">Delete</button><button class="xp-button" data-modal-id="xpTrackerConfirmDeleteAchievementModal">Cancel</button></div>
                </div>
            </div>
            <div id="xpTrackerCreateQuestModal" class="modal">
                <div class="modal-content">
                    <div class="modal-title-bar"><span>Create New Quest</span><span class="close-button" data-modal-id="xpTrackerCreateQuestModal">r</span></div>
                    <div class="modal-body">
                        <label for="xpTrackerNewQuestAreaName">Area:</label><select id="xpTrackerNewQuestAreaName"></select>
                        <label for="xpTrackerNewQuestDescription">Description:</label><textarea id="xpTrackerNewQuestDescription" rows="2" placeholder="e.g., Read 2 chapters"></textarea>
                        <label for="xpTrackerNewQuestTargetXP">Target XP to Earn in Area for Quest:</label><input type="number" id="xpTrackerNewQuestTargetXP" min="1" value="30">
                        <label for="xpTrackerNewQuestRewardXP">Quest Reward XP:</label><input type="number" id="xpTrackerNewQuestRewardXP" min="1" value="50">
                    </div>
                    <div class="modal-footer"><button id="xpTrackerSaveNewQuestBtn" class="xp-button">Save Quest</button><button class="xp-button" data-modal-id="xpTrackerCreateQuestModal">Cancel</button></div>
                </div>
            </div>
            <div id="xpTrackerConfirmRefreshQuestModal" class="modal">
                <div class="modal-content">
                    <div class="modal-title-bar"><span>Confirm Quest Refresh</span><span class="close-button" data-modal-id="xpTrackerConfirmRefreshQuestModal">r</span></div>
                    <div class="modal-body"><p>Are you sure you want to refresh this quest? Current progress will be lost.</p></div>
                    <div class="modal-footer"><button id="xpTrackerConfirmRefreshQuestBtn" class="xp-button">Refresh Quest</button><button class="xp-button" data-modal-id="xpTrackerConfirmRefreshQuestModal">Cancel</button></div>
                </div>
            </div>
        </div>
    </template>
    
    <script type="application/json" id="xpTracker-config">
    {
        "minWidth": 750,
        "minHeight": 400,
        "defaultWidth": 905,
        "defaultHeight": 705,
        "defaultOffsetX": 20,
        "defaultOffsetY": 20
    }
    </script>

    <script id="xpTracker-script">
    const appWindow = this.appWindow; // 'this' is bound by the Function constructor in index.html
    const appData = this.appData; // This will be the app-specific part of osData
    const os = this.os; // API provided by index.html

    const WEEKDAYS = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    const XP_PER_REGULAR_ACHIEVEMENT = 10;
    const XP_PER_QUEST_COMPLETED_BASE = 50;
    const MAX_WEEKLY_QUESTS = 5;
    let minTrackerAppWidth = 750; 
    const MIN_TRACKER_APP_HEIGHT = 250;

    const DOM = {
        xpMainWindow: appWindow,
        weekdayHeaders: appWindow.querySelector('#xpTrackerWeekdayHeaders'),
        gridBody: appWindow.querySelector('#xpTrackerGridBody'),
        addAreaBtn: appWindow.querySelector('#xpTrackerAddAreaBtn'),
        prevWeekBtn: appWindow.querySelector('#xpTrackerPrevWeekBtn'),
        nextWeekBtn: appWindow.querySelector('#xpTrackerNextWeekBtn'),
        thisWeekBtn: appWindow.querySelector('#xpTrackerThisWeekBtn'),
        toggleViewBtn: appWindow.querySelector('#xpTrackerToggleViewBtn'),
        currentWeekDisplay: appWindow.querySelector('#xpTrackerCurrentWeekDisplay'),
        weekCountDisplay: appWindow.querySelector('#xpTrackerWeekCountDisplay'),
        showQuestsBtn: appWindow.querySelector('#xpTrackerShowQuestsBtn'),
        controlsBar: appWindow.querySelector('#xpTrackerControlsBar'),
        
        newAreaModal: appWindow.querySelector('#xpTrackerNewAreaModal'),
        newAreaNameInput: appWindow.querySelector('#xpTrackerNewAreaName'),
        saveNewAreaBtn: appWindow.querySelector('#xpTrackerSaveNewAreaBtn'),
        
        addEditAchievementModal: appWindow.querySelector('#xpTrackerAddEditAchievementModal'),
        addEditAchievementModalTitle: appWindow.querySelector('#xpTrackerAddEditAchievementModalTitle'),
        achievementAreaNameInput: appWindow.querySelector('#xpTrackerAchievementAreaName'),
        achievementDayIndexInput: appWindow.querySelector('#xpTrackerAchievementDayIndex'),
        editingAchievementKeyInput: appWindow.querySelector('#xpTrackerEditingAchievementKey'),
        editingAchievementIdInput: appWindow.querySelector('#xpTrackerEditingAchievementId'),
        achievementTypeRadios: appWindow.querySelectorAll('input[name="xpTrackerAchievementType"]'),
        textInputDiv: appWindow.querySelector('#xpTrackerTextInputDiv'),
        imageInputDiv: appWindow.querySelector('#xpTrackerImageInputDiv'),
        achievementTextInput: appWindow.querySelector('#xpTrackerAchievementText'),
        achievementImageInput: appWindow.querySelector('#xpTrackerAchievementImage'),
        saveAchievementBtn: appWindow.querySelector('#xpTrackerSaveAchievementBtn'),
        
        questsModal: appWindow.querySelector('#xpTrackerQuestsModal'),
        questsList: appWindow.querySelector('#xpTrackerQuestsList'),
        addQuestBtn: appWindow.querySelector('#xpTrackerAddQuestBtn'),
        
        createQuestModal: appWindow.querySelector('#xpTrackerCreateQuestModal'),
        newQuestAreaNameSelect: appWindow.querySelector('#xpTrackerNewQuestAreaName'),
        newQuestDescriptionInput: appWindow.querySelector('#xpTrackerNewQuestDescription'),
        newQuestTargetXPInput: appWindow.querySelector('#xpTrackerNewQuestTargetXP'),
        newQuestRewardXPInput: appWindow.querySelector('#xpTrackerNewQuestRewardXP'),
        saveNewQuestBtn: appWindow.querySelector('#xpTrackerSaveNewQuestBtn'),
        
        confirmRefreshQuestModal: appWindow.querySelector('#xpTrackerConfirmRefreshQuestModal'),
        confirmRefreshQuestBtn: appWindow.querySelector('#xpTrackerConfirmRefreshQuestBtn'),
        
        confirmRemoveAreaModal: appWindow.querySelector('#xpTrackerConfirmRemoveAreaModal'),
        confirmRemoveAreaMessage: appWindow.querySelector('#xpTrackerConfirmRemoveAreaMessage'),
        confirmRemoveBtn: appWindow.querySelector('#xpTrackerConfirmRemoveBtn'),
        
        confirmDeleteAchievementModal: appWindow.querySelector('#xpTrackerConfirmDeleteAchievementModal'),
        confirmDeleteAchievementBtn: appWindow.querySelector('#xpTrackerConfirmDeleteAchievementBtn'),
        
        modalCloseButtons: appWindow.querySelectorAll('.modal .close-button, .modal .xp-button[data-modal-id]')
    };
    
    function initializeDefaultAppData() {
        if (!appData.areas) appData.areas = [];
        if (!appData.achievements) appData.achievements = {};
        if (!appData.quests) appData.quests = {};
        if (!appData.currentWeekStartDate) appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        if (appData.viewMode !== 'week' && appData.viewMode !== 'day') appData.viewMode = 'week';
        if (appData.selectedDayIndex === undefined || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) appData.selectedDayIndex = 0;
    }
    initializeDefaultAppData();

    function parseYYYYMMDDToLocalDate(dateString) {
        if (!dateString || typeof dateString !== 'string') return null;
        const parts = dateString.split('-');
        if (parts.length !== 3) return null;
        const [year, month, day] = parts.map(Number);
        if (isNaN(year) || isNaN(month) || isNaN(day)) return null;
        return new Date(year, month - 1, day);
    }
    function getDayOfYear(date) {
        const startOfYear = new Date(date.getFullYear(), 0, 0);
        const diff = date - startOfYear;
        const oneDay = 1000 * 60 * 60 * 24;
        return Math.floor(diff / oneDay);
    }
     function checkAndAwardScheduledXP() {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        let xpWasAwardedThisCheck = false;
        for (const achievementsKey in appData.achievements) {
            if (appData.achievements.hasOwnProperty(achievementsKey)) {
                const achievementsInCell = appData.achievements[achievementsKey];
                const keyParts = achievementsKey.split('_');
                if (keyParts.length < 3) continue;
                const areaName = keyParts.slice(1, keyParts.length - 1).join('_');
                for (const ach of achievementsInCell) {
                    if (ach.xpAwarded === undefined) ach.xpAwarded = false;
                    if (!ach.scheduledDate) continue;
                    if (!ach.xpAwarded) {
                        const achievementScheduledDate = parseYYYYMMDDToLocalDate(ach.scheduledDate);
                        if (achievementScheduledDate && achievementScheduledDate <= today) {
                            addXpToArea(areaName, ach.xp);
                            updateQuestProgress(areaName, ach.xp);
                            ach.xpAwarded = true;
                            xpWasAwardedThisCheck = true;
                        }
                    }
                }
            }
        }
        if (xpWasAwardedThisCheck) {
            renderGrid();
            os.saveAppData();
        }
    }

    function getMonday(d) {
        d = new Date(d);
        const currentDay = d.getDay();
        const diffToMondayVal = d.getDate() - currentDay + (currentDay === 0 ? -6 : 1);
        return new Date(d.getFullYear(), d.getMonth(), diffToMondayVal);
    }
    function getWeekNumber(d) {
        d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
        d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7));
        const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
        return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }
    function getCurrentWeekId() {
        if (!appData.currentWeekStartDate) {
            appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        }
        const startDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        return `${startDate.getFullYear()}-W${String(getWeekNumber(startDate)).padStart(2, '0')}`;
    }

    function updateViewControls() {
        if (appData.viewMode === 'week') {
            DOM.toggleViewBtn.textContent = 'Day View';
            DOM.prevWeekBtn.textContent = '< Prev Week';
            DOM.nextWeekBtn.textContent = 'Next Week >';
            DOM.thisWeekBtn.textContent = 'This Week';
            minTrackerAppWidth = 750;
        } else {
            DOM.toggleViewBtn.textContent = 'Week View';
            DOM.prevWeekBtn.textContent = '< Prev Day';
            DOM.nextWeekBtn.textContent = 'Next Day >';
            DOM.thisWeekBtn.textContent = 'Today';
            minTrackerAppWidth = 375;
        }
    }
    function updateDateDisplay() {
        const currentMonday = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        if (appData.viewMode === 'week') {
            const weekEndDate = new Date(currentMonday);
            weekEndDate.setDate(currentMonday.getDate() + 6);
            const options = { month: 'short', day: 'numeric' };
            DOM.currentWeekDisplay.textContent = `${currentMonday.toLocaleDateString(undefined, options)} - ${weekEndDate.toLocaleDateString(undefined, options)}`;
            DOM.weekCountDisplay.textContent = `Year Week: ${getWeekNumber(currentMonday)}`;
        } else {
            const selectedDate = new Date(currentMonday);
            selectedDate.setDate(selectedDate.getDate() + appData.selectedDayIndex);
            const dayDisplayOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            DOM.currentWeekDisplay.textContent = selectedDate.toLocaleDateString(undefined, dayDisplayOptions);
            DOM.weekCountDisplay.textContent = `Year Day: ${getDayOfYear(selectedDate)}`;
        }
    }
    function renderWeekdayHeaders() {
        DOM.weekdayHeaders.innerHTML = '<th>Area</th>';
        if (appData.viewMode === 'week') {
            WEEKDAYS.forEach(day => {
                const th = document.createElement('th');
                th.textContent = day;
                DOM.weekdayHeaders.appendChild(th);
            });
        } else {
            const th = document.createElement('th');
            const dayDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
            dayDate.setDate(dayDate.getDate() + appData.selectedDayIndex);
            th.textContent = `${WEEKDAYS[appData.selectedDayIndex]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;
            DOM.weekdayHeaders.appendChild(th);
        }
    }
    function renderGrid() {
        DOM.gridBody.innerHTML = '';
        appData.areas.forEach(area => {
            const tr = document.createElement('tr');
            tr.dataset.areaName = area.name;
            const nameTd = document.createElement('td');
            nameTd.className = 'area-name-cell';
            nameTd.style.width = '180px'; // Ensure this style is applied
            const currentXP = area.xp;
            const xpToNext = xpForNextLevel(area.level);
            const percentage = xpToNext > 0 ? Math.min((currentXP / xpToNext) * 100, 100) : (currentXP > 0 ? 100 : 0);
            nameTd.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="font-weight: bold;">${os.decodeHtmlEntities(area.name)}</span>
                    <button class="xp-button delete-area-btn" data-area-name="${area.name}" title="Delete ${area.name}" style="padding: 1px 6px; min-width: auto; font-size: 10px; background-color: #E04343; color: white; border: 1px outset white;">X</button>
                </div>
                <div style="font-size: 0.9em; margin-top: 5px; color: #333;">
                    <span>Level: <span class="area-level">${area.level}</span></span>
                    <div style="width: 100%; height: 12px; background-color: #BDBDBD; border: 1px solid #7F7F7F; margin-top: 3px; position: relative; border-radius: 2px; overflow: hidden;">
                        <div style="height: 100%; background-color: #008000; transition: width 0.3s ease; border-radius: 1px; width: ${percentage}%;"></div>
                        <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 9px; line-height: 12px; color: white; text-shadow: 1px 1px 0px black; font-weight: bold; z-index: 1;"><span class="area-xp">${currentXP}</span> / ${xpToNext} XP</div>
                    </div>
                </div>`;
            tr.appendChild(nameTd);

            const renderCellContent = (td, areaName, dayIdx) => {
                const achievementsKey = `${appData.currentWeekStartDate}_${areaName}_${dayIdx}`;
                const cellAchievements = appData.achievements[achievementsKey] || [];
                cellAchievements.forEach(ach => {
                    const achDiv = document.createElement('div');
                    achDiv.className = 'achievement-item';
                    achDiv.style.cssText = "background-color: #FFF; border: 1px solid #DDD; padding: 8px; margin-bottom: 4px; font-size: 0.9em; border-radius: 3px; word-wrap: break-word; box-sizing: border-box; display: flex; flex-direction: column; align-items: center;";
                    achDiv.dataset.achId = ach.id;
                    achDiv.dataset.achKey = achievementsKey;
                    const contentDiv = document.createElement('div');
                    contentDiv.style.cssText = "width: 100%; text-align: center; margin-bottom: 8px;";
                    if (ach.type === 'text') {
                        contentDiv.textContent = os.decodeHtmlEntities(ach.content);
                    } else if (ach.type === 'image') {
                        const img = document.createElement('img');
                        img.src = ach.content;
                        img.alt = "Achievement Image";
                        img.style.cssText = "max-width: 100%; height: auto; display: block; margin: 0 auto; border-radius: 2px;";
                        contentDiv.appendChild(img);
                    }
                    achDiv.appendChild(contentDiv);
                    const actionsDiv = document.createElement('div');
                    actionsDiv.style.cssText = "display: flex; gap: 3px;";
                    actionsDiv.innerHTML = `
                        <button class="xp-button edit-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Edit" style="padding: 2px 5px; font-size: 10px; min-width: auto;">Edit</button>
                        <button class="xp-button remove-ach-btn" data-ach-key="${achievementsKey}" data-ach-id="${ach.id}" title="Delete" style="padding: 2px 5px; font-size: 10px; min-width: auto;">Delete</button>
                    `;
                    achDiv.appendChild(actionsDiv);
                    let titleText = `XP: ${ach.xp} | Added: ${new Date(ach.timestamp).toLocaleString()}`;
                    if (ach.scheduledDate) {
                        titleText += ` | Scheduled: ${ach.scheduledDate}`;
                        titleText += ach.xpAwarded ? ' (XP Awarded)' : ' (XP Pending)';
                    }
                    achDiv.title = titleText;
                    td.appendChild(achDiv);
                });
                const addAchBtn = document.createElement('button');
                addAchBtn.className = 'xp-button achievement-add-btn-cell';
                addAchBtn.style.cssText = "display: block; width: 99.5%; box-sizing: border-box; margin-top: 5px;";
                addAchBtn.textContent = '+';
                addAchBtn.dataset.areaName = areaName;
                addAchBtn.dataset.dayIndex = dayIdx;
                const dayDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
                dayDate.setDate(dayDate.getDate() + dayIdx);
                addAchBtn.title = `Add achievement to ${os.decodeHtmlEntities(areaName)} on ${WEEKDAYS[dayIdx]}, ${dayDate.toLocaleDateString(undefined, {month: 'short', day: 'numeric'})}`;
                td.appendChild(addAchBtn);
            };

            if (appData.viewMode === 'week') {
                WEEKDAYS.forEach((day, dayIndex) => {
                    const td = document.createElement('td');
                    td.style.cssText = "border: 1px solid #ACA899; padding: 8px; text-align: left; vertical-align: top; word-wrap: break-word;";
                    td.dataset.areaName = area.name;
                    td.dataset.dayIndex = dayIndex;
                    renderCellContent(td, area.name, dayIndex);
                    tr.appendChild(td);
                });
            } else {
                const dayIndex = appData.selectedDayIndex;
                const td = document.createElement('td');
                td.style.cssText = "border: 1px solid #ACA899; padding: 8px; text-align: left; vertical-align: top; word-wrap: break-word;";
                td.dataset.areaName = area.name;
                td.dataset.dayIndex = dayIndex;
                renderCellContent(td, area.name, dayIndex);
                tr.appendChild(td);
            }
            DOM.gridBody.appendChild(tr);
        });
    }

    function saveNewArea() {
        const name = DOM.newAreaNameInput.value.trim();
        if (!name) { alert("Area name cannot be empty."); return; }
        if (appData.areas.find(a => a.name.toLowerCase() === name.toLowerCase())) {
            alert("Area with this name already exists."); return;
        }
        appData.areas.push({ name: name, level: 1, xp: 0 });
        DOM.newAreaNameInput.value = '';
        os.closeModal(DOM.newAreaModal);
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded(true);
        os.saveAppData();
    }
    function promptRemoveArea(areaName) {
        DOM.confirmRemoveAreaMessage.textContent = `Are you sure you want to remove the area "${os.decodeHtmlEntities(areaName)}"? This action cannot be undone and will delete all associated achievements and quests.`;
        DOM.confirmRemoveBtn.dataset.areaNameToRemove = areaName;
        os.openModal(DOM.confirmRemoveAreaModal);
    }
    function removeArea(areaName) {
        appData.areas = appData.areas.filter(area => area.name !== areaName);
        const achievementKeysToDelete = [];
        for (const key in appData.achievements) {
            if (appData.achievements.hasOwnProperty(key)) {
                const parts = key.split('_');
                const keyAreaName = parts.slice(1, parts.length -1).join('_');
                if (keyAreaName === areaName) achievementKeysToDelete.push(key);
            }
        }
        achievementKeysToDelete.forEach(key => delete appData.achievements[key]);
        for (const weekId in appData.quests) {
            if (appData.quests.hasOwnProperty(weekId)) {
                appData.quests[weekId] = appData.quests[weekId].filter(quest => quest.areaName !== areaName);
            }
        }
        generateQuestsForCurrentWeekIfNeeded(true);
        updateDateDisplay(); renderWeekdayHeaders(); renderGrid();
        os.saveAppData();
    }
    function openAddEditAchievementModal(areaName, dayIndex, achievementKeyToEdit = null, achievementIdToEdit = null) {
        DOM.achievementImageInput.value = null;
        DOM.achievementTextInput.value = '';
        DOM.editingAchievementKeyInput.value = '';
        DOM.editingAchievementIdInput.value = '';
        if (achievementKeyToEdit && achievementIdToEdit) {
            const achievementsInCell = appData.achievements[achievementKeyToEdit];
            const achievementToEdit = achievementsInCell ? achievementsInCell.find(ach => ach.id === achievementIdToEdit) : null;
            if (!achievementToEdit) { alert("Error: Could not find achievement to edit."); return; }
            const keyParts = achievementKeyToEdit.split('_');
            DOM.achievementAreaNameInput.value = keyParts.slice(1, keyParts.length -1).join('_');
            DOM.achievementDayIndexInput.value = parseInt(keyParts[keyParts.length -1]);
            DOM.editingAchievementKeyInput.value = achievementKeyToEdit;
            DOM.editingAchievementIdInput.value = achievementIdToEdit;
            DOM.addEditAchievementModalTitle.textContent = "Edit Achievement";
            DOM.saveAchievementBtn.textContent = "Update Achievement";
            if (achievementToEdit.type === 'text') {
                DOM.achievementTypeRadios[0].checked = true;
                DOM.achievementTextInput.value = os.decodeHtmlEntities(achievementToEdit.content);
            } else if (achievementToEdit.type === 'image') {
                DOM.achievementTypeRadios[1].checked = true;
            }
        } else {
            DOM.achievementAreaNameInput.value = areaName;
            DOM.achievementDayIndexInput.value = dayIndex;
            DOM.addEditAchievementModalTitle.textContent = "Add Achievement";
            DOM.saveAchievementBtn.textContent = "Save Achievement";
            DOM.achievementTypeRadios[0].checked = true;
        }
        toggleAchievementInputType();
        os.openModal(DOM.addEditAchievementModal);
        if(DOM.achievementTypeRadios[0].checked) DOM.achievementTextInput.focus();
    }
    function toggleAchievementInputType() {
        if (DOM.achievementTypeRadios[0].checked) {
            DOM.textInputDiv.style.display = 'block';
            DOM.imageInputDiv.style.display = 'none';
        } else {
            DOM.textInputDiv.style.display = 'none';
            DOM.imageInputDiv.style.display = 'block';
        }
    }
    function getAchievementDate(weekStartDateStr, dayIdx) {
        const achievementDate = parseYYYYMMDDToLocalDate(weekStartDateStr);
        achievementDate.setDate(achievementDate.getDate() + dayIdx);
        return achievementDate;
    }
    function saveOrUpdateAchievement() {
        const areaName = DOM.achievementAreaNameInput.value;
        const dayIndex = parseInt(DOM.achievementDayIndexInput.value);
        const type = appWindow.querySelector('input[name="xpTrackerAchievementType"]:checked').value;
        const editingKey = DOM.editingAchievementKeyInput.value;
        const editingId = DOM.editingAchievementIdInput.value;
        const isEditing = editingKey && editingId;
        let achievement;
        const achievementsKey = isEditing ? editingKey : `${appData.currentWeekStartDate}_${areaName}_${dayIndex}`;
        if (!appData.achievements[achievementsKey] && !isEditing) appData.achievements[achievementsKey] = [];
        let achievementList = appData.achievements[achievementsKey] || [];
        if (isEditing) {
            achievement = achievementList.find(ach => ach.id === editingId);
            if (!achievement) { alert("Error: Could not find achievement to update."); return; }
        } else {
            achievement = {
                id: Date.now() + '-' + Math.random().toString(36).substring(2, 9),
                timestamp: new Date().toISOString(), xp: XP_PER_REGULAR_ACHIEVEMENT,
                scheduledDate: getAchievementDate(appData.currentWeekStartDate, dayIndex).toISOString().split('T')[0],
                xpAwarded: false
            };
        }
        achievement.type = type;
        const processSave = (contentToSave) => {
            achievement.content = contentToSave;
            if (!isEditing) {
                achievementList.push(achievement);
                const today = new Date(); today.setHours(0,0,0,0);
                const achievementScheduledDateObj = parseYYYYMMDDToLocalDate(achievement.scheduledDate);
                if (achievementScheduledDateObj && achievementScheduledDateObj <= today) {
                    addXpToArea(areaName, achievement.xp);
                    updateQuestProgress(areaName, achievement.xp);
                    achievement.xpAwarded = true;
                } else {
                    achievement.xpAwarded = false;
                }
            }
            os.closeModal(DOM.addEditAchievementModal);
            renderGrid();
            os.saveAppData();
        };
        if (type === 'text') {
            const textContent = DOM.achievementTextInput.value.trim();
            if (!textContent) { alert("Achievement description cannot be empty."); return; }
            processSave(textContent);
        } else if (type === 'image') {
            const file = DOM.achievementImageInput.files[0];
            if (file) {
                if (file.size > 2 * 1024 * 1024) { alert("Image file is too large (max 2MB)."); return; }
                const reader = new FileReader();
                reader.onloadend = () => processSave(reader.result);
                reader.onerror = () => alert("Error reading image file.");
                reader.readAsDataURL(file);
            } else if (isEditing && achievement.type === 'image' && achievement.content) {
                processSave(achievement.content);
            } else if (!isEditing || (isEditing && achievement.type !== 'image')) {
                alert("Please select an image file."); return;
            }
        }
    }
    function promptRemoveAchievement(achievementKey, achievementId) {
        DOM.confirmDeleteAchievementBtn.dataset.achievementKey = achievementKey;
        DOM.confirmDeleteAchievementBtn.dataset.achievementId = achievementId;
        os.openModal(DOM.confirmDeleteAchievementModal);
    }
    function confirmRemoveAchievement(achievementKey, achievementId) {
        if (!appData.achievements[achievementKey]) return;
        const achIndex = appData.achievements[achievementKey].findIndex(ach => ach.id === achievementId);
        if (achIndex === -1) return;
        const achievementToRemove = appData.achievements[achievementKey][achIndex];
        const xpToRemove = achievementToRemove.xp;
        const keyParts = achievementKey.split('_');
        const areaName = keyParts.slice(1, keyParts.length -1).join('_');
        appData.achievements[achievementKey].splice(achIndex, 1);
        if (appData.achievements[achievementKey].length === 0) delete appData.achievements[achievementKey];
        if (achievementToRemove.xpAwarded) {
            subtractXpFromArea(areaName, xpToRemove);
            updateQuestProgress(areaName, -xpToRemove);
        }
        os.closeModal(DOM.confirmDeleteAchievementModal);
        renderGrid();
        os.saveAppData();
    }
    function xpForNextLevel(currentLevel) {
        if (currentLevel <= 0) return 50;
        return Math.floor(50 * Math.pow(currentLevel, 1.5));
    }
    function addXpToArea(areaName, xpAmount) {
        const area = appData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp += xpAmount;
            let leveledUp = false;
            let requiredForNext = xpForNextLevel(area.level);
            while (area.xp >= requiredForNext && requiredForNext > 0) {
                area.xp -= requiredForNext;
                area.level++;
                leveledUp = true;
                requiredForNext = xpForNextLevel(area.level);
            }
            if (leveledUp) {
                alert(`${os.decodeHtmlEntities(area.name)} leveled up to Level ${area.level}!`);
                generateQuestsForCurrentWeekIfNeeded(true);
            }
        }
    }
    function subtractXpFromArea(areaName, xpAmount) {
        const area = appData.areas.find(a => a.name === areaName);
        if (area) {
            area.xp -= xpAmount;
            let deLeveled = false;
            while (area.xp < 0) {
                if (area.level > 1) {
                    area.level--;
                    deLeveled = true;
                    area.xp += xpForNextLevel(area.level);
                } else { area.xp = 0; break; }
            }
            if (deLeveled) generateQuestsForCurrentWeekIfNeeded(true);
        }
    }
    function generateQuestsForCurrentWeekIfNeeded(forceRegenerate = false) {
        const weekId = getCurrentWeekId();
        if (!appData.quests[weekId] || forceRegenerate) appData.quests[weekId] = [];
        if (appData.areas.length < 1 && !forceRegenerate && appData.quests[weekId].length === 0) return;
        if (forceRegenerate || (appData.quests[weekId].length === 0 && appData.areas.length > 0)) {
            if (forceRegenerate) appData.quests[weekId] = [];
            const questsToPotentiallyGenerate = Math.min(MAX_WEEKLY_QUESTS, appData.areas.length, 3);
            const availableAreas = [...appData.areas].filter(area => !appData.quests[weekId].some(q => q.areaName === area.name));
            let shuffledAreas = [...(availableAreas.length > 0 ? availableAreas : appData.areas)];
            for (let i = shuffledAreas.length - 1; i > 0; i--) { // Fisher-Yates shuffle
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledAreas[i], shuffledAreas[j]] = [shuffledAreas[j], shuffledAreas[i]];
            }
            for (let i = 0; i < questsToPotentiallyGenerate && appData.quests[weekId].length < MAX_WEEKLY_QUESTS; i++) {
                if (shuffledAreas.length === 0) break;
                const selectedArea = shuffledAreas.pop();
                if (!selectedArea || (!forceRegenerate && appData.quests[weekId].some(q => q.areaName === selectedArea.name))) continue;
                const targetXPEarned = 20 + (selectedArea.level * 10);
                const rewardXP = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5);
                appData.quests[weekId].push({
                    id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}_${i}`,
                    areaName: selectedArea.name,
                    description: `Earn ${targetXPEarned} XP in "${os.decodeHtmlEntities(selectedArea.name)}" this week.`,
                    targetXPEarned: targetXPEarned, currentXPEarned: 0, rewardXP: rewardXP, completed: false
                });
            }
        }
    }
    function updateQuestProgress(areaName, xpGained) {
        const weekId = getCurrentWeekId();
        if (!appData.quests || !appData.quests[weekId]) return;
        let questCompletedThisUpdate = false;
        appData.quests[weekId].forEach(quest => {
            if (quest.areaName === areaName && !quest.completed) {
                quest.currentXPEarned += xpGained;
                if (quest.currentXPEarned < 0) quest.currentXPEarned = 0;
                if (quest.currentXPEarned >= quest.targetXPEarned) {
                    quest.completed = true;
                    quest.currentXPEarned = quest.targetXPEarned;
                    addXpToArea(quest.areaName, quest.rewardXP);
                    alert(`Quest Completed: ${os.decodeHtmlEntities(quest.description)}\n+${quest.rewardXP} XP to ${os.decodeHtmlEntities(quest.areaName)}!`);
                    questCompletedThisUpdate = true;
                }
            }
        });
        if (questCompletedThisUpdate) { renderGrid(); os.saveAppData(); }
    }
    function showQuests() {
        const weekId = getCurrentWeekId();
        DOM.questsList.innerHTML = '';
        generateQuestsForCurrentWeekIfNeeded();
        const currentQuests = appData.quests[weekId] || [];
        if (currentQuests.length === 0) {
            DOM.questsList.innerHTML = `<p>No quests available for this week.${appData.areas.length === 0 ? ' Add areas first!' : ' Create quests manually.'}</p>`;
        } else {
            currentQuests.forEach(quest => {
                const questDiv = document.createElement('div');
                questDiv.className = 'quest-item' + (quest.completed ? ' completed' : '');
                questDiv.style.cssText = "padding: 8px; border: 1px solid #ACA899; margin-bottom: 8px; background-color: #FFF; border-radius: 3px; position: relative;" + (quest.completed ? "background-color: #DFF0D8; text-decoration: line-through; color: #508a50;" : "");
                questDiv.innerHTML = `
                    <div class="quest-title" style="font-weight: bold; margin-bottom: 5px; color: ${quest.completed ? '#006400' : '#0039A9'};">${`Quest for: ${os.decodeHtmlEntities(quest.areaName)}`}</div>
                    <div class="quest-details" style="font-size: 0.95em; margin-bottom: 3px;">${os.decodeHtmlEntities(quest.description)}</div>
                    <div class="quest-progress" style="font-size: 0.85em; color: #555; margin-top: 3px; margin-bottom: 25px;">Progress: ${Math.min(quest.currentXPEarned, quest.targetXPEarned)} / ${quest.targetXPEarned} XP. Reward: ${quest.rewardXP} XP.</div>
                    <div class="quest-actions" style="position: absolute; bottom: 5px; right: 5px;">
                        ${!quest.completed ? `<button class="xp-button refresh-quest-btn" data-quest-id="${quest.id}" style="padding: 2px 5px; font-size: 10px; min-width: auto;">Refresh</button>` : ''}
                    </div>`;
                DOM.questsList.appendChild(questDiv);
            });
        }
        DOM.addQuestBtn.disabled = currentQuests.length >= MAX_WEEKLY_QUESTS;
        os.openModal(DOM.questsModal);
    }
    function openCreateQuestModal() {
        const weekId = getCurrentWeekId();
        if (appData.quests[weekId] && appData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Maximum of ${MAX_WEEKLY_QUESTS} quests per week reached.`); return;
        }
        if (appData.areas.length === 0) { alert("Please create at least one Area first."); return; }
        DOM.newQuestAreaNameSelect.innerHTML = '';
        appData.areas.forEach(area => {
            const option = document.createElement('option');
            option.value = area.name; option.textContent = os.decodeHtmlEntities(area.name);
            DOM.newQuestAreaNameSelect.appendChild(option);
        });
        DOM.newQuestDescriptionInput.value = '';
        DOM.newQuestTargetXPInput.value = 30;
        DOM.newQuestRewardXPInput.value = 50;
        os.openModal(DOM.createQuestModal);
    }
    function saveNewQuest() {
        const weekId = getCurrentWeekId();
        if (!appData.quests[weekId]) appData.quests[weekId] = [];
        if (appData.quests[weekId].length >= MAX_WEEKLY_QUESTS) {
            alert(`Cannot add new quest: Maximum of ${MAX_WEEKLY_QUESTS} quests reached.`); return;
        }
        const areaName = DOM.newQuestAreaNameSelect.value;
        const description = DOM.newQuestDescriptionInput.value.trim();
        const targetXP = parseInt(DOM.newQuestTargetXPInput.value);
        const rewardXP = parseInt(DOM.newQuestRewardXPInput.value);
        if (!areaName || !description || isNaN(targetXP) || targetXP <= 0 || isNaN(rewardXP) || rewardXP <= 0) {
            alert("Please fill all fields correctly."); return;
        }
        appData.quests[weekId].push({
            id: `quest_${weekId}_${areaName.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName, description, targetXPEarned: targetXP, currentXPEarned: 0, rewardXP, completed: false
        });
        os.closeModal(DOM.createQuestModal);
        showQuests();
        os.saveAppData();
    }
    function promptRefreshQuest(questId) {
        DOM.confirmRefreshQuestBtn.dataset.questIdToRefresh = questId;
        os.openModal(DOM.confirmRefreshQuestModal);
    }
    function generateSingleRandomQuest(weekId, questToReplace = null) {
        if (appData.areas.length === 0) return null;
        let potentialAreas = [...appData.areas];
        if (questToReplace && potentialAreas.length > 1) {
            const filtered = potentialAreas.filter(a => a.name !== questToReplace.areaName);
            if (filtered.length > 0) potentialAreas = filtered;
        }
        if(potentialAreas.length === 0) potentialAreas = [...appData.areas];
        const selectedArea = potentialAreas[Math.floor(Math.random() * potentialAreas.length)];
        const baseTarget = 20 + (selectedArea.level * 10);
        const targetXPEarned = Math.max(10, Math.round(baseTarget + (Math.random() * baseTarget * 0.3) - (baseTarget * 0.15)) );
        const baseReward = XP_PER_QUEST_COMPLETED_BASE + (selectedArea.level * 5);
        const rewardXP = Math.max(10, Math.round(baseReward + (Math.random() * baseReward * 0.2) - (baseReward * 0.1)));
        return {
            id: `quest_${weekId}_${selectedArea.name.replace(/\s+/g, '-')}_${Date.now()}`,
            areaName: selectedArea.name,
            description: `Earn ${targetXPEarned} XP in "${os.decodeHtmlEntities(selectedArea.name)}" this week. (Refreshed)`,
            targetXPEarned, currentXPEarned: 0, rewardXP, completed: false
        };
    }
    function confirmAndRefreshQuest() {
        const questIdToRefresh = DOM.confirmRefreshQuestBtn.dataset.questIdToRefresh;
        const weekId = getCurrentWeekId();
        if (!questIdToRefresh || !appData.quests[weekId]) { os.closeModal(DOM.confirmRefreshQuestModal); return; }
        const questIndex = appData.quests[weekId].findIndex(q => q.id === questIdToRefresh);
        if (questIndex === -1) { os.closeModal(DOM.confirmRefreshQuestModal); return; }
        const oldQuest = appData.quests[weekId][questIndex];
        appData.quests[weekId].splice(questIndex, 1);
        const newQuest = generateSingleRandomQuest(weekId, oldQuest);
        if (newQuest) appData.quests[weekId].push(newQuest);
        else if (appData.areas.length > 0) alert("Could not generate a new quest.");
        os.closeModal(DOM.confirmRefreshQuestModal);
        showQuests();
        os.saveAppData();
    }

    function navigateWeek(offsetInDays) {
        const currentMon = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        currentMon.setDate(currentMon.getDate() + offsetInDays);
        appData.currentWeekStartDate = getMonday(currentMon).toISOString().split('T')[0];
        updateDateDisplay(); renderWeekdayHeaders(); checkAndAwardScheduledXP(); renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        os.saveAppData();
    }
    function navigateDay(offset) {
        appData.selectedDayIndex += offset;
        let weekChanged = false;
        let currentMonDate = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
        if (appData.selectedDayIndex < 0) {
            currentMonDate.setDate(currentMonDate.getDate() - 7);
            appData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            appData.selectedDayIndex = 6; weekChanged = true;
        } else if (appData.selectedDayIndex > 6) {
            currentMonDate.setDate(currentMonDate.getDate() + 7);
            appData.currentWeekStartDate = getMonday(currentMonDate).toISOString().split('T')[0];
            appData.selectedDayIndex = 0; weekChanged = true;
        }
        updateDateDisplay(); renderWeekdayHeaders(); checkAndAwardScheduledXP(); renderGrid();
        if (weekChanged) generateQuestsForCurrentWeekIfNeeded();
        os.saveAppData();
    }
    function goToThisWeek() {
        appData.currentWeekStartDate = getMonday(new Date()).toISOString().split('T')[0];
        if(appData.viewMode === 'day') {
            const today = new Date();
            appData.selectedDayIndex = (today.getDay() === 0) ? 6 : today.getDay() - 1;
        }
        updateViewControls(); updateDateDisplay(); renderWeekdayHeaders(); checkAndAwardScheduledXP(); renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        os.saveAppData();
    }
    function toggleViewMode() {
        const state = os.getAppData().windowStates?.xpTrackerWindow; // Access through OS API if needed or assume direct access
        const wasMaximized = DOM.xpMainWindow.classList.contains('true-maximized');
        const wasMinimized = DOM.xpMainWindow.classList.contains('minimized');

        if (appData.viewMode === 'week') {
            appData.viewMode = 'day';
            minTrackerAppWidth = 375;
            const today = new Date();
            const currentWeekMondayObj = parseYYYYMMDDToLocalDate(appData.currentWeekStartDate);
            const checkDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            const weekStartCheck = new Date(currentWeekMondayObj.getFullYear(), currentWeekMondayObj.getMonth(), currentWeekMondayObj.getDate());
            const weekEndCheck = new Date(weekStartCheck); weekEndCheck.setDate(weekStartCheck.getDate() + 6);
            if (checkDate >= weekStartCheck && checkDate <= weekEndCheck) {
                appData.selectedDayIndex = (today.getDay() === 0) ? 6 : today.getDay() - 1;
            } else if (appData.selectedDayIndex === undefined || appData.selectedDayIndex < 0 || appData.selectedDayIndex > 6) {
                appData.selectedDayIndex = 0;
            }
        } else {
            appData.viewMode = 'week';
            minTrackerAppWidth = 750;
        }
        
        if (!wasMaximized && !wasMinimized) {
            let currentWidth = DOM.xpMainWindow.offsetWidth;
            if (currentWidth < minTrackerAppWidth) {
                DOM.xpMainWindow.style.width = minTrackerAppWidth + 'px';
                if(state) { state.width = minTrackerAppWidth; state.userManuallySet = false; }
            } else if (state && !state.userManuallySet) {
                 // os.setWindowDefaults('xpTrackerWindow'); // This would need to be an OS function
            }
        }
        updateViewControls(); updateDateDisplay(); renderWeekdayHeaders(); renderGrid();
        os.saveAppData();
    }

    function handleAppWindowResize() {
        if (DOM.xpMainWindow.classList.contains('minimized') || DOM.xpMainWindow.style.display === 'none') return;
        checkControlsBarLayout();
    }
    function checkControlsBarLayout() {
        const controlsBar = DOM.controlsBar;
        if (!controlsBar || !controlsBar.clientWidth) return;
        const children = Array.from(controlsBar.children).filter(el => el.offsetParent !== null); // Only visible children
        if (children.length === 0) return;
        
        const originalClasses = controlsBar.className;
        controlsBar.className = 'controls-bar layout-single-row'; // Temporarily set to measure
        let totalChildrenWidth = 0;
        children.forEach(child => {
            const childStyle = getComputedStyle(child);
            totalChildrenWidth += child.scrollWidth + parseFloat(childStyle.marginLeft) + parseFloat(childStyle.marginRight);
        });
        controlsBar.className = originalClasses; // Restore

        const controlsBarClientWidth = controlsBar.clientWidth - (parseFloat(getComputedStyle(controlsBar).paddingLeft) + parseFloat(getComputedStyle(controlsBar).paddingRight));
        if (totalChildrenWidth > controlsBarClientWidth && controlsBarClientWidth > 0) {
            controlsBar.classList.add('layout-multi-row');
            controlsBar.classList.remove('layout-single-row');
        } else {
            controlsBar.classList.add('layout-single-row');
            controlsBar.classList.remove('layout-multi-row');
        }
    }


    DOM.gridBody.addEventListener('click', function(event) {
        const target = event.target;
        if (target.classList.contains('delete-area-btn')) {
            promptRemoveArea(target.dataset.areaName);
        } else if (target.classList.contains('edit-ach-btn')) {
            openAddEditAchievementModal(null, null, target.dataset.achKey, target.dataset.achId);
        } else if (target.classList.contains('remove-ach-btn')) {
            promptRemoveAchievement(target.dataset.achKey, target.dataset.achId);
        } else if (target.classList.contains('achievement-add-btn-cell')) {
            openAddEditAchievementModal(target.dataset.areaName, parseInt(target.dataset.dayIndex));
        }
    });
    DOM.addAreaBtn.addEventListener('click', () => os.openModal(DOM.newAreaModal));
    DOM.saveNewAreaBtn.addEventListener('click', saveNewArea);
    DOM.newAreaNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') saveNewArea(); });
    DOM.saveAchievementBtn.addEventListener('click', saveOrUpdateAchievement);
    DOM.achievementTypeRadios.forEach(radio => radio.addEventListener('change', toggleAchievementInputType));
    DOM.prevWeekBtn.addEventListener('click', () => { if (appData.viewMode === 'week') navigateWeek(-7); else navigateDay(-1); });
    DOM.nextWeekBtn.addEventListener('click', () => { if (appData.viewMode === 'week') navigateWeek(7); else navigateDay(1); });
    DOM.thisWeekBtn.addEventListener('click', goToThisWeek);
    DOM.toggleViewBtn.addEventListener('click', toggleViewMode);
    DOM.showQuestsBtn.addEventListener('click', showQuests);
    DOM.addQuestBtn.addEventListener('click', openCreateQuestModal);
    DOM.saveNewQuestBtn.addEventListener('click', saveNewQuest);
    DOM.questsList.addEventListener('click', function(event) {
        if (event.target.classList.contains('refresh-quest-btn')) {
            promptRefreshQuest(event.target.dataset.questId);
        }
    });
    DOM.confirmRefreshQuestBtn.addEventListener('click', confirmAndRefreshQuest);
    DOM.confirmRemoveBtn.addEventListener('click', function() {
        const areaNameToRemove = this.dataset.areaNameToRemove;
        if (areaNameToRemove) {
            removeArea(areaNameToRemove);
            os.closeModal(DOM.confirmRemoveAreaModal);
            delete this.dataset.areaNameToRemove;
        }
    });
    DOM.confirmDeleteAchievementBtn.addEventListener('click', function() {
        confirmRemoveAchievement(this.dataset.achievementKey, this.dataset.achievementId);
    });
    DOM.modalCloseButtons.forEach(button => {
        button.addEventListener('click', (event) => {
            const modalId = event.target.dataset.modalId || event.target.closest('.modal').id;
            if (modalId) os.closeModal(appWindow.querySelector('#'+modalId));
        });
    });
    
    const appConfig = os.getAppWindow().parentElement.querySelector(`#xpTracker-config`);
    if (appConfig) {
        const config = JSON.parse(appConfig.textContent);
        minTrackerAppWidth = config.minWidth || 750;
    }


    updateViewControls();
    updateDateDisplay();
    renderWeekdayHeaders();
    checkAndAwardScheduledXP();
    renderGrid();
    generateQuestsForCurrentWeekIfNeeded();
    handleAppWindowResize(); 

    const resizeObserver = new ResizeObserver(handleAppWindowResize);
    resizeObserver.observe(DOM.xpMainWindow);
    
    this.onOpen = (win) => {
        updateViewControls();
        updateDateDisplay();
        renderWeekdayHeaders();
        checkAndAwardScheduledXP();
        renderGrid();
        generateQuestsForCurrentWeekIfNeeded();
        handleAppWindowResize();
    };
    this.onResize = handleAppWindowResize;


    </script>
</body>
